<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>java | 小高笔记</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link ref="icon" href="/favicon.ico">
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.35bcedcf.css" as="style"><link rel="preload" href="/assets/js/app.d13f59f1.js" as="script"><link rel="preload" href="/assets/js/2.53646e3a.js" as="script"><link rel="preload" href="/assets/js/3.bb50f79a.js" as="script"><link rel="prefetch" href="/assets/js/10.5ccc8fdd.js"><link rel="prefetch" href="/assets/js/11.aa33a8de.js"><link rel="prefetch" href="/assets/js/12.993b4d84.js"><link rel="prefetch" href="/assets/js/13.5507d9bc.js"><link rel="prefetch" href="/assets/js/14.0048d491.js"><link rel="prefetch" href="/assets/js/15.0455f1d1.js"><link rel="prefetch" href="/assets/js/16.f911e976.js"><link rel="prefetch" href="/assets/js/17.2510d920.js"><link rel="prefetch" href="/assets/js/18.e2e23205.js"><link rel="prefetch" href="/assets/js/19.d5043b46.js"><link rel="prefetch" href="/assets/js/20.07b6a18c.js"><link rel="prefetch" href="/assets/js/21.60063212.js"><link rel="prefetch" href="/assets/js/22.0bc5fe12.js"><link rel="prefetch" href="/assets/js/23.9a2edd04.js"><link rel="prefetch" href="/assets/js/24.dac6e202.js"><link rel="prefetch" href="/assets/js/25.156ad714.js"><link rel="prefetch" href="/assets/js/26.b27149f5.js"><link rel="prefetch" href="/assets/js/27.6d559b79.js"><link rel="prefetch" href="/assets/js/28.c42a444d.js"><link rel="prefetch" href="/assets/js/29.4836f5f1.js"><link rel="prefetch" href="/assets/js/30.37b5d171.js"><link rel="prefetch" href="/assets/js/31.919c37fa.js"><link rel="prefetch" href="/assets/js/32.c5479266.js"><link rel="prefetch" href="/assets/js/33.ef7cdcee.js"><link rel="prefetch" href="/assets/js/34.0d49d121.js"><link rel="prefetch" href="/assets/js/35.a96ba84d.js"><link rel="prefetch" href="/assets/js/36.280625b4.js"><link rel="prefetch" href="/assets/js/37.a1358acd.js"><link rel="prefetch" href="/assets/js/38.d6dbc7ba.js"><link rel="prefetch" href="/assets/js/39.97b4bcfd.js"><link rel="prefetch" href="/assets/js/4.35661e66.js"><link rel="prefetch" href="/assets/js/40.684a77c3.js"><link rel="prefetch" href="/assets/js/41.5ef9d50f.js"><link rel="prefetch" href="/assets/js/42.444f193c.js"><link rel="prefetch" href="/assets/js/43.e6bf2917.js"><link rel="prefetch" href="/assets/js/44.6241887c.js"><link rel="prefetch" href="/assets/js/45.ee459281.js"><link rel="prefetch" href="/assets/js/46.42a39b62.js"><link rel="prefetch" href="/assets/js/47.96607b08.js"><link rel="prefetch" href="/assets/js/48.2dc75c63.js"><link rel="prefetch" href="/assets/js/49.1404ad3e.js"><link rel="prefetch" href="/assets/js/5.2a73e3c3.js"><link rel="prefetch" href="/assets/js/50.eaa708d4.js"><link rel="prefetch" href="/assets/js/51.813059e2.js"><link rel="prefetch" href="/assets/js/52.b2b30732.js"><link rel="prefetch" href="/assets/js/53.83e35218.js"><link rel="prefetch" href="/assets/js/54.5114b1c2.js"><link rel="prefetch" href="/assets/js/55.31992a29.js"><link rel="prefetch" href="/assets/js/56.9d768f0f.js"><link rel="prefetch" href="/assets/js/57.ed73a721.js"><link rel="prefetch" href="/assets/js/58.be77d415.js"><link rel="prefetch" href="/assets/js/59.8ef3b6a8.js"><link rel="prefetch" href="/assets/js/6.191aaf39.js"><link rel="prefetch" href="/assets/js/60.4fd87fd0.js"><link rel="prefetch" href="/assets/js/61.361e594c.js"><link rel="prefetch" href="/assets/js/62.3801fa63.js"><link rel="prefetch" href="/assets/js/63.fb124fab.js"><link rel="prefetch" href="/assets/js/64.bdb473d5.js"><link rel="prefetch" href="/assets/js/65.8b14388b.js"><link rel="prefetch" href="/assets/js/66.6ad4e223.js"><link rel="prefetch" href="/assets/js/67.caf1ddfb.js"><link rel="prefetch" href="/assets/js/68.84d22d1b.js"><link rel="prefetch" href="/assets/js/69.2411fe3a.js"><link rel="prefetch" href="/assets/js/7.029c4464.js"><link rel="prefetch" href="/assets/js/70.b310e685.js"><link rel="prefetch" href="/assets/js/71.0e077ea4.js"><link rel="prefetch" href="/assets/js/72.2b6d7f80.js"><link rel="prefetch" href="/assets/js/73.c3e37b24.js"><link rel="prefetch" href="/assets/js/8.37f8fc14.js"><link rel="prefetch" href="/assets/js/9.9b32826c.js">
    <link rel="stylesheet" href="/assets/css/0.styles.35bcedcf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">小高笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/pages/miscellaneous/reg/reg.html" class="nav-link">
  杂记
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端" class="mobile-dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/frontend/htmlcssLearn.html" class="nav-link">
  html+css3+移动前端
</a></li><li class="dropdown-item"><!----> <a href="/pages/frontend/js.html" class="nav-link">
  javaScript
</a></li><li class="dropdown-item"><!----> <a href="/pages/frontend/jses6.html" class="nav-link">
  javaScript-es6
</a></li><li class="dropdown-item"><!----> <a href="/pages/frontend/ts.html" class="nav-link">
  typeScript
</a></li><li class="dropdown-item"><!----> <a href="/pages/frontend/nodejs.html" class="nav-link">
  nodeJs
</a></li><li class="dropdown-item"><!----> <a href="/pages/frontend/webpack/webpack.html" class="nav-link">
  webpack
</a></li><li class="dropdown-item"><!----> <a href="/pages/frontend/react/react.html" class="nav-link">
  react
</a></li><li class="dropdown-item"><!----> <a href="/pages/frontend/vue/vue.html" class="nav-link">
  vue
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="后端" class="dropdown-title"><span class="title">后端</span> <span class="arrow down"></span></button> <button type="button" aria-label="后端" class="mobile-dropdown-title"><span class="title">后端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/backend/java.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  java
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/pages/miscellaneous/reg/reg.html" class="nav-link">
  杂记
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端" class="mobile-dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/frontend/htmlcssLearn.html" class="nav-link">
  html+css3+移动前端
</a></li><li class="dropdown-item"><!----> <a href="/pages/frontend/js.html" class="nav-link">
  javaScript
</a></li><li class="dropdown-item"><!----> <a href="/pages/frontend/jses6.html" class="nav-link">
  javaScript-es6
</a></li><li class="dropdown-item"><!----> <a href="/pages/frontend/ts.html" class="nav-link">
  typeScript
</a></li><li class="dropdown-item"><!----> <a href="/pages/frontend/nodejs.html" class="nav-link">
  nodeJs
</a></li><li class="dropdown-item"><!----> <a href="/pages/frontend/webpack/webpack.html" class="nav-link">
  webpack
</a></li><li class="dropdown-item"><!----> <a href="/pages/frontend/react/react.html" class="nav-link">
  react
</a></li><li class="dropdown-item"><!----> <a href="/pages/frontend/vue/vue.html" class="nav-link">
  vue
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="后端" class="dropdown-title"><span class="title">后端</span> <span class="arrow down"></span></button> <button type="button" aria-label="后端" class="mobile-dropdown-title"><span class="title">后端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/backend/java.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  java
</a></li></ul></div></div> <!----></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="java"><a href="#java" class="header-anchor">#</a> java</h1> <p><strong>基本数据类型转换</strong></p> <ol><li><p>自动提升类型：当容量小的变量和大容量变量数据类型做运算时，结果会自动提升为大容量数据类型。</p> <p>根据 byte→char→short→int→long→float→double→string</p></li> <li><p>强制类型转换</p> <p>自动提升类型的逆向操作，需要在前面添加(强制转换的类型)</p></li></ol> <p><strong>数组</strong></p> <ul><li><p>选择排序</p> <ul><li>直接选择排序、堆排序</li></ul></li> <li><p>交换排序</p> <ul><li><p>冒泡排序、快速排序</p></li> <li><p>冒泡排序</p> <ul><li><p>排序思想：</p> <ul><li><p>比较每每相邻的两个元素，如果第一个比第二个大，则交换他们的位置，这样第一遍后最大的那个数会是最后一个。</p></li> <li><p>针对每一个元素都重复以上的步骤，最后一个不用。</p></li></ul></li></ul></li></ul></li> <li><p>插入排序</p> <ul><li>直接插入排序、折半插入排序、Shell排序</li></ul></li> <li><p>归并排序</p></li> <li><p>桶式排序</p></li> <li><p>基数排序</p></li></ul> <p><strong>面向对象：封装</strong></p> <p><img src="/assets/img/49_3zwmNeuk2b.aa216dc2.png" alt=""></p> <p><strong>代码块</strong></p> <ol><li><p>代码块的作用：用来初始化类、对象</p></li> <li><p>代码块有修饰的话，只能是static</p></li> <li><p>分类：分为静态代码块和非静态代码块</p></li> <li><p>静态代码块和非静态代码块的区别</p> <p>静态代码块：</p> <ol><li><p>定义：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">static</span><span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>代码
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>随着类的加载而执行，且只执行一次</p></li> <li><p>作用：初始化当前类的静态属性</p></li> <li><p>如果定义类多个静态代码块，则按照定义顺序执行。</p></li> <li><p>静态代码块只能调用静态的属性，静态的方法，不能调用非静态的结构</p></li></ol> <p>非静态代码块：</p> <ol><li><p>定义：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>代码
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>随着创建对象而执行，就执行一次非静态代码块</p></li> <li><p>作用：可以在创建对象时，对对象属性进行初始化。</p></li> <li><p>多个非静态代码块，按照定义顺序执行。</p></li> <li><p>非静态代码块可以调用静态的属性，静态的方法和非静态的属性和方法。</p></li></ol></li></ol> <p><strong>静态代码块、非静态代码块、和构造函数执行顺序</strong></p> <p>如果是有继承的父类，则在子类new一个对象时，如果调用到父类的构造函数，则先执行父类的静态代码块，再执行子类静态代码块、</p> <p>再执行父类非静态代码块和父类构造函数，最后在执行子类非静态代码块和子类构造方法。</p> <p>执行顺序：静态代码块→非静态代码块→构造函数</p> <p><strong>抽象abstract</strong></p> <ul><li><p>修饰类：抽象类</p> <ul><li><p>此类不能实例化</p></li> <li><p>抽象类中一定有构造器，便于子类实例化时调用。</p></li> <li><p>开发中，都会提供抽象类的子类，让子类对象实例化，完成相关操作。</p></li></ul></li> <li><p>修饰方法：抽象方法</p> <ul><li><p>抽象方法只方法的声明，没有方法体</p></li> <li><p>包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法</p></li> <li><p>若子类重写了父类中的所有抽象方法，此子类可以实例化</p></li> <li><p>若子类没有重写父类的所有抽象方法，子类也是一个抽象类。需要abstract来修饰</p></li></ul></li></ul> <p><strong>接口interface</strong></p> <ul><li><p>接口使用interface定义</p></li> <li><p>如何定义接口</p> <ul><li><p>在JDK7以前，只能定义抽象方法和全局常量</p></li> <li><p>在JDK8以后，增加了静态方法和默认方法</p></li></ul></li> <li><p>接口不能定义构造器，不能实例化</p></li></ul> <p><strong>多线程</strong></p> <p>多线程的创建</p> <p><strong>方式一：</strong></p> <ol><li><p>创建一个继承于Thred类的子类</p></li> <li><p>重写Thread类的run方法</p></li> <li><p>创建Thread类子类的实例对象</p></li> <li><p>通过此对象调用start方法执行</p></li> <li><p>一些线程常用方法</p> <ol><li><p>start 启动线程，并执行对象的run方法</p></li> <li><p>run 线程在被调用时执行的操作</p></li> <li><p>getName 获取线程名称</p></li> <li><p>setName 设置线程名称</p></li> <li><p>currentThread 返回当前线程</p></li> <li><p>yield 释放当前cpu执行权</p></li> <li><p>join 在线程a中调用线程b的join方法，线程a进入阻塞状态，直到线程b执行完，a才结束阻塞状态。</p></li> <li><p>stop 强制结束线程，不再执行。已过时</p></li> <li><p>sleep(long milltime)  让当前线程 睡眠，在指定的时间内，线程时阻塞状态。</p></li> <li><p>isAlive 判断当前线程是否存活</p></li> <li><p>setPriority 设置线程优先级</p></li></ol></li></ol> <p><strong>方式二： 实现runnable接口</strong></p> <ol><li><p>创建一个实现类runnable接口的类</p></li> <li><p>实现类去实现runnable中的抽象方法run</p></li> <li><p>创建实现类的对象</p></li> <li><p>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</p></li> <li><p>通过thread类的对象调用start方法</p></li></ol> <p><strong>比较两种方式</strong></p> <p>优先选择方式二，实现的方式更适合来处理多个线程有数据共享的情况。</p> <p><strong>方式三：实现Callable接口</strong></p> <ul><li><p>实现call方法，相比run方法实现，可以有返回值</p></li> <li><p>方法可以抛出异常</p></li> <li><p>支持范型的返回值</p></li> <li><p>需要借助FutureTask类，比如获取返回结果</p> <ul><li><p>Future接口</p> <ul><li><p>可以对具体Runnable、Cellable任务的执行结果进行取消、查询是否完成、获取结果等。</p></li> <li><p>FutureTask是Future接口的唯一实现类</p></li> <li><p>FutureTask同时实现类Runnable、Future接口。它即可以作为Runnable被线程执行，又可以作为Future得到Callable的值。</p></li></ul></li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//1创建一个实现Callabel实现类</span>
<span class="token keyword">class</span> <span class="token class-name">NumThread</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token punctuation">{</span>
  <span class="token comment">//2、实现call方法</span>
  <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//多线程代码</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//3、创建一个Callabel实现类对象</span>
<span class="token class-name">NumThread</span> num <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NumThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">//4、创建一个FutureTask实现类对象,把Callabel实现类对象作为参数</span>
<span class="token class-name">FutureTask</span> futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>
<span class="token comment">//5、创建Thread类对象，执行start方法</span>
<span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span>
<span class="token comment">//执行start方法</span>
thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div></li></ul> <p><strong>方式四：使用线程池创建</strong></p> <p><img src="/assets/img/44_2cAiRrskP1.86e21716.png" alt=""></p> <p><strong>线程的生命周期</strong></p> <p>线程的状态：Thread.State类表示线程状态</p> <ul><li><p>新建：</p> <p>当一个Thread类或子类对象被声明创建时，新生的线程对象处于新建状态。</p></li> <li><p>就绪：</p> <p>新建的线程处于被start后，将进入线程队列等待CPU时间片，此时它已具备类运行的条件，只是没有分配到CPU</p></li> <li><p>运行：</p> <p>当就绪的线程被调度并获得CPU资源时，便进行运行状态，run方法定义类运行的操作</p></li> <li><p>阻塞：</p> <p>在某些特殊情况下，被人刮起或者执行输入输出操作时，让出cpu并临时中止自己的执行，进入阻塞状态</p></li> <li><p>死亡：</p> <p>线程完成类它的全部工作或者线程被提前强制性得中止或者出现异常导致结束。</p></li></ul> <p><img src="/assets/img/45_i03NMegpUu.aa15f3fe.png" alt=""></p> <p><strong>线程安全问题</strong></p> <ol><li><p>问题：在卖票过程中，出现了重票、错票—&gt;就是出现了线程安全问题</p></li> <li><p>出现原因：当某个线程在操作过程中，尚未操作完成，其他线程参与进来，执行操作。</p></li> <li><p>如何解决：当一个线程进入操作时，其他线程应该等待，即使正在操作的线程阻塞了，也要等待。等到正在执行的线程执行完了，其他线程才能进入执行。</p></li> <li><p>在java中，通过同步机制，来解决线程安全问题</p> <ul><li><p>方式一：同步代码块</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token function">synchronozed</span><span class="token punctuation">(</span>同步监视器<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">//需要被同步的代码</span>
<span class="token punctuation">}</span> 
<span class="token comment">//说明：操作共享数据的代码，即为需要被同步的代码</span>
   共享数据：多个线程共同操作的数据
   同步监视器：俗称：锁。任何一个类的对象，都可以当作锁
     要求：多个线程必须要共用一把锁。
   
</code></pre></div></li> <li><p>方式二：同步方法</p> <p>如果操作的共享数据代码完整的声明在一个方法中，我们不妨将此方法声明同步。</p> <p>在方法加上synchronozed即可。</p> <p>同步方法依然涉及到监视器，只是不需要我们显示声明</p> <p>非静态的同步方法，同步监视器是this</p> <p>静态的同步方法，同步监视器是：当前类本身</p></li> <li><p>方式三Lock锁</p> <ul><li><p>实例化一个ReentrantLock锁类</p></li> <li><p>把要同步的代码之前使用lock类的lock方法</p></li> <li><p>执行完同步代码后在调用lock类的释放锁的方法unlock</p></li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Window</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token keyword">int</span> ticket <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">//共享资源</span>
  <span class="token comment">//实例化锁</span>
  <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">//同步代码</span>
    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div></li></ul></li></ol> <p><strong>线程的通信</strong></p> <p>多个线程之间怎么运行问题，如何进行。</p> <p>涉及到三个方法</p> <ul><li><p>wait 方法 一旦执行此方法，当前线程就会进入阻塞状态，并释放同步机制</p></li> <li><p>notify方法 一旦执行此方法，就会唤醒在等待的线程，如果有多个线程被wait，就优先唤醒优先级较高的那个</p></li> <li><p>notifyAll 方法 唤醒所有在等待的线程</p></li> <li><p>说明：</p> <ul><li><p>三个方法必须写在同步代码里</p></li> <li><p><strong>这三个方法调用者必须是同步代码块或者同步方法中的同步监视器</strong></p></li></ul></li></ul> <p><strong>sleep和wait有何不同</strong></p> <ul><li><p>相同点</p> <p>都能使线程进入阻塞状态</p></li> <li><p>不同点</p> <ul><li><p>两个方法声明的位置不同，sleep是thread类中声明，wait方法是在Object中声明</p></li> <li><p>调用的要求不同：sleep在任何需要调用的地方都可调用，wait方法必须使用在同步代码块中或者同步方法中</p></li> <li><p>关于是否释放同步监视器：如果两个方法都使用在同步代码块和同步方法中，sleep方法不释放锁，wait方法会释放锁</p></li></ul></li></ul> <p><strong>比较器</strong></p> <p>Comparable接口使用</p> <p>实现这个接口，重写compareTo方法，实现自定义类型的比较，可以进行从小到大排序。</p> <p>重写compareTo方法规则：</p> <ul><li><p>如果当前对象this大于形参对象obj，则返回正数</p></li> <li><p>如果当前对象this等于形参对象obj，则返回零</p></li> <li><p>如果当前对象this小于形参对象obj，则返回负整数</p></li></ul> <p>对于自定义类来说，需要排序的话，就可以实现自定力类的CompareTo接口，重写compareTo方法，在compareto方法中指明如何排序</p> <p><strong>注解</strong></p> <p>如何自定义注解，随便拿一个现成注解来仿照写就行。</p> <p>元注解：JDK提供四种元注解</p> <ul><li><p>Retention </p> <p>只能修饰一个注解定义的注解，用于指定该注解的生命周期，@Retention包含一个RetentionPolicy类型的成员变量，使用该注解时必须为该value成员变量指定值：</p> <ul><li><p>RetentionPolicy.SOURCE:在源文件中有效（即源文件保留），通过javac编译时就丢弃，不保留。</p></li> <li><p>CLASS：在class文件中有效即class保留，运行时丢弃，不保留，不会加载到内存中</p></li> <li><p>RUNTIME：在运行时保留即运行时保留，保留在class中，在运行时加载到内存，就可以通过反射进行获取</p></li></ul></li></ul> <p><img src="/assets/img/oSyKz0hoz3.e0a8757a.png" alt=""></p> <ul><li><p>Target</p> <p>用于修饰注解的定义，指定被修饰的注解只能用于哪些程序元素。@Target包含一个value成员变量。</p> <p><img src="/assets/img/YkZhUN7h9p.1ec7c15d.png" alt=""></p></li> <li><p>Document</p> <p>表示所修饰的注解在被javac解析时，保留下来。</p></li> <li><p>Inherited</p></li></ul> <p><strong>集合框架</strong></p> <ul><li><p>collection接口</p> <ul><li><p>List接口 有序的，可重复的数据</p> <ul><li><p>ArrayList</p> <p>线程不安全的，效率高，底层使用object数组存储</p> <p><strong>源码分析JDK7</strong></p> <p>new ArrayList()底层创建了长度是10的object[]的数组elementData，往里添加元素导致容量不够时，则扩容。默认情况下，扩容为原来的1.5倍，同时需要将原数组数据复制到新数组中。</p> <p>开发中建议使用new ArrayList(int count)来确定容量，避免扩容带来的性能消耗。</p> <p><strong>JDK8中的变化</strong></p> <p>在new ArrayList时底层Object数组初始化为{}，并没有创建长度为10的数组，在add添加元素时，底层才创建长度为10的数组</p> <p>后续的擦操作就一样</p></li> <li><p>LinkList</p> <p>底层使用双向链表存储，对于频繁插入和删除操作效率高，查询慢。</p></li> <li><p>Vector</p> <p>线程安全，效率低，底层使用object数组存储</p> <p><strong>源码分析JDK7</strong>和JDK8</p> <p>底层创建了长度是10的object[]的数组elementData，往里添加元素导致容量不够时，则扩容。默认情况下，扩容为原来的2倍，同时需要将原数组数据复制到新数组中。</p></li> <li><p>Set接口 无序的，不可重复的数据</p> <ul><li><p>HashSet</p> <p>线程不安全的，可以存储null值。</p> <p><strong>分析</strong></p> <p>向hashSet添加元素时，首先调用元素a所在类的hashCode方法，计算元素a的哈希值，此哈希值通过某种算法计算出在hashSet底层数组中存放位置，判断此位置上是否以有元素：</p> <ul><li><p>如果没有元素，则元素a添加成功。</p></li> <li><p>如果有其他元素b或者以链条的形式存在多个元素，则比较a元素与b元素的hash值</p> <ul><li><p>如果hash值不同，则元素添加成功</p></li> <li><p>如果hash值相同，则需要在调用a元素的equals方法返回true，添加失败。</p></li></ul></li></ul></li> <li><p>LinkHashSet</p> <p>作为hashSet的子类，遍历内部数据时，可以按照添加顺序遍历。</p></li> <li><p>TreeSet</p> <p>可以按照添加的对象指定属性进行排序。</p> <p>向Treeset中添加数据，要求是相同类的对象。 </p> <p>自然排序中，比较两个对象是否相同的标准为compareTo返回0，不再是equals方法。</p></li></ul></li></ul></li></ul></li> <li><p>Map接口</p> <ul><li><p>HashMap</p> <p>线程不安全，效率高。可以存储null的key和value。</p> <p><strong>JDK分析JDK7</strong></p> <p>hashMap map = new hashMap</p> <p>实例化后，创建了长度是16的Entry[] 数组。</p> <p>map.put(key,value)</p> <p>先利用key所在类的hashcode计算key的哈希值，此哈希值经过某种算法计算后，得到在Entry数组中的位置。</p> <ul><li><p>如果此位置上没有数据，则添加成功。</p></li> <li><p>如果有数据，则比较他们的哈希值是否相同</p> <ul><li><p>如果哈希值不同，则添加成功</p></li> <li><p>如果哈希值是相同的，则比较调用key 所在的equals比较是否相同</p> <ul><li><p>相同则替换相同key的value值。</p></li> <li><p>不相同则添加成功</p></li></ul></li></ul></li></ul> <p>在JDK8中相较于在底层方面的不同</p> <p>new hashmap底层没有创建一个长度为16的数组</p> <p>jdk8底层的数组是nodep[],非entry数组</p> <p>首次调用put方法时，底层去创建长度为16的数组</p> <p>在jdk8中底层结构为数组+链表+红黑树</p> <p>当数组某一个索引位置上以链表的形式存在的数据个数&gt;8且当前数组的长度&gt;64时，此时此索引位置上的所有数据会改成使用红黑树存储。</p> <p><img src="/assets/img/27_6xMl-cG_zg.5f924340.png" alt=""></p></li> <li><p>LinkedHashMap</p></li> <li><p>TreeMap</p></li> <li><p>Hashtable</p> <p>线程安全的，效率低。不可以存储null的key和value。</p></li> <li><p>Properties</p> <p>常用来处理配置文件。key和value都是string类型</p></li></ul></li></ul> <p><strong>范型</strong></p> <p>范型方法不是在类中出现了类中指定的范型就是范型方法，范型方法是在方法中出现了范型结构。范型参数与类的范型参数没有关系。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">copyFromArrayToList</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p><strong>IO流</strong></p> <p>流的体系</p> <table><thead><tr><th>抽象基类</th> <th>节点流</th> <th>缓冲流</th></tr></thead> <tbody><tr><td>InputStream</td> <td>FileInputStream</td> <td>BufferedInputStream</td></tr> <tr><td>OutputStream</td> <td>FileOutputStream</td> <td>BufferedOutputStream</td></tr> <tr><td>Reader</td> <td>FileReader</td> <td>BufferedReader</td></tr> <tr><td>Writer</td> <td>FileWriter</td> <td>BufferedWriter</td></tr></tbody></table> <p><strong>反射</strong></p> <p><img src="/assets/img/14_eWHX0MetoU.be02377c.png" alt=""></p> <ul><li><p>属性</p> <ul><li><p>getFields()获取当前运行时类及父类中声明为public的属性</p></li> <li><p>getDeclaredFields()获取当前运行时类声明的所有属性（不包括父类的属性）</p></li></ul></li> <li><p>方法</p> <ul><li><p>getMethods()和属性是一样的</p></li> <li><p>getDeclaredMethods()和属性是一样的</p></li></ul></li></ul> <p><strong>反射的应用</strong>：<strong>动态代理</strong></p> <p>无论是动态代理还是静态代理，基本思路如下：</p> <ol><li><p>先定义要实现接口</p></li> <li><p>定义被代理类，被代理类实现接口</p></li> <li><p>定义代理类，实现接口</p></li></ol> <ul><li><p>静态代理 编译时已经确定类型</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>staticton</span><span class="token punctuation">;</span>
</code></pre></div><p>//1、定义接口
interface ClothFactory{
public void productCloth();
}
//2、定义代理类
class ClothFactoryProxy implements ClothFactory{
private ClothFactory clothFactory;
public ClothFactoryProxy(ClothFactory clothFactory){
this.clothFactory=clothFactory;
}</p> <div class="language- extra-class"><pre><code>  @Override
  public void productCloth() {
      System.out.println(&quot;做前致工作&quot;);
      clothFactory.productCloth();
      System.out.println(&quot;守候工作&quot;);
  }
</code></pre></div><p>}
//3、定义被代理类
class NikeClothFactory implements ClothFactory{</p> <div class="language- extra-class"><pre><code>  @Override
  public void productCloth() {
      System.out.println(&quot;我要做衣服&quot;);
  }
</code></pre></div><p>}
public class StaticProxyTest {
public static void main(String[] args) {
//创建被代理类
ClothFactory nike = new NikeClothFactory();
//创建代理类
ClothFactoryProxy clothFactoryProxy = new ClothFactoryProxy(nike);
clothFactoryProxy.productCloth();
}</p> <p>}</p> <div class="language- extra-class"><pre class="language-text"><code>
</code></pre></div></li> <li><p>动态代理 根据运行时来确定代理的类型</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>staticton</span><span class="token punctuation">;</span>
</code></pre></div><p>import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;</p> <p>//1、创建接口
interface HuMan{
public void eat(String food);
public String beSelf();
}
//2、创建被代理类
class SupperMan implements HuMan{</p> <div class="language- extra-class"><pre><code>  @Override
  public void eat(String food) {
      System.out.println(&quot;chifanl&quot;+food);
  }

  @Override
  public String beSelf() {
      return &quot;I can fly&quot;;
  }
</code></pre></div><p>}
class MyInvocationHandler implements InvocationHandler {
private Object object;
public MyInvocationHandler(Object object){
this.object = object;
}
@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
return  method.invoke(object,args);
}
}
//3、创建动态代理类
class ProxyFactory{
public static Object getProxyInstance(Object obj){
MyInvocationHandler handler = new MyInvocationHandler(obj);
return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(),handler);
}
}</p> <p>public class ProxyTest {
public static void main(String[] args) {
SupperMan supperMan = new SupperMan();
HuMan proxyInstance = (HuMan) ProxyFactory.getProxyInstance(supperMan);
System.out.println(proxyInstance.beSelf());
proxyInstance.eat(&quot;xxxxxx&quot;);
}</p> <p>}</p> <div class="language- extra-class"><pre class="language-text"><code>
</code></pre></div></li></ul> <p><strong>Lambda表达式</strong></p> <p>→划分为左右两边</p> <p>左边为形参列表、右边为方法体。分为以下几种情况</p> <p>lambda本质：作为接口的实例</p> <ol><li><p>语法格式一：无参数、无返回值</p> <p><img src="/assets/img/32_ndd9qiGx_w.b32f352d.png" alt=""></p></li> <li><p>语法格式二：需要一个参数、无返回值</p> <p><img src="/assets/img/44_xqlSaRStCr.fa6bc370.png" alt=""></p></li> <li><p>语法格式三：数据类型可以省略、因为可由编译器推断得出，称为类型推断</p> <p><img src="/assets/img/57_qhHQyJhwDc.775b13e0.png" alt=""></p></li> <li><p>语法格式四：只有一个参数时、参数的小括号可以省略</p> <p><img src="/assets/img/24_vt9sSmevIM.3816a534.png" alt=""></p></li> <li><p>语法格式五：需要两个以上参数时、多条语句执行，并且可以有返回值</p> <p><img src="/assets/img/35_CUG2npNE8Q.a99a79f7.png" alt=""></p></li> <li><p>语法格式六：只有一条语句时，return与大括号若有，都可以省略。</p> <p><img src="/assets/img/42_ouKbkRWwzt.b035e494.png" alt=""></p></li></ol> <p><strong>函数式接口</strong></p> <p>若一个接口只含有一个方法时，它就是函数式接口，可以使用Lambda表达式实现。</p> <p>JAVA内置四大核心函数式接口</p> <p><img src="/assets/img/51_sh_SI1cVrF.9d91b2c2.png" alt=""></p> <p><img src="/assets/img/12_oK-XhAmWlr.d845b87b.png" alt=""></p> <p><strong>Stream API</strong></p> <p>Stream的中间操作</p> <ol><li><p>筛选与切片</p> <p><img src="/assets/img/53_EY1dYu0bS1.aa07279d.png" alt=""></p></li> <li><p>映射</p> <p><img src="/assets/img/13_DMRSS5rvFb.f3aefbc2.png" alt=""></p></li> <li><p>排序</p> <p><img src="/assets/img/05_F974Ce7Uci.70c9dc18.png" alt=""></p></li></ol> <p>Stream的中止操作</p> <ol><li><p>匹配与查找</p> <p><img src="/assets/img/54_o9hZvIEEiD.685aebee.png" alt=""></p></li> <li><p>归约</p> <p><img src="/assets/img/42_VYXGoiiMgh.4d352e90.png" alt=""></p></li> <li><p>收集</p> <p><img src="/assets/img/47_P2exGVry66.fcaae624.png" alt=""></p></li></ol> <p><strong>Optional类</strong></p> <p>为了避免出现空指针异常，可以使用此类来避免。</p> <p><img src="/assets/img/13_hxfDlCg6jM.4654ec86.png" alt=""></p> <p><img src="/assets/img/CWDxUyQkxj.01a7a188.png" alt=""></p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.d13f59f1.js" defer></script><script src="/assets/js/2.53646e3a.js" defer></script><script src="/assets/js/3.bb50f79a.js" defer></script>
  </body>
</html>
