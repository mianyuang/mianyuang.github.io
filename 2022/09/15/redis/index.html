<!-- build time:Fri Feb 17 2023 08:22:44 GMT+0000 (Coordinated Universal Time) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="学习笔记记录分享站" href="https://mianyuang.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="学习笔记记录分享站" href="https://mianyuang.github.io/atom.xml"><link rel="alternate" type="application/json" title="学习笔记记录分享站" href="https://mianyuang.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://mianyuang.github.io/2022/09/15/redis/"><title>redis - 中间件 | Xiao Gao = 学习笔记记录分享站</title><meta name="generator" content="Hexo 6.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">redis</h1><div class="meta"><span class="item" title="创建时间：2022-09-15 19:18:35"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-09-15T19:18:35+00:00">2022-09-15</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Xiao Gao</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipetv6p75j20zk0m8x6p.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclxp31goj20zk0m8qv5.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipevarprfj20zk0m8npd.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclil3m4ej20zk0m8tn8.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipex2cdtbj20zk0m8x6p.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclimtf7dj20zk0m8qav.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="item" rel="index" title="分类于 中间件"><span itemprop="name">中间件</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://mianyuang.github.io/2022/09/15/redis/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Xiao Gao"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="学习笔记记录分享站"></span><div class="body md" itemprop="articleBody"><h1 id="redis"><a class="anchor" href="#redis">#</a> Redis</h1><h2 id="redis-概述"><a class="anchor" href="#redis-概述">#</a> Redis 概述</h2><p>基于 redis6 的学习</p><h3 id="redis-介绍"><a class="anchor" href="#redis-介绍">#</a> Redis 介绍</h3><ul><li>Redis 是一个开源的 key-value 存储系统。</li><li>和 Memcached 类似，它支持存储的 value 类型相对更多，包括 string (字符串)、list (链表)、set (集合)、zset (sorted set –有序集合) 和 hash（哈希类型）。</li><li>这些数据类型都支持 push/pop、add/remove 及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</li><li>在此基础上，Redis 支持各种不同方式的排序。</li><li>与 memcached 一样，为了保证效率，数据都是缓存在内存中。</li><li>区别的是 Redis 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。</li><li>并且在此基础上实现了 master-slave (主从) 同步。</li></ul><h3 id="应用场景"><a class="anchor" href="#应用场景">#</a> 应用场景</h3><ul><li>配合关系型数据库做高速缓存</li><li>高频次，热门访问的数据，降低数据库 IO。</li><li>分布式架构，做 session 共享。</li></ul><p><img data-src="image_Nwio3kR_x6.png" alt=""></p><p><strong>多样的数据结构存储持久化数据</strong></p><p><img data-src="image_GbrMlUGWmc.png" alt=""></p><h3 id="相关技术"><a class="anchor" href="#相关技术">#</a> 相关技术</h3><p><strong>Redis 使用的是单线程 + 多路 IO 复用技术：</strong></p><p>多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用 select 和 poll 函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）。</p><p>** 串行 vs 多线程 + 锁（memcached） vs 单线程 + 多路 IO 复用 (Redis)**（与 Memcache 三点不同：支持多数据类型，支持持久化，单线程 + 多路 IO 复用）</p><h3 id="rediskey键"><a class="anchor" href="#rediskey键">#</a> Redis（key）键</h3><ul><li>keys * 查看当前库所有 key</li><li>exists key 检查某个 key 是否存在</li><li>type key 查看 key 的类型</li><li>del key 删除指定 key 数据</li><li>unlink key 根据 key 选择非阻塞删除（仅将 key 从 keyspace 元数据中删除，真正删除会在后续异步操作）</li><li>expire key 10 设置 key 过期时间</li><li>ttl key 查看还有多少秒过期 -1 代表永不过期 -2 代表已过期</li><li>select 命令切换数据库</li><li>dbsize 查看当前数据库 key 的数量</li><li>flushdb 清空当前库</li><li>flushall 通杀全部库</li></ul><h3 id="常用五大基本数据类型"><a class="anchor" href="#常用五大基本数据类型">#</a> 常用五大基本数据类型</h3><h4 id="字符串string"><a class="anchor" href="#字符串string">#</a> 字符串（String）</h4><p><em><strong>String</strong></em> 类型是二进制安全的。意味着 <em><strong>Redis</strong></em> 的 <em><strong>string</strong></em> 可以包含任何数据。比如 <em><strong>jpg</strong></em> 图片或者序列化的对象。</p><p><em><strong>String</strong></em> 类型是 <em><strong>Redis</strong></em> 最基本的数据类型，一个 <em><strong>Redis</strong></em> 中字符串 <em><strong>value</strong></em> 最多可以是 512M。</p><ul><li><code>set &lt;key&gt;&lt;value&gt;</code> ：添加键值对</li><li><code>get &lt;key&gt;</code> ：查询对应键值</li><li><code>append &lt;key&gt;&lt;value&gt;</code> ：将给定的 <em><strong>&lt;value&gt;</strong></em> 追加到原值的末尾</li><li><code>strlen &lt;key&gt;</code> ：获得值的长度</li><li><code>setnx &lt;key&gt;&lt;value&gt;</code> ：只有在 <em><strong>key</strong></em> 不存在时，设置 <em><strong>key</strong></em> 的值</li><li><code>incr &lt;key&gt;</code> ：将 <em><strong>key</strong></em> 中储存的数字值增 1，只能对数字值操作，如果为空，新增值为 1（<strong>具有原子性</strong>）</li><li><code>decr &lt;key&gt;</code> ：将 <em><strong>key</strong></em> 中储存的数字值减 1，只能对数字值操作，如果为空，新增值为 -1</li><li><code>incrby/decrby &lt;key&gt;&lt;步长&gt;</code> ：将 <em><strong>key</strong></em> 中储存的数字值增减。自定义步长</li><li><code>mset &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;</code> ：同时设置一个或多个 <em><strong>key-value</strong></em> 对</li><li><code>mget &lt;key1&gt;&lt;key2&gt;&lt;key3&gt;...</code> ：同时获取一个或多个 <em><strong>value</strong></em></li><li><code>msetnx &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;...</code> ：同时设置一个或多个 <em><strong>key-value</strong></em> 对，当且仅当所有给定 <em><strong>key</strong></em> 都不存在</li><li><code>getrange &lt;key&gt;&lt;起始位置&gt;&lt;结束位置&gt;</code> ：获得值的范围</li><li><code>setrange &lt;key&gt;&lt;起始位置&gt;&lt;value&gt;</code> ：用 <em><strong>&lt;value&gt;</strong></em> 覆写 <em><strong>&lt;key&gt;</strong></em> 所储存的字符串值</li><li><code>setex &lt;key&gt;&lt;过期时间&gt;&lt;value&gt;</code> ：设置键值的同时，设置过期时间，单位秒。</li><li><code>getset &lt;key&gt;&lt;value&gt;</code> ：以新换旧，设置了新值同时获得旧值。</li></ul><h4 id="原子性"><a class="anchor" href="#原子性">#</a> <strong>原子性</strong></h4><p>所谓 <strong>原子</strong> 操作是指不会被线程调度机制打断的操作；</p><p>这种操作一旦开始，就一直运行到结束，中间不会有任何 <em><strong>context switch</strong></em> （切换到另一个线程）。</p><ul><li>在单线程中， 能够在单条指令中完成的操作都可以认为是” 原子操作”，因为中断只能发生于指令之间。</li><li>在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。</li></ul><p><em><strong>Redis</strong></em> 单命令的原子性主要得益于 <em><strong>Redis</strong></em> 的单线程。</p><h4 id="数据结构"><a class="anchor" href="#数据结构">#</a> <strong>数据结构</strong></h4><p>内部结构实现上类似于 <em><strong>Java</strong></em> 的 <em><strong>ArrayList</strong></em>，采用预分配冗余空间的方式来减少内存的频繁分配.</p><p><img data-src="image_zJyCzxDTiQ.png" alt=""></p><p>内部为当前字符串实际分配的空间 capacity 一般高于实际字符串长度 len。当字符串长度小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容是一次只会多扩容 1M 的空间。需要注意的是字符串最大长度为 512M。</p><h4 id="列表list"><a class="anchor" href="#列表list">#</a> 列表（List）</h4><p><em><strong>Redis</strong></em> 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p><p>它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p><ul><li><code>lpush/rpush &lt;key&gt;&lt;value1&gt;&lt;value2&gt;&lt;value3&gt; ....</code> ： 从左边 / 右边插入一个或多个值。</li><li><code>lpop/rpop &lt;key&gt;</code> ：从左边 / 右边吐出一个值。值在键在，值光键亡。</li><li><code>rpoplpush &lt;key1&gt;&lt;key2&gt;</code> ：从 <em><strong>&lt;key1&gt;</strong></em> 列表右边吐出一个值，插到 <em><strong>&lt;key2&gt;</strong></em> 列表左边。</li><li><code>lrange &lt;key&gt;&lt;start&gt;&lt;stop&gt;</code> ：按照索引下标获得元素（从左到右）</li><li><code>lrange mylist 0 -1 0</code> ：左边第一个，-1 右边第一个，（0 -1 表示获取所有）</li><li><code>lindex &lt;key&gt;&lt;index&gt;</code> ：按照索引下标获得元素（从左到右）</li><li><code>llen &lt;key&gt;</code> ：获得列表长度</li><li><code>linsert &lt;key&gt; before/after &lt;value&gt;&lt;newvalue&gt;</code> ：在 <em><strong>&lt;value&gt;</strong></em> 的前面 / 后面插入 <em><strong>&lt;newvalue&gt;</strong></em> 插入值</li><li><code>lrem &lt;key&gt;&lt;n&gt;&lt;value&gt;</code> ：从左边删除 <em><strong>n</strong></em> 个 <em><strong>value</strong></em>（从左到右）</li><li><code>ltrim &lt;key&gt;&lt;start&gt;&lt;end&gt;</code> ：按照索引截取下标元素（从左到右）</li><li><code>lset&lt;key&gt;&lt;index&gt;&lt;value&gt;</code> ：将列表 <em><strong>key</strong></em> 下标为 <em><strong>index</strong></em> 的值替换成 <em><strong>value</strong></em></li></ul><p><strong>数据结构</strong></p><p><em><strong>List</strong></em> 的数据结构为快速链表 <em><strong>quickList</strong></em>。</p><p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是 <em><strong>ziplist</strong></em>，也即是压缩列表。</p><p>它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</p><p>当数据量比较多的时候才会改成 <em><strong>quicklist</strong></em>。</p><p>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是 <em><strong>int</strong></em> 类型的数据，结构上还需要两个额外的指针 <em><strong>prev</strong></em> 和 <em><strong>next</strong></em>。</p><p><em><strong>Redis</strong></em> 将链表和 <em><strong>ziplist</strong></em> 结合起来组成了 <em><strong>quicklist</strong></em>。也就是将多个 <em><strong>ziplist</strong></em> 使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p><p><img data-src="202206241240221.png" alt=""></p><h4 id="set集合"><a class="anchor" href="#set集合">#</a> Set（集合）</h4><p><em><strong>Set</strong></em> 对外提供的功能与 <em><strong>List</strong></em> 类似列表的功能，特殊之处在于 <em><strong>Set</strong></em> 是可以 <strong>自动排重</strong> 的，当需要存储一个列表数据，又不希望出现重复数据时，<em><strong>Set</strong></em> 是一个很好的选择，并且 <em><strong>Set</strong></em> 提供了判断某个成员是否在一个 <em><strong>Set</strong></em> 集合内的重要接口，这个也是 <em><strong>List</strong></em> 所不能提供的。</p><p><em><strong>Redis</strong></em> 的 <em><strong>Set</strong></em> 是 <em><strong>String</strong></em> 类型的无序集合。它底层其实是一个 <em><strong>value</strong></em> 为 <em><strong>null</strong></em> 的 <em><strong>hash</strong></em> 表，所以添加，删除，查找的复杂度都是 <em><strong>O(1)</strong></em>。</p><p>一个算法，随着数据的增加，执行时间的长短，如果是 <em><strong>O(1)</strong></em>，数据增加，查找数据的时间不变。</p><ul><li><code>sadd &lt;key&gt;&lt;value1&gt;&lt;value2&gt; .....</code> ：将一个或多个 <em><strong>member</strong></em> 元素加入到集合 <em><strong>key</strong></em> 中，已经存在的 <em><strong>member</strong></em> 元素将被忽略</li><li><code>smembers &lt;key&gt;</code> ：取出该集合的所有值。</li><li><code>sismember &lt;key&gt;&lt;value&gt;</code> ：判断集合 <em><strong>&lt;key&gt;</strong></em> 是否为含有该 <em><strong>&lt;value&gt;</strong></em> 值，有返回 1，没有返回 0</li><li><code>scard&lt;key&gt;</code> ：返回该集合的元素个数。</li><li><code>srem &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ....</code> ：删除集合中的某个元素</li><li><code>spop &lt;key&gt;</code> ：随机从该集合中吐出一个值</li><li><code>srandmember &lt;key&gt;&lt;n&gt;</code> ：随机从该集合中取出 <em><strong>n</strong></em> 个值，不会从集合中删除</li><li><code>smove &lt;source&gt;&lt;destination&gt;value</code> ：把集合中一个值从一个集合移动到另一个集合</li><li><code>sinter &lt;key1&gt;&lt;key2&gt;</code> ：返回两个集合的交集元素</li><li><code>sunion &lt;key1&gt;&lt;key2&gt;</code> ：返回两个集合的并集元素</li><li><code>sdiff &lt;key1&gt;&lt;key2&gt;</code> ：返回两个集合的差集元素（<em><strong>key1</strong></em> 中的，不包含 <em><strong>key2</strong></em> 中的）</li></ul><p>数据结构</p><p>Set 数据结构是字典，字典是用哈希表实现的。</p><h4 id="hash哈希"><a class="anchor" href="#hash哈希">#</a> Hash（哈希）</h4><p><em><strong>Redis hash</strong></em> 是一个键值对集合。</p><p><em><strong>Redis hash</strong></em> 是一个 <em><strong>String</strong></em> 类型的 <em><strong>field</strong></em> 和 <em><strong>value</strong></em> 的映射表，<em><strong>hash</strong></em> 特别适合用于存储对象。</p><ul><li><code>hset &lt;key&gt;&lt;field&gt;&lt;value&gt;</code> ：给 <em><strong>&lt;key&gt;</strong></em> 集合中的 <em><strong>&lt;field&gt;</strong></em> 键赋值 <em><strong>&lt;value&gt;</strong></em></li><li><code>hget &lt;key1&gt;&lt;field&gt;</code> ：从 <em><strong>&lt;key1&gt;</strong></em> 集合 <em><strong>&lt;field&gt;</strong></em> 取出 <em><strong>value</strong></em></li><li><code>hmset &lt;key1&gt;&lt;field1&gt;&lt;value1&gt;&lt;field2&gt;&lt;value2&gt;...</code> ： 批量设置 <em><strong>hash</strong></em> 的值</li><li><code>hexists &lt;key1&gt;&lt;field&gt;</code> ：查看哈希表 <em><strong>key</strong></em> 中，给定域 <em><strong>field</strong></em> 是否存在</li><li><code>hkeys &lt;key&gt;</code> ：列出该 <em><strong>hash</strong></em> 集合的所有 <em><strong>field</strong></em></li><li><code>hvals &lt;key&gt;</code> ：列出该 <em><strong>hash</strong></em> 集合的所有 <em><strong>value</strong></em></li><li><code>hincrby &lt;key&gt;&lt;field&gt;&lt;increment&gt;</code> ：为哈希表 <em><strong>key</strong></em> 中的域 <em><strong>field</strong></em> 的值加上增量 1 -1</li><li><code>hsetnx &lt;key&gt;&lt;field&gt;&lt;value&gt;</code> ：将哈希表 <em><strong>key</strong></em> 中的域 <em><strong>field</strong></em> 的值设置为 <em><strong>value</strong></em> ，当且仅当域 <em><strong>field</strong></em> 不存在</li></ul><p><strong>数据结构</strong></p><p><em><strong>Hash</strong></em> 类型对应的数据结构是两种：<em><strong>ziplist</strong></em>（压缩列表），<em><strong>hashtable</strong></em>（哈希表）。</p><p>当 <em><strong>field-value</strong></em> 长度较短且个数较少时，使用 <em><strong>ziplist</strong></em>，否则使用 <em><strong>hashtable</strong></em>。</p><h4 id="zset有序集合"><a class="anchor" href="#zset有序集合">#</a> Zset（有序集合）</h4><p><em><strong>Redis</strong></em> 有序集合 <em><strong>zset</strong></em> 与普通集合 <em><strong>set</strong></em> 非常相似，是一个没有重复元素的字符串集合。</p><p>不同之处是有序集合的每个成员都关联了一个评分（<em><strong>score</strong></em>）, 这个评分（<em><strong>score</strong></em>）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复的。</p><p>因为元素是有序的，所以可以很快的根据评分（<em><strong>score</strong></em>）或者次序（<em><strong>position</strong></em>）来获取一个范围的元素。</p><p>访问有序集合的中间元素也是非常快的，因此能够使用有序集合作为一个没有重复成员的智能列表。</p><ul><li><code>zadd &lt;key&gt;&lt;score1&gt;&lt;value1&gt;&lt;score2&gt;&lt;value2&gt;…</code> ：将一个或多个 <em><strong>member</strong></em> 元素及其 <em><strong>score</strong></em> 值加入到有序集 <em><strong>key</strong></em> 当中</li><li><code>zrange &lt;key&gt;&lt;start&gt;&lt;stop&gt; [WITHSCORES]</code> ：返回有序集 <em><strong>key</strong></em> 中，下标在 <em><strong>&lt;start&gt;&lt;stop&gt;</strong></em> 之间的元素</li><li>当带 <em><strong>WITHSCORES</strong></em>，可以让分数一起和值返回到结果集</li><li><code>zrangebyscore key min max [withscores] [limit offset count]</code> ：返回有序集 <em><strong>key</strong></em> 中，所有 <em><strong>score</strong></em> 值介于 <em><strong>min</strong></em> 和 <em><strong>max</strong></em> 之间（包括等于 <em><strong>min</strong></em> 或 <em><strong>max</strong></em> ）的成员。有序集成员按 <em><strong>score</strong></em> 值递增（从小到大）次序排列。</li><li><code>zrevrangebyscore key max min [withscores] [limit offset count]</code> ：同上，改为从大到小排列</li><li><code>zincrby &lt;key&gt;&lt;increment&gt;&lt;value&gt;</code> ：为元素的 <em><strong>score</strong></em> 加上增量</li><li><code>zrem &lt;key&gt;&lt;value&gt;</code> ：删除该集合下，指定值的元素</li><li><code>zcount &lt;key&gt;&lt;min&gt;&lt;max&gt;</code> ：统计该集合，分数区间内的元素个数</li><li><code>zrank &lt;key&gt;&lt;value&gt;</code> ：返回该值在集合中的排名，从 0 开始</li></ul><p><strong>数据结构</strong></p><p><strong>SortedSet（zset）</strong>_是 <em><strong>Redis</strong></em> 提供的一个非常特别的数据结构，一方面它等价于 <em><strong>Java</strong></em> 的数据结构 <em><strong>Map&lt;String, Double&gt;</strong></em>，可以给每一个元素 <em><strong>value</strong></em> 赋予一个权重 <em><strong>score</strong></em>，另一方面它又类似于 <em><strong>TreeSet</strong></em>，内部的元素会按照权重 <em><strong>score</strong></em> 进行排序，可以得到每个元素的名次，还可以通过 <em><strong>score</strong></em> 的范围来获取元素的列表。</p><p><em><strong>zset</strong></em> 底层使用了两个数据结构</p><ul><li><em><strong>hash</strong></em>，<em><strong>hash</strong></em> 的作用就是关联元素 <em><strong>value</strong></em> 和权重 <em><strong>score</strong></em>，保障元素 <em><strong>value</strong></em> 的唯一性，可以通过元素 <em><strong>value</strong></em> 找到相应的 <em><strong>score</strong></em> 值</li><li>跳跃表，跳跃表的目的在于给元素 <em><strong>value</strong></em> 排序，根据 <em><strong>score</strong></em> 的范围获取元素列表</li></ul><h3 id="配置文件"><a class="anchor" href="#配置文件">#</a> 配置文件</h3><h4 id="units"><a class="anchor" href="#units">#</a> <em><strong>Units</strong></em></h4><blockquote><p>单位，配置大小单位，开头定义了一些基本的度量单位，只支持 <em><strong>bytes</strong></em>，不支持 <em><strong>bit</strong></em>。<br>大小写不敏感。</p><p><img data-src="image_h9cUn74aKW.png" alt=""></p></blockquote><h4 id="includes"><a class="anchor" href="#includes">#</a> <em><strong>INCLUDES</strong></em></h4><blockquote><p>包含，多实例的情况可以把公用的配置文件提取出来。</p><p><img data-src="image_S_PjXa9v_g.png" alt=""></p></blockquote><h4 id="network"><a class="anchor" href="#network">#</a> <em><strong>NETWORK</strong></em></h4><blockquote><p>网络相关配置。</p><p><em><strong>bind</strong></em></p><p>默认情况 <code>bind=127.0.0.1</code> 只能接受本机的访问请求。</p><p>不写的情况下，无限制接受任何 <em><strong>ip</strong></em> 地址的访问。</p><p>生产环境肯定要写你应用服务器的地址，服务器是需要远程访问的，所以需要将其注释掉。</p><p>如果开启了<strong> protected-mode</strong>*，那么在没有设定 *<em><strong>bind ip</strong></em> 且没有设密码的情况下，<strong>Redis</strong> 只允许接受本机的响应。</p><p><img data-src="image_75Y1iHzH3N.png" alt=""></p><p><em><strong>protected-mode</strong></em></p><p>将本机访问保护模式设置 <em><strong>no</strong></em>。</p><p><img data-src="image_0Bzvxj6BjJ.png" alt=""></p><p>p<em><strong>ort</strong></em></p><p>端口号，默认 <em><strong>6379</strong></em>。</p><p><img data-src="202206241232526.png" alt=""></p><p><em><strong>tcp-backlog</strong></em></p><p>设置 <em><strong>tcp</strong></em> 的 <em><strong>backlog</strong></em>，<em><strong>backlog</strong></em> 其实是一个连接队列，<em><strong>backlog</strong></em> 队列总和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo></mrow><annotation encoding="application/x-tex">=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.36687em;vertical-align:0"></span><span class="mrel">=</span></span></span></span> 未完成三次握手队列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo></mrow><annotation encoding="application/x-tex">+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord">+</span></span></span></span> 已经完成三次握手队列。</p><p>在高并发环境下你需要一个高 <em><strong>backlog</strong></em> 值来避免慢客户端连接问题。</p><p><img data-src="202206241233656.png" alt=""></p><p><em><strong>timeout</strong></em></p><p>一个空闲的客户端维持多少秒会关闭，0 表示关闭该功能。即永不关闭。</p><p><img data-src="202206241233384.png" alt=""></p><p><em><strong>tcp-keepalive</strong></em></p><p>对访问客户端的一种心跳检测，每个 <em><strong>n</strong></em> 秒检测一次。</p><p>单位为秒，如果设置为 0，则不会进行 <em><strong>Keepalive</strong></em> 检测，建议设置成 60。</p><p><img data-src="202206241234246.png" alt=""></p></blockquote><h4 id="general"><a class="anchor" href="#general">#</a> <em><strong>GENERAL</strong></em></h4><blockquote><p>通用。<br><em><strong>daemonize</strong></em><br>是否为后台进程，设置为 <em><strong>yes</strong></em>。<br>守护进程，后台启动。</p><p><img data-src="202206241235837.png" alt=""></p><p><em><strong>pidfile</strong></em><br>存放 <em><strong>pid</strong></em> 文件的位置，每个实例会产生一个不同的 <em><strong>pid</strong></em> 文件。</p><p><img data-src="202206241235968.png" alt=""></p><p><em><strong>loglevel</strong></em><br>指定日志记录级别，<em><strong>Redis</strong></em> 总共支持四个级别：<em><strong>debug、verbose、notice、warning</strong></em>，默认为 <em><strong>notice</strong></em>。</p><p><img data-src="202206241235383.png" alt=""></p><p><em><strong>logfile</strong></em><br>日志文件名称。</p><p><img data-src="202206241236971.png" alt=""></p><p><strong>database</strong><br>设定库的数量 默认 16，默认数据库为 0，可以使用 <code>SELECT &lt;dbid&gt;</code> 命令在连接上指定数据库 <em><strong>id</strong></em>。</p><p><img data-src="202206241236379.png" alt=""></p></blockquote><h4 id="security"><a class="anchor" href="#security">#</a> <em><strong>SECURITY</strong></em></h4><blockquote><p>安全。<br>访问密码的查看、设置和取消。<br>在命令中设置密码，只是临时的。重启 <em><strong>redis</strong></em> 服务器，密码就还原了。<br>永久设置，需要在配置文件中进行设置。</p></blockquote><h4 id="limits"><a class="anchor" href="#limits">#</a> <em><strong>LIMITS</strong></em></h4><blockquote><p>限制。</p><p><em><strong>maxclients</strong></em></p><p>设置 <em><strong>redis</strong></em> 同时可以与多少个客户端进行连接。</p><p>默认情况下为 <em><strong>10000</strong></em> 个客户端。</p><p>如果达到了此限制，<em><strong>redis</strong></em> 则会拒绝新的连接请求，并且向这些连接请求方发出 <em><strong>max number of clients reached</strong></em> 以作回应。</p><p><img data-src="202206241237488.png" alt=""></p><p><em><strong>maxmemory</strong></em></p><p>建议<strong>必须设置</strong>，否则，将内存占满，造成服务器宕机。</p><p>设置 <em><strong>redis</strong></em> 可以使用的内存量。一旦到达内存使用上限，<em><strong>redis</strong></em> 将会试图移除内部数据，移除规则可以通过 <em><strong>maxmemory-policy</strong></em> 来指定。</p><p>如果 <em><strong>redis</strong></em> 无法根据移除规则来移除内存中的数据，或者设置了不允许移除，那么 <em><strong>redis</strong></em> 则会针对那些需要申请内存的指令返回错误信息，比如 <em><strong>SET、LPUSH</strong></em> 等。</p><p>但是对于无内存申请的指令，仍然会正常响应，比如 <em><strong>GET</strong></em> 等。如果你的 <em><strong>redis</strong></em> 是主 <em><strong>redis</strong></em>（ 说明你的 <em><strong>redis</strong></em> 有从 <em><strong>redis</strong></em> ），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是 “不移除” 的情况下，才不用考虑这个因素。</p><p><img data-src="202206241237150.png" alt=""></p><p><em><strong>maxmemory-policy</strong></em></p><p><em><strong>volatile-lru</strong></em>：使用 <em><strong>LRU</strong></em> 算法移除 <em><strong>key</strong></em>，只对设置了过期时间的键（最近最少使用）。</p><p><em><strong>allkeys-lru</strong></em>：在所有集合 <em><strong>key</strong></em> 中，使用 <em><strong>LRU</strong></em> 算法移除 <em><strong>key</strong></em>。</p><p><em><strong>volatile-random</strong></em>：在过期集合中移除随机的 <em><strong>key</strong></em>，只对设置了过期时间的键。</p><p><em><strong>allkeys-random</strong></em>：在所有集合 <em><strong>key</strong></em> 中，移除随机的 <em><strong>key</strong></em>。</p><p><em><strong>volatile-ttl</strong></em>：移除那些 <em><strong>TTL</strong></em> 值最小的 <em><strong>key</strong></em>，即那些最近要过期的 <em><strong>key</strong></em>。</p><p><em><strong>noeviction</strong></em>：不进行移除。针对写操作，只是返回错误信息。</p><p><img data-src="202206241238328.png" alt=""></p><p><em><strong>maxmemory-samples</strong></em></p><p>设置样本数量，<em><strong>LRU</strong></em> 算法和最小 <em><strong>TTL</strong></em> 算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，<em><strong>redis</strong></em> 默认会检查这么多个 <em><strong>key</strong></em> 并选择其中 <em><strong>LRU</strong></em> 的那个。</p><p>一般设置 3 到 7 的数字，数值越小样本越不准确，但性能消耗越小。</p><p><img data-src="202206241238581.png" alt=""></p></blockquote><h3 id="redis的发布与订阅"><a class="anchor" href="#redis的发布与订阅">#</a> Redis 的发布与订阅</h3><p><em><strong>Redis</strong></em> 发布订阅（ <em><strong>pub/sub</strong></em> ）是一种消息通信模式：发送者（ <em><strong>pub</strong></em> ）发送消息，订阅者（ <em><strong>sub</strong></em> ）接收消息。</p><p><em><strong>Redis</strong></em> 客户端可以订阅任意数量的频道。</p><ol><li>客户端可以订阅频道</li></ol><p><img data-src="202206241241271.png" alt=""></p><ol><li>当给这个频道发布消息后，消息就会发送给订阅的客户端</li></ol><p><img data-src="202206241242008.png" alt=""></p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>subscribe channel <span class="token comment"># 订阅频道</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>publish channel hello <span class="token comment"># 频道发送信息</span></pre></td></tr></table></figure><h3 id="redis6中新的数据类型"><a class="anchor" href="#redis6中新的数据类型">#</a> Redis6 中新的数据类型</h3><h4 id="bitmaps"><a class="anchor" href="#bitmaps">#</a> Bitmaps</h4><p>现代计算机用二进制（位） 作为信息的基础单位，1 个字节等于 8 位，例如 &quot;abc” 字符串是由 了个字节组成，但实际在计算机存储时将其用二进制表示&quot;abc&quot; 对应的 ASCII 码分别是 97、 98、99，对应的二进制分别是 01100001、 01100010 和 01100011， 如下图</p><p><img data-src="image_Prwhvq95c7.png" alt=""></p><p>合理使用操作位能够有效地提高内存使用率和开发率。</p><p>redis 提供了 Bitmaps 这个数据类型，可以实现对位的操作：</p><p>Bitmaps 本身不是一种数据类型，实际上它就是字符串（key-value），但是它可以对字符串的位进行操作。</p><p>Bitmaps 单独提供一套命令，所以在 redis 中使用 Bitmaps 和使用字符串的方法不太相同。可以把 Bitmaps 想象成一个以位为单位的数组，数组的每个单元只能存储 0 和 1，数组的下标在 Bitmaps 中叫做偏移量。</p><p><img data-src="image_mpkW5jJxiz.png" alt=""></p><h4 id="操作命令"><a class="anchor" href="#操作命令">#</a> 操作命令</h4><ul><li><p>setbit</p><p>setbit &lt;key&gt;&lt;offset&gt;&lt;value &gt; 设置 Bitmaps 中某个偏移量的值（0 或者 1）。</p><p>offset：偏移量从 0 开始</p><p><strong>实例操作</strong></p><p>每个独立用户是否访问过网站存放在 Bitmaps 中，将访问的用户记做 1，没有<br>访问的用户记做 0，用偏移量作为用户的 id。<br>设置键的第 offset 个位的值（从 0 算起），假设现在有 20 个用户，userid=1<br>6，11，15，19 的用户对网站进行了访问，那么当前 Bitmaps 初始化结果如图。</p><p><img data-src="image_jRfq--24sV.png" alt=""></p><p>unique:users:20201106 代表 2020-11-06 这天的独立访问用户的 Bitmaps。</p><p><img data-src="image_bugB9yYreG.png" alt=""></p><p><strong>注意点：</strong></p><p>很多应用的用户 id 以一个指定数字（例如 10000）开头，直接将用户 id 和<br>Bitmaps 的偏移量对应势必会造成一定的浪费，通常的做法是每次做 setbit 操作时将用户 id 减去这个指定数字。<br>在第一次初始化 Bitmaps 时，假如偏移量非常大，那么整个初始化过程执行会<br>比较慢，可能会造成 Redis 的阻塞。</p></li><li><p>getbit</p><p>getbit&lt;key&gt;&lt;offset &gt; 获取 Bitmaps 中某个偏移量的值。</p></li><li><p>bitcount</p><p>统计字符串被设置为 1 的 bit 数。一般情况下 ，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。start 和 end 参数的设置，都可以使用负数值：比如 -1 表示最后一个位，而 - 2 表示倒数第二个位，start、end 是指 bit 组的字节的下标数，二者皆包含。</p><p>格式</p><p>bitcount&lt;key&gt;[start end] 统计字符串从 start 字节到 end 字节 bit 值为 1 的数量</p></li><li><p>bitop</p><p>bitop 是一个复合操作，它可以做多个 bitmaps 的 and 交集、or 并集、not 非、xor 异或操作并将结果保存在 destkey 中。</p><p>格式</p><p>bitop add(/or/not/xor) &lt;destkey&gt; [key......]</p></li></ul><p><strong>Bitmaps 与 set 对比</strong></p><p>假设网站有 1 亿用户， 每天独立访问的用户有 5 千万， 如果每天用集合类型和 Bitmaps 分别存储活跃用户可以得到表：</p><p>**set 和 Bitmaps 存储一天活跃用户对比 **</p><table><thead><tr><th>数据类型</th><th>每个用户 id 占用空间</th><th>需要存储的用户量</th><th>全部内存量</th></tr></thead><tbody><tr><td>集合</td><td>64 位</td><td>50000000</td><td>64 位 * 50000000 = 400MB</td></tr><tr><td>Bitmaps</td><td>1 位</td><td>100000000</td><td>1 位 * 100000000 = 12.5MB</td></tr></tbody></table><p>很明显， 这种情况下使用 Bitmaps 能节省很多的内存空间， 尤其是随着时间推移节省的内存还是非常可观的。</p><p>**set 和 Bitmaps 存储独立用户空间对比 **</p><table><thead><tr><th>数据类型</th><th>一天</th><th>一个月</th><th>一年</th></tr></thead><tbody><tr><td>集合</td><td>400MB</td><td>12GB</td><td>144GB</td></tr><tr><td>Bitmaps</td><td>12.5MB</td><td>375MB</td><td>4.5GB</td></tr></tbody></table><p>但 Bitmaps 并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有 10 万（大量的僵尸用户） ， 那么两者的对比如下表所示， 很显然， 这时候使 Bitmaps 就不太合适了， 因为基本上大部分位都是 0。</p><p>**set 和 Bitmaps 存储一天活跃用户对比（用户比较少） **</p><table><thead><tr><th>数据类型</th><th>每个用户 id 占用空间</th><th>需要存储的用户量</th><th>全部内存量</th></tr></thead><tbody><tr><td>集合</td><td>64 位</td><td>100000</td><td>64 位 * 100000 = 800KB</td></tr><tr><td>Bitmaps</td><td>1 位</td><td>100000000</td><td>1 位 * 100000000 = 12.5MB</td></tr></tbody></table><h4 id="hyperloglog"><a class="anchor" href="#hyperloglog">#</a> HyperLogLog</h4><p>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站 PV（PageView 页面访问量），可以使用 Redis 的 incr、incrby 轻松实现。但像 UV ( UniqueVisitor，独立访客）、独立 IP 数、搜索记录数等需要去重和计数的问题如何解决？<strong>这种求集合中不重复元素个数的问题称为基数问题。</strong><br>解決基数问题有很多种方案！！<br>(1）数据存储在 MysQL 表中，使用 distinct count 计算不重复个数。<br>（2）使用 Redis 提供的 hash、 set、bitmaps 等数据结构来处理。<br>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非<br>常大的数据集是不切实际的。<br>能否能够降低 定的精度来平衡存储空间？Redis 推出了 HyperLogLog<br>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需要的空间总是固定的，并且是很小的。</p><p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12KB 内存，就可以计算接<br>近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。但是，因为 HyperLogLog 只会根据输入元素来计算基数 ，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样 ，返回输入的各个元素</p><p><strong>命令</strong></p><ul><li><p>pfadd</p><p>pfadd &lt;key&gt;&lt;element&gt; [element....] 添加指定元素到 HyperLogLog 中</p></li><li><p>pfcount</p><p>pfcount&lt;key&gt;[key...] 计算 HLL 的近视基数，可以计算出多个 HLL。</p></li><li><p>pfmerge</p><p>pfmerge&lt;destkey&gt;&lt;sourcekey&gt;[sourcekey....] 将一个或者多个 HLL 合并后的结果保存在另一个 HLL 中。</p></li></ul><p><strong>Geospatial</strong></p><p>Redis 3.2 中增加了对 GEO 类型的支持。GEO,Geographic，地理信息的缩写、<br>该类型，就是元素的 2 维坐标 ，在地图上就是经纬度。redis 基于该类型，提供了经纬度设置，查询，范围查询 ，距离查询，经纬度 Hash 等常见操作。</p><p><strong>命令</strong></p><ul><li><p>geoadd</p><p>geoadd &lt;key&gt;&lt;longitude&gt;&lt;latitude&gt;&lt;member&gt;[&lt;longitude&gt;&lt;latitude&gt;&lt;member&gt;....] 添加地理位置（经度，纬度，名称）</p></li><li><p>geopos</p><p>geopos &lt;key&gt;&lt;member&gt;[member.....] 获得指定地区的坐标值</p></li><li><p>geodist</p><p>geodist &lt;key&gt;&lt;member1&gt;&lt;member2&gt; [m|km|ft|mi] 获取两个位置之间的直线距离</p></li></ul><h3 id="springboot整合redis6"><a class="anchor" href="#springboot整合redis6">#</a> Springboot 整合 Redis6</h3><ol><li>依赖<figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">&lt;!-- redis --></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">&lt;!-- spring2.X 集成 redis 所需 common-pool2--></span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.commons<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>commons-pool2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.6.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></pre></td></tr></table></figure></li><li>配置文件配置 Redis<pre><code class="language-.properties">#Redis服务器地址
spring.redis.host= ip
#Redis服务器连接端口
spring.redis.port=6379
#Redis数据库索引（默认为0）
spring.redis.database= 0
#连接超时时间（毫秒）
spring.redis.timeout=1800000
#连接池最大连接数（使用负值表示没有限制）
spring.redis.lettuce.pool.max-active=20
#最大阻塞等待时间(负数表示没限制)
spring.redis.lettuce.pool.max-wait=-1
#连接池中的最大空闲连接
spring.redis.lettuce.pool.max-idle=5
#连接池中的最小空闲连接
spring.redis.lettuce.pool.min-idle=0
</code></pre></li><li><em><strong>Redis</strong></em> 配置类（需要继承 <em><strong>CachingConfigurerSupport</strong></em>）<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@EnableCaching</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token annotation punctuation">@Configuration</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisConfig</span> <span class="token keyword">extends</span> <span class="token class-name">CachingConfigurerSupport</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token annotation punctuation">@Bean</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> <span class="token function">redisTemplate</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span> factory<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> template <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token class-name">RedisSerializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> redisSerializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringRedisSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token class-name">Jackson2JsonRedisSerializer</span> jackson2JsonRedisSerializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jackson2JsonRedisSerializer</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token class-name">ObjectMapper</span> om <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        om<span class="token punctuation">.</span><span class="token function">setVisibility</span><span class="token punctuation">(</span><span class="token class-name">PropertyAccessor</span><span class="token punctuation">.</span><span class="token constant">ALL</span><span class="token punctuation">,</span> <span class="token class-name">JsonAutoDetect<span class="token punctuation">.</span>Visibility</span><span class="token punctuation">.</span><span class="token constant">ANY</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        om<span class="token punctuation">.</span><span class="token function">enableDefaultTyping</span><span class="token punctuation">(</span><span class="token class-name">ObjectMapper<span class="token punctuation">.</span>DefaultTyping</span><span class="token punctuation">.</span><span class="token constant">NON_FINAL</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        jackson2JsonRedisSerializer<span class="token punctuation">.</span><span class="token function">setObjectMapper</span><span class="token punctuation">(</span>om<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        template<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>factory<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">//key 序列化方式</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        template<span class="token punctuation">.</span><span class="token function">setKeySerializer</span><span class="token punctuation">(</span>redisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token comment">//value 序列化</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        template<span class="token punctuation">.</span><span class="token function">setValueSerializer</span><span class="token punctuation">(</span>jackson2JsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token comment">//value hashmap 序列化</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        template<span class="token punctuation">.</span><span class="token function">setHashValueSerializer</span><span class="token punctuation">(</span>jackson2JsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">return</span> template<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token annotation punctuation">@Bean</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">CacheManager</span> <span class="token function">cacheManager</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span> factory<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token class-name">RedisSerializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> redisSerializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringRedisSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token class-name">Jackson2JsonRedisSerializer</span> jackson2JsonRedisSerializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jackson2JsonRedisSerializer</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token comment">// 解决查询缓存转换异常的问题</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token class-name">ObjectMapper</span> om <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        om<span class="token punctuation">.</span><span class="token function">setVisibility</span><span class="token punctuation">(</span><span class="token class-name">PropertyAccessor</span><span class="token punctuation">.</span><span class="token constant">ALL</span><span class="token punctuation">,</span> <span class="token class-name">JsonAutoDetect<span class="token punctuation">.</span>Visibility</span><span class="token punctuation">.</span><span class="token constant">ANY</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        om<span class="token punctuation">.</span><span class="token function">enableDefaultTyping</span><span class="token punctuation">(</span><span class="token class-name">ObjectMapper<span class="token punctuation">.</span>DefaultTyping</span><span class="token punctuation">.</span><span class="token constant">NON_FINAL</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        jackson2JsonRedisSerializer<span class="token punctuation">.</span><span class="token function">setObjectMapper</span><span class="token punctuation">(</span>om<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token comment">// 配置序列化（解决乱码的问题）, 过期时间 600 秒</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token class-name">RedisCacheConfiguration</span> config <span class="token operator">=</span> </pre></td></tr><tr><td data-num="34"></td><td><pre>          <span class="token class-name">RedisCacheConfiguration</span><span class="token punctuation">.</span><span class="token function">defaultCacheConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="35"></td><td><pre>                <span class="token punctuation">.</span><span class="token function">entryTtl</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofSeconds</span><span class="token punctuation">(</span><span class="token number">600</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="36"></td><td><pre>      <span class="token punctuation">.</span><span class="token function">serializeValuesWith</span><span class="token punctuation">(</span><span class="token class-name">RedisSerializationContext<span class="token punctuation">.</span>SerializationPair</span><span class="token punctuation">.</span><span class="token function">fromSerializer</span><span class="token punctuation">(</span>jackson2JsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="37"></td><td><pre>                <span class="token punctuation">.</span><span class="token function">disableCachingNullValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>        <span class="token class-name">RedisCacheManager</span> cacheManager <span class="token operator">=</span> <span class="token class-name">RedisCacheManager</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span>factory<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="39"></td><td><pre>                <span class="token punctuation">.</span><span class="token function">cacheDefaults</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="40"></td><td><pre>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>        <span class="token keyword">return</span> cacheManager<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="43"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li></ol><h3 id="redis事务和锁机制"><a class="anchor" href="#redis事务和锁机制">#</a> Redis 事务和锁机制</h3><p><em><strong>Redis</strong></em> 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p><p><em><strong>Redis</strong></em> 事务的主要作用就是串联多个命令防止别的命令插队。</p><p>Redis 事务是一组隔离操作，会顺序执行，在执行过程中，不会被其他客户端发送的命令请求给打断，Multi 开启事务，向队列中输入要执行的指令，Exec 按照执行队列中的指令。Discard 放弃组队。</p><h4 id="事务操作"><a class="anchor" href="#事务操作">#</a> 事务操作</h4><p><em><strong>Multi</strong></em>**、<em><strong><strong>Exec</strong></strong></em>、**<em><strong>Discard</strong></em></p><p><img data-src="image_ZHRyxQtgmN.png" alt=""></p><p>multi 指令</p><p>开启事务，向队列输入执行指令。</p><p>exec 指令</p><p>按顺序执行队列中的指令</p><p><strong>在组队中指令出现错误，exec 时都不会成功，组队指令没有出错，在 exec 执行时出错，只有出错的指令不成功，其他的命令会成功。</strong></p><h4 id="悲观锁"><a class="anchor" href="#悲观锁">#</a> 悲观锁</h4><p>悲观锁（<em><strong>Pessimistic Lock</strong></em>），即每次去拿数据的时候都认为有其他线程会修改，所以每次在拿数据的时候都会上锁，这样其他线程想要拿到这个数据就会被 <em><strong>block</strong></em> 直到成功拿到锁。（效率低）</p><h4 id="乐观锁"><a class="anchor" href="#乐观锁">#</a> 乐观锁</h4><p>乐观锁（<em><strong>Optimistic Lock</strong></em>），即每次去拿数据的时候都认为其他线程不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间有没有其他线程去更新这个数据，可以使用版本号等机制。</p><p><strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。</p><p><em><strong>Redis</strong></em> 就是利用这种 <em><strong>check-and-set</strong></em> 机制实现事务的。</p><h4 id="watch-unwatch"><a class="anchor" href="#watch-unwatch">#</a> Watch、UnWatch</h4><p>在执行 <em><strong>multi</strong></em> 之前，先执行 <em><strong>watch key1 [key2]</strong></em><strong>，可以监视一个（或多个 ）</strong> ​<em><strong>key</strong></em>。如果在事务执行之前这个 <em><strong>key</strong></em> 被其他命令所改动，那么事务将被打断。</p><p>取消 <em><strong>WATCH</strong></em> 命令对所有 <em><strong>key</strong></em> 的监视。如果在执行 <em><strong>WATCH</strong></em> 命令之后，<em><strong>EXEC</strong></em> 命令或 <em><strong>DISCARD</strong></em> 命令先被执行，那么就不需要再执行 <em><strong>UNWATCH</strong></em> 。</p><h4 id="事务三特性"><a class="anchor" href="#事务三特性">#</a> 事务三特性</h4><ul><li><p>单独的隔离操作</p><p>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p></li><li><p>没有隔离级别的概念</p><p>队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行。</p></li><li><p>不保证原子性</p><p>事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚 。</p></li></ul><h3 id="redis持久化"><a class="anchor" href="#redis持久化">#</a> Redis 持久化</h3><h4 id="rdb"><a class="anchor" href="#rdb">#</a> RDB</h4><p>在指定的时间间隔内将内存中的数据集快照写入磁盘， 即 <em><strong>Snapshot</strong></em> 快照，恢复时是将快照文件直接读到内存里。</p><h4 id="备份是如何执行的"><a class="anchor" href="#备份是如何执行的">#</a> 备份是如何执行的</h4><p>Redis 会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个<strong>临时文件替换上次持久化好</strong>的文件。整个过程中，主进程是不进行任何 IO 操作的，这就确保了极高的性能，如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那 RDB 方式是要比 AOF 方式更加的高效。<strong>RDB 的缺点是最后一次持久化后的数据可能丢失</strong>。</p><h4 id="fork"><a class="anchor" href="#fork">#</a> Fork</h4><ul><li>作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</li><li>在 <em><strong>Linux</strong></em> 程序中，<em><strong>fork()</strong></em> 会产生一个和父进程完全相同的子进程，但子进程在此后多会 <em><strong>exec</strong></em> 系统调用，出于效率考虑，<em><strong>Linux</strong></em> 中引入了 <strong>写时复制技术</strong></li><li><strong>一般情况父进程和子进程会共用同一段物理内存</strong>，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程</li></ul><h4 id="rdb持久化流程"><a class="anchor" href="#rdb持久化流程">#</a> RDB 持久化流程</h4><p><img data-src="image_OKOLeWAR.png" alt=""></p><h4 id="配置"><a class="anchor" href="#配置">#</a> 配置</h4><blockquote><p><em><strong>dump</strong></em>** 文件名字 **​</p><p>在 <em><strong>redis.conf</strong></em> 中配置文件名称，默认为 <em><strong>dump.rdb</strong></em>。</p><p><img data-src="202206241245089.png" alt=""></p><p><em><strong>dump</strong></em>** 保存位置 **​</p><p><em><strong>rdb</strong></em> 文件的保存路径可以修改。默认为 <em><strong>Redis</strong></em> 启动时命令行所在的目录下。</p><p><img data-src="202206241245951.png" alt=""></p><p><em><strong>stop-writes-on-bgsave-error</strong></em></p><p>即当 <em><strong>redis</strong></em> 无法写入磁盘，关闭 <em><strong>redis</strong></em> 的写入操作。</p><p><img data-src="202206241246038.png" alt=""></p><p><em><strong>rdbcompression</strong></em></p><p>持久化的文件是否进行压缩存储。</p><p><img data-src="202206241246917.png" alt=""></p><p><em><strong>rdbchecksum</strong></em></p><p>完整性的检查，即数据是否完整性、准确性。</p><p><img data-src="202206241247735.png" alt=""></p><p><em><strong>save</strong></em></p><p>表示写操作的次数。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>格式：save 秒 写操作次数</pre></td></tr></table></figure><p><img data-src="202206241247583.png" alt=""></p></blockquote><h4 id="优点"><a class="anchor" href="#优点">#</a> 优点</h4><ul><li>适合大规模的数据恢复；</li><li>对数据完整性和一致性要求不高更适合使用；</li><li>节省磁盘空间；</li><li>恢复速度快。</li></ul><h4 id="缺点"><a class="anchor" href="#缺点">#</a> 缺点</h4><ul><li><em><strong>Fork</strong></em> 的时候，内存中的数据被克隆了一份，大致 2 倍的膨胀性需要考虑；</li><li>虽然 <em><strong>Redis</strong></em> 在 <em><strong>fork</strong></em> 时使用了<strong>写时拷贝技术</strong>，但是如果数据庞大时还是比较消耗性能；</li><li>在备份周期在一定间隔时间做一次备份，所以如果 <em><strong>Redis</strong></em> 意外 <em><strong>down</strong></em> 掉的话，就会丢失最后一次快照后的所有修改。</li></ul><h4 id="aof"><a class="anchor" href="#aof">#</a> AOF</h4><p>以日志的形式来记录每个写操作（增量保存），将 <em><strong>Redis</strong></em> 执行过的所有写指令记录下来（读操作不记录）， 只许追加文件但不可以改写文件，<em><strong>Redis</strong></em> 启动之初会读取该文件重新构建数据，换言之，如果 <em><strong>Redis</strong></em> 重启就会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p><p><strong>执行流程</strong></p><ul><li>客户端的请求写命令会被 <em><strong>append</strong></em> 追加到 <em><strong>AOF</strong></em> 缓冲区内；</li><li><em><strong>AOF</strong></em> 缓冲区根据 <em><strong>AOF</strong></em> 持久化策略 <code>[always,everysec,no]</code> 将操作 <em><strong>sync</strong></em> 同步到磁盘的 <em><strong>AOF</strong></em> 文件中；</li><li><em><strong>AOF</strong></em> 文件大小超过重写策略或手动重写时，会对 <em><strong>AOF</strong></em> 文件 <em><strong>Rewrite</strong></em> 重写，压缩 <em><strong>AOF</strong></em> 文件容量；</li><li><em><strong>Redis</strong></em> 服务重启时，会重新 <em><strong>load</strong></em> 加载 <em><strong>AOF</strong></em> 文件中的写操作达到数据恢复的目的。</li></ul><p><em><strong>AOF</strong></em> 和 <em><strong>RDB</strong></em> 同时开启时，系统默认读取 <em><strong>AOF</strong></em> 的数据（数据不会存在丢失）</p><h4 id="配置-2"><a class="anchor" href="#配置-2">#</a> 配置</h4><blockquote><p><em><strong>AOF</strong></em>** 默认不开启 **​</p><p><img data-src="202206241248962.png" alt=""></p><p><strong>文件名字</strong></p><p><img data-src="202206241248396.png" alt=""></p><p><em><strong>AOF</strong></em>** 同步频率设置 **​</p><p><img data-src="202206241249139.png" alt=""></p><p><em><strong>appendfsync always</strong></em></p><p>始终同步，每次 <em><strong>Redis</strong></em> 的写入都会立刻记入日志；</p><p>性能较差但数据完整性比较好。</p><p><em><strong>appendfsync everysec</strong></em></p><p>每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。</p><p><em><strong>appendfsync no</strong></em></p><p><em><strong>Redis</strong></em> 不主动进行同步，把同步时机交给操作系统。</p><p><em><strong>Rewrite</strong></em>** 压缩 **​</p><p>当 <em><strong>AOF</strong></em> 文件的大小超过所设定的阈值时，<em><strong>Redis</strong></em> 就会启动 <em><strong>AOF</strong></em> 文件的内容压缩，只保留可以恢复数据的最小指令集。可以使用命令 <em><strong>bgrewriteaof</strong></em>。</p><p><img data-src="202206241249997.png" alt=""></p></blockquote><h4 id="优点-2"><a class="anchor" href="#优点-2">#</a> 优点</h4><ul><li>备份机制更稳健，丢失数据概率更低；</li><li>可读的日志文本，通过操作 <em><strong>AOF</strong></em> 稳健，可以处理误操作。</li></ul><h4 id="缺点-2"><a class="anchor" href="#缺点-2">#</a> 缺点</h4><ul><li>比起 <em><strong>RDB</strong></em> 占用更多的磁盘空间；</li><li>恢复备份速度要慢；</li><li>每次读写都同步的话，有一定的性能压力；</li><li>存在个别 <em><strong>Bug</strong></em>，造成不能恢复。</li></ul><h4 id="选择"><a class="anchor" href="#选择">#</a> 选择</h4><blockquote><p>官方推荐两个都启用。</p><p>如果对数据不敏感，可以选单独用 <em><strong>RDB</strong></em>。</p><p>不建议单独用 <em><strong>AOF</strong></em>，因为可能会出现 <em><strong>Bug</strong></em>。</p><p>如果只是做纯内存缓存，可以都不用。</p></blockquote><h3 id="主从复制"><a class="anchor" href="#主从复制">#</a> 主从复制</h3><p>主机数据更新后根据配置和策略， 自动同步到备机的 <em><strong>master/slaver</strong></em> 机制，<em><strong>Master</strong></em> 以写为主，<em><strong>Slaver</strong></em> 以读为主。</p><p><img data-src="202206241250697.png" alt=""></p><ol><li>读写分离，性能扩展</li><li>容灾快速恢复</li><li>一主多从！</li></ol><h4 id="主重复制-搭建一主多从"><a class="anchor" href="#主重复制-搭建一主多从">#</a> 主重复制 - 搭建一主多从</h4><ol><li><p>创建一个 myredis 文件夹模仿多台机器</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">mkdir</span> myredis</pre></td></tr></table></figure></li><li><p>复制 redis 配置文件到 myredis 文件夹中</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">cp</span> /usr/local/etc/redis.conf /myredis/redis.conf</pre></td></tr></table></figure></li><li><p>配置一主两从，创建三个配置文件</p><p>redis6379.conf</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>include /myredis/redis.conf</pre></td></tr><tr><td data-num="2"></td><td><pre>pidfile /var/run/redis_6379.pid</pre></td></tr><tr><td data-num="3"></td><td><pre>port <span class="token number">6379</span></pre></td></tr><tr><td data-num="4"></td><td><pre>dbfilename dump6379.rdb</pre></td></tr></table></figure><p>redis6380.conf</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>include /myredis/redis.conf</pre></td></tr><tr><td data-num="2"></td><td><pre>pidfile /var/run/redis_6380.pid</pre></td></tr><tr><td data-num="3"></td><td><pre>port <span class="token number">6380</span></pre></td></tr><tr><td data-num="4"></td><td><pre>dbfilename dump6380.rdb</pre></td></tr></table></figure><p>redis6381.conf</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>include /myredis/redis.conf</pre></td></tr><tr><td data-num="2"></td><td><pre>pidfile /var/run/redis_6381.pid</pre></td></tr><tr><td data-num="3"></td><td><pre>port <span class="token number">6381</span></pre></td></tr><tr><td data-num="4"></td><td><pre>dbfilename dump6381.rdb</pre></td></tr></table></figure></li><li><p>启动服务</p></li><li><p>查看主机运行情况，使用客户端连接 redis 服务，使用如下命令查看。</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>info replication</pre></td></tr></table></figure></li><li><p>配从不配主 (redis-cli 命令行操作)</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>slaveof  <span class="token operator">&lt;</span>ip<span class="token operator">></span><span class="token operator">&lt;</span>port<span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment"># 成为某个实例的从服务器</span></pre></td></tr></table></figure></li><li><p>再次查看主机运行情况</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># Replication</span></pre></td></tr><tr><td data-num="2"></td><td><pre>role:master</pre></td></tr><tr><td data-num="3"></td><td><pre>connected_slaves:2</pre></td></tr><tr><td data-num="4"></td><td><pre>slave0:ip<span class="token operator">=</span><span class="token number">127.0</span>.0.1,port<span class="token operator">=</span><span class="token number">6380</span>,state<span class="token operator">=</span>online,offset<span class="token operator">=</span><span class="token number">42</span>,lag<span class="token operator">=</span><span class="token number">1</span></pre></td></tr><tr><td data-num="5"></td><td><pre>slave1:ip<span class="token operator">=</span><span class="token number">127.0</span>.0.1,port<span class="token operator">=</span><span class="token number">6381</span>,state<span class="token operator">=</span>online,offset<span class="token operator">=</span><span class="token number">42</span>,lag<span class="token operator">=</span><span class="token number">0</span></pre></td></tr><tr><td data-num="6"></td><td><pre>master_failover_state:no-failover</pre></td></tr><tr><td data-num="7"></td><td><pre>master_replid:1b14fa5778316372346af6021bcd0bb131ed27af</pre></td></tr><tr><td data-num="8"></td><td><pre>master_replid2:0000000000000000000000000000000000000000</pre></td></tr><tr><td data-num="9"></td><td><pre>master_repl_offset:42</pre></td></tr><tr><td data-num="10"></td><td><pre>second_repl_offset:-1</pre></td></tr><tr><td data-num="11"></td><td><pre>repl_backlog_active:1</pre></td></tr><tr><td data-num="12"></td><td><pre>repl_backlog_size:1048576</pre></td></tr><tr><td data-num="13"></td><td><pre>repl_backlog_first_byte_offset:1</pre></td></tr><tr><td data-num="14"></td><td><pre>repl_backlog_histlen:42</pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span></pre></td></tr></table></figure></li><li><p>主机挂掉，重启就行</p></li><li><p>从机重启需要重设： <code>slaveof</code></p></li><li><p>可以将配置增加到文件中，永久生效</p></li></ol><h4 id="一主二仆"><a class="anchor" href="#一主二仆">#</a> 一主二仆</h4><blockquote><p>主机 <em><strong>6379</strong></em>，从机 <em><strong>6380</strong></em> 和 <em><strong>6381</strong></em>。</p><ol><li>假设主机 <em><strong>6379</strong></em> 挂掉。<figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token number">6380</span>和<span class="token number">6381</span>仍然是<span class="token number">6379</span>的从机，不会做任何事；</pre></td></tr><tr><td data-num="2"></td><td><pre>当<span class="token number">6379</span>重启后，依然是主服务器。</pre></td></tr></table></figure></li><li>假设从机 <em><strong>6380</strong></em> 挂掉。<figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre>当<span class="token number">6380</span>重启后，<span class="token number">6380</span>不再是<span class="token number">6379</span>的从机，而是作为新的master；</pre></td></tr><tr><td data-num="2"></td><td><pre>当再次把<span class="token number">6380</span>作为<span class="token number">6379</span>的从机加入后，从机会把数据从头到尾复制。</pre></td></tr></table></figure></li></ol></blockquote><h4 id="复制原理"><a class="anchor" href="#复制原理">#</a> 复制原理</h4><ul><li><em><strong>slave</strong></em> 启动成功连接到 <em><strong>master</strong></em> 后会发送一个 <em><strong>sync</strong></em> 命令（同步命令）。</li><li><em><strong>master</strong></em> 接到命令启动后台的存盘进程，对数据进行持久化操作，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，<em><strong>master</strong></em> 将传送整个数据文件（<em><strong>rdb</strong></em>）到 <em><strong>slave</strong></em>，以完成一次完全同步。</li><li>当主服务进行写操作后，和从服务器进行数据同步。</li><li>全量复制：而 <em><strong>slave</strong></em> 服务在接收到数据库文件数据后，将其存盘并加载到内存中。</li><li>增量复制：<em><strong>master</strong></em> 继续将新的所有收集到的修改命令依次传给 <em><strong>slave</strong></em>，完成同步。</li><li>只要是重新连接 <em><strong>master</strong></em>，一次完全同步（全量复制）将被自动执行。</li></ul><h4 id="薪火相传"><a class="anchor" href="#薪火相传">#</a> 薪火相传</h4><p><img data-src="202206241253497.png" alt=""></p><p>上一个 <em><strong>slave</strong></em> 可以是下一个 <em><strong>slave</strong></em> 的 <em><strong>master</strong></em>，<em><strong>slave</strong></em> 同样可以接收其他 _<strong>slave</strong>_的连接和同步请求，那么该 <em><strong>slave</strong></em> 作为了链条中下一个的 <em><strong>master</strong></em>，可以有效减轻 <em><strong>master</strong></em> 的写压力，去中心化降低风险。</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>slaveof <span class="token operator">&lt;</span>ip<span class="token operator">></span><span class="token operator">&lt;</span>port<span class="token operator">></span></pre></td></tr></table></figure><p>中途变更转向：会清除之前的数据，重新建立拷贝最新的。</p><p>当某个 <em><strong>slave</strong></em> 宕机，后面的 <em><strong>slave</strong></em> 都没法备份。</p><p>即当主机挂掉，从机还是从机，但是无法继续写数据。</p><h4 id="反客为主"><a class="anchor" href="#反客为主">#</a> 反客为主</h4><p>当一个 <em><strong>master</strong></em> 宕机后，后面的 <em><strong>slave</strong></em> 可以立刻升为 <em><strong>master</strong></em>，其后面的 <em><strong>slave</strong></em> 不用做任何修改。</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>slaveof no one</pre></td></tr></table></figure><h4 id="哨兵模式"><a class="anchor" href="#哨兵模式">#</a> 哨兵模式</h4><p><strong>反客为主的自动版</strong>，即能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。</p><ol><li>创建 <em><strong>sentinel.conf</strong></em> 文件<figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token operator">/</span>opt<span class="token operator">/</span>etc<span class="token operator">/</span>sentinel<span class="token punctuation">.</span>conf</pre></td></tr></table></figure></li><li>配置哨兵<figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre>sentinel monitor mymaster <span class="token number">172.16</span><span class="token number">.88</span><span class="token number">.168</span> <span class="token number">6379</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment"># mymaster：监控对象起的服务器名称</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment"># 1：至少有多少个哨兵同意迁移的数量。</span></pre></td></tr></table></figure></li><li>启动哨兵<figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre>redis<span class="token operator">-</span>sentinel  <span class="token operator">/</span>opt<span class="token operator">/</span>etc<span class="token operator">/</span>sentinel<span class="token punctuation">.</span>conf</pre></td></tr></table></figure><img data-src="image_2lMXcsy7nd.png" alt=""></li></ol><p>主机挂掉，会从机选举中产生新的主机。选举的规则。</p><h4 id="选举规则"><a class="anchor" href="#选举规则">#</a> 选举规则</h4><ol><li><p>根据优先级别，<em><strong>slave-priority/replica-priority</strong></em>，优先选择优先级靠前的。</p><p><img data-src="202206241253826.png" alt=""></p></li><li><p>根据偏移量，优先选择偏移量大的。</p></li><li><p>根据 <em><strong>runid</strong></em>，优先选择最小的服务。</p></li></ol><h3 id="redis集群"><a class="anchor" href="#redis集群">#</a> Redis 集群</h3><p>容量不够，<em><strong>redis</strong></em> 如何进行扩容？</p><p>并发写操作， <em><strong>redis</strong></em> 如何分摊？</p><p>主从模式，薪火相传模式，主机宕机，导致 <em><strong>ip</strong></em> 地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。</p><p>解决方法：</p><ul><li><p>代理主机（ <em><strong>之前</strong></em> ）</p><p><img data-src="202206241254954.png" alt=""></p></li><li><p>无中心化集群配置（ <em><strong>redis3.0</strong></em> ）</p></li></ul><p><img data-src="202206241255698.png" alt=""></p><p><em><strong>Redis</strong></em> 集群实现了对 <em><strong>Redis</strong></em> 的水平扩容，即启动 <em><strong>N</strong></em> 个 <em><strong>Redis</strong></em> 节点，将整个数据库分布存储在这 <em><strong>N</strong></em> 个节点中，每个节点存储总数据的 <em><strong>1/N</strong></em> 。</p><p><em><strong>Redis</strong></em> 集群通过分区（<em><strong>partition</strong></em>）来提供一定程度的可用性（<em><strong>availability</strong></em>），即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p><h4 id="搭建-redis-集群"><a class="anchor" href="#搭建-redis-集群">#</a> 搭建 <em>Redis</em> 集群</h4><ol><li><p>创建配置文件</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 以 redis6379.conf 为例</span></pre></td></tr><tr><td data-num="2"></td><td><pre>include /opt/etc/redis.conf</pre></td></tr><tr><td data-num="3"></td><td><pre>pidfile /var/run/redis_6379.pid <span class="token comment"># 更改</span></pre></td></tr><tr><td data-num="4"></td><td><pre>port <span class="token number">6379</span> <span class="token comment"># 更改</span></pre></td></tr><tr><td data-num="5"></td><td><pre>dbfilename dump6379.rdb <span class="token comment"># 更改</span></pre></td></tr><tr><td data-num="6"></td><td><pre>cluster-enabled <span class="token function">yes</span> <span class="token comment"># 打开集群模式</span></pre></td></tr><tr><td data-num="7"></td><td><pre>cluster-config-file nodes-6379.conf <span class="token comment"># 设置节点配置文件名称，需要更改</span></pre></td></tr><tr><td data-num="8"></td><td><pre>cluster-node-timeout <span class="token number">15000</span> <span class="token comment"># 设置节点失联事件，超过该时间（ms），集群自动进行主从切换</span></pre></td></tr></table></figure><p><img data-src="image_Z6oabPxOUI.png" alt=""></p></li><li><p>启动</p><p><img data-src="image_Qa4reQgQ3W.png" alt=""></p></li><li><p>将 6 个节点合成一个集群</p><p>组合之前请确保所有 redis 实例启动后，nodes-xxxx.conf 文件都生成正常。</p><p><img data-src="image_edkTh3bsP0.png" alt=""></p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 进入 redis 安装目录</span></pre></td></tr><tr><td data-num="2"></td><td><pre>/opt/redis-6.2.6/src</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment"># 执行</span></pre></td></tr><tr><td data-num="5"></td><td><pre>redis-cli <span class="token parameter variable">--cluster</span> create --cluster-replicas <span class="token number">1</span> <span class="token number">172.16</span>.88.168:6379 <span class="token number">172.16</span>.88.168:6380 <span class="token number">172.16</span>.88.168:6381 <span class="token number">172.16</span>.88.168:6389 <span class="token number">172.16</span>.88.168:6390 <span class="token number">172.16</span>.88.168:6391</pre></td></tr></table></figure><p><img data-src="image_6422nCmUjp.png" alt=""></p></li><li><p>采用集群策略连接</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>redis-cli <span class="token parameter variable">-c</span> <span class="token parameter variable">-p</span> PORT</pre></td></tr><tr><td data-num="2"></td><td><pre>cluster nodes <span class="token comment"># 命令查看集群信息</span></pre></td></tr></table></figure><p><img data-src="image_8J74DT92B1.png" alt=""></p></li></ol><h4 id="问题"><a class="anchor" href="#问题">#</a> 问题</h4><p><em><strong>redis cluster</strong></em>** 如何分配这六个节点？** ​</p><blockquote><p>一个集群至少要有三个主节点。</p><p>选项 <code>--cluster-replicas 1</code> ，表示希望为集群中的每个主节点创建一个从节点。</p><p>分配原则尽量保证每个主数据库运行在不同的 <em><strong>IP</strong></em> 地址，每个从库和主库不在一个 <em><strong>IP</strong></em> 地址上。</p><p><img data-src="202206241258001.png" alt=""></p></blockquote><p><strong>什么是 <em><strong><strong>slots</strong></strong></em>？</strong></p><p><img data-src="202206241259789.png" alt=""></p><p><img data-src="202206241259691.png" alt=""></p><blockquote><p>一个 <em><strong>Redis</strong></em> 集群包含 <em><strong>16384</strong></em> 个插槽（<em><strong>hash slot</strong></em>）， 数据库中的每个键都属于这 <em><strong>16384</strong></em> 个插槽的其中一个。</p><p>集群使用公式 <em><strong>CRC16(key) % 16384</strong></em> 来计算键 <em><strong>key</strong></em> 属于哪个槽， 其中 <em><strong>CRC16(key)</strong></em> 语句用于计算键 <em><strong>key</strong></em> 的 <em><strong>CRC16</strong></em> 校验和 。</p><p>集群中的每个节点负责处理一部分插槽。 例如， 如果一个集群可以有主节点， 其中：</p><ul><li>节点 <em><strong>A</strong></em> 负责处理 <em><strong>0</strong></em> 号至 <em><strong>5460</strong></em> 号插槽。</li><li>节点 <em><strong>B</strong></em> 负责处理 <em><strong>5461</strong></em> 号至 <em><strong>10922</strong></em> 号插槽。</li><li>节点 <em><strong>C</strong></em> 负责处理 <em><strong>10923</strong></em> 号至 <em><strong>16383</strong></em> 号插槽。</li></ul></blockquote><p><strong>如何在集群中录入值？</strong></p><blockquote><p>在 <em><strong>redis-cli</strong></em> 每次录入、查询键值，<em><strong>redis</strong></em> 都会计算出该 <em><strong>key</strong></em> 应该送往的插槽，如果不是该客户端对应服务器的插槽，<em><strong>redis</strong></em> 会报错，并告知应前往的 <em><strong>redis</strong></em> 实例地址和端口。</p><p><em><strong>redis-cli</strong></em> 客户端提供了 <em><strong>–c</strong></em> 参数实现自动重定向。</p><p>例如 <em><strong>redis-cli -c –p 6379</strong></em> 登入后，再录入、查询键值对可以自动重定向。</p></blockquote><p><strong>如何查询集群中的值</strong></p><blockquote><p>每个主机只能查询自己范围内部的插槽。</p><p><code>cluster keyslot &lt;key&gt;</code> ：查询某个 <em><strong>key</strong></em> 的 **<em>slot</em> **。</p><p><code>cluster countkeysinslot &lt;slot&gt;</code> ：查询某个 <em><strong>slot</strong></em> 是否有值。</p><p><code>CLUSTER GETKEYSINSLOT &lt;slot&gt;&lt;count&gt;</code> ：返回 <em><strong>count</strong></em> 个 <em><strong>slot</strong></em> 槽中的键。</p></blockquote><p><strong>故障恢复</strong></p><blockquote><p>如果主节点下线？从节点能否自动升为主节点？注意：<em><strong>15</strong></em> 秒超时。</p><p><img data-src="202206241259357.png" alt=""></p><ul><li>当 <em><strong>6379</strong></em> 挂掉后，<em><strong>6389</strong></em> 成为新的主机。</li></ul><p>主节点恢复后，主从关系会如何？主节点回来变成从机。</p><ul><li>当 <em><strong>6379</strong></em> 重启后，<em><strong>6379</strong></em> 成为 <em><strong>6389</strong></em> 的从机。</li></ul><p>如果所有某一段插槽的主从节点都宕掉，<em><strong>redis</strong></em> 服务是否还能继续？</p><ul><li>如果某一段插槽的主从都挂掉，而 <em><strong>cluster-require-full-coverage=yes</strong></em>，那么 ，整个集群都挂掉。</li><li>如果某一段插槽的主从都挂掉，而 <em><strong>cluster-require-full-coverage=no</strong></em>，那么，该插槽数据全都不能使用，也无法存储。</li></ul><p><code>redis.conf</code> 中的参数 <code>cluster-require-full-coverage</code></p></blockquote><h4 id="优点-3"><a class="anchor" href="#优点-3">#</a> 优点</h4><ul><li>实现扩容；</li><li>分摊压力；</li><li>无中心配置相对简单。</li></ul><h4 id="缺点-3"><a class="anchor" href="#缺点-3">#</a> 缺点</h4><ul><li>多键操作是不被支持的；</li><li>多键的 <em><strong>Redis</strong></em> 事务是不被支持的。<em><strong>lua</strong></em> 脚本不被支持；</li><li>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至_<strong>redis cluster</strong>_，需要整体迁移而不是逐步过渡，复杂度较大。</li></ul><h3 id="应用问题解决"><a class="anchor" href="#应用问题解决">#</a> 应用问题解决</h3><h4 id="缓存穿透"><a class="anchor" href="#缓存穿透">#</a> 缓存穿透</h4><p><img data-src="202206241300146.png" alt=""></p><p><strong>现象</strong></p><p><em><strong>key</strong></em> 对应的数据在数据源并不存在，每次针对此 <em><strong>key</strong></em> 的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。</p><p>比如用一个不存在的用户 <em><strong>id</strong></em> 获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。</p><p>造成：</p><ol><li>应用服务器压力变大。</li><li><em><strong>redis</strong></em> 命中率下降 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.522em;vertical-align:-.011em"></span><span class="mrel">⟶</span></span></span></span> 查询数据库 。</li></ol><p><strong>如何解决</strong></p><ul><li><p><strong>对空值缓存</strong></p><p>如果一个查询返回的数据为空（不管是数据是否不存在），仍然把这个空结果（<em><strong>null</strong></em>）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟。</p></li><li><p><strong>设置可访问的名单（白名单）：</strong></p><p>使用 <em><strong>bitmaps</strong></em> 类型定义一个可以访问的名单，名单 <em><strong>id</strong></em> 作为 <em><strong>bitmaps</strong></em> 的偏移量，每次访问和 <em><strong>bitmap</strong></em> 里面的 <em><strong>id</strong></em> 进行比较，如果访问 <em><strong>id</strong></em> 不在 <em><strong>bitmaps</strong></em> 里面，进行拦截，则不允许访问。</p></li><li><p><strong>采用布隆过滤器</strong></p><p>布隆过滤器（<em><strong>Bloom Filter</strong></em>）是 1970 年由布隆提出的。它实际上是一个很长的二进制向量（位图）和一系列随机映射函数（哈希函数）。</p><p>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p><p>将所有可能存在的数据哈希到一个足够大的 <em><strong>bitmaps</strong></em> 中，一个一定不存在的数据会被这个 <em><strong>bitmaps</strong></em> 拦截掉，从而避免了对底层存储系统的查询压力。</p></li><li><p><strong>进行实时监控</strong></p><p>当发现 <em><strong>Redis</strong></em> 的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务。</p></li></ul><h4 id="缓存击穿"><a class="anchor" href="#缓存击穿">#</a> 缓存击穿</h4><p><img data-src="202206241301946.png" alt=""></p><p><em><strong>key</strong></em> 对应的数据存在，但在 <em><strong>redis</strong></em> 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端_<strong>DB</strong>_ 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 <em><strong>DB</strong></em> 压垮。</p><ol><li>数据库访问压力瞬间增大。</li><li><em><strong>redis</strong></em> 中没有出现大量 <em><strong>key</strong></em> 过期，<em><strong>redis</strong></em> 正常运行。</li><li>（即某个经常访问的 <em><strong>key</strong></em> 过期，突然有大量访问这个数据）</li></ol><h4 id="如何解决"><a class="anchor" href="#如何解决">#</a> 如何解决</h4><ul><li><p>预先设置热门数据</p><p>在 <em><strong>redis</strong></em> 高峰访问之前，把一些热门数据提前存入到 <em><strong>redis</strong></em> 里面，加大这些热门数据 <em><strong>key</strong></em> 的时长。</p></li><li><p>实时调整</p><p>现场监控哪些数据热门，实时调整 <em><strong>key</strong></em> 的过期时长。</p></li><li><p>使用锁</p></li></ul><h4 id="缓存雪崩"><a class="anchor" href="#缓存雪崩">#</a> 缓存雪崩</h4><p><em><strong>key</strong></em> 对应的数据存在，但在 <em><strong>redis</strong></em> 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端_<strong>DB</strong>_ 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 <em><strong>DB</strong></em> 压垮。</p><p>缓存雪崩与缓存击穿的区别在于这里针对很多 <em><strong>key</strong></em> 缓存，前者则是某一个 <em><strong>key</strong></em>。</p><ol><li>数据库压力变大。</li><li>即极少的时间段，查询大量 <em><strong>key</strong></em> 的集中过期情况。</li></ol><h4 id="如何解决-2"><a class="anchor" href="#如何解决-2">#</a> 如何解决</h4><ul><li><p><strong>构建多级缓存架构</strong></p><p><em><strong>nginx</strong></em> 缓存 + <em><strong>redis</strong></em> 缓存 + 其他缓存（_<strong>ehcache</strong>_等）</p></li><li><p><strong>使用锁或队列：</strong></p><p>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况。</p></li><li><p><strong>设置过期标志更新缓存：</strong></p><p>记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际 <em><strong>key</strong></em> 的缓存。</p></li><li><p><strong>将缓存失效时间分散开：</strong></p><p>比如我们可以在原有的失效时间基础上增加一个随机值，比如 1～5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p></li></ul><h4 id="分布式锁"><a class="anchor" href="#分布式锁">#</a> 分布式锁</h4><p>解决分布式时加锁问题。</p><p>解决方案：</p><ol><li>基于 zookeeper，可靠性最高</li><li>基于 redis，性能最高</li></ol><p><strong>使用 redis 解决方案</strong></p><p>redis：命令</p><p>setnx key value 命令</p><p>只有键不存在时，才能对键进行设置操作。</p><p><img data-src="image_Sawm5Qeg9i.png" alt=""></p><ol><li><p>使用 setnx 上锁，通过 del key 使用锁</p></li><li><p>锁一直没有释放，设置 key 过期时间，自动释放</p></li><li><p>防止在上锁完后出现异常无法设置过期时间，可以同时设置。</p><p>使用命令 set key value nx ex 过期时间</p></li></ol><p>** UUID 防止误删 **​</p><p>在使用 redis 分布式锁时，可能存在一个机器 a 操作时，获取锁了，操作还没结束。锁过期了，自动释放了，b 机器就会拿到这个锁进行操作。这时候，a 机器操作完了手动释放锁了。b 机器的锁就会释放，这样的问题。</p><p><strong>解决：</strong></p><ol><li>使用不同的 uuid 表示不同的操作，防止误删锁。<figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token builtin class-name">set</span> lock uuid nx ex <span class="token number">10</span></pre></td></tr></table></figure></li><li>释放锁的时候，先检查当前 uuid 和要释放的 uuid 是否一样。</li></ol><p>为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：</p><ol><li>互斥性。在任意时刻，只能有一个客户端持有锁</li><li>不能发生死锁。即使有一个客户端在持有锁的期间崩溃而没有自动解锁，也能保证后续其他客户端能加锁。</li><li>解铃还需系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</li><li>加锁和解锁必须具有原子性。可以使用 LUA 脚本实现。LUA 脚本类似 redis 事务，有一定的原子性，不会被其他命令插队，可以完后一些 redis 事务性操作。</li></ol></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-02-17 08:22:31" itemprop="dateModified" datetime="2023-02-17T08:22:31+00:00">2023-02-17</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Xiao Gao <i class="ic i-at"><em>@</em></i>学习笔记记录分享站</li><li class="link"><strong>本文链接：</strong> <a href="https://mianyuang.github.io/2022/09/15/redis/" title="redis">https://mianyuang.github.io/2022/09/15/redis/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/09/14/mysql/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclhtuo6nj20zk0m8ttm.jpg" title="mysql"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 数据库</span><h3>mysql</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#redis"><span class="toc-number">1.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#redis-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">Redis 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.1.</span> <span class="toc-text">Redis 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.1.2.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF"><span class="toc-number">1.1.3.</span> <span class="toc-text">相关技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rediskey%E9%94%AE"><span class="toc-number">1.1.4.</span> <span class="toc-text">Redis（key）键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E4%BA%94%E5%A4%A7%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.5.</span> <span class="toc-text">常用五大基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2string"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">字符串（String）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">原子性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E8%A1%A8list"><span class="toc-number">1.1.5.4.</span> <span class="toc-text">列表（List）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set%E9%9B%86%E5%90%88"><span class="toc-number">1.1.5.5.</span> <span class="toc-text">Set（集合）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hash%E5%93%88%E5%B8%8C"><span class="toc-number">1.1.5.6.</span> <span class="toc-text">Hash（哈希）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#zset%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88"><span class="toc-number">1.1.5.7.</span> <span class="toc-text">Zset（有序集合）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.6.</span> <span class="toc-text">配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#units"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">Units</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#includes"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">INCLUDES</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#network"><span class="toc-number">1.1.6.3.</span> <span class="toc-text">NETWORK</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#general"><span class="toc-number">1.1.6.4.</span> <span class="toc-text">GENERAL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#security"><span class="toc-number">1.1.6.5.</span> <span class="toc-text">SECURITY</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#limits"><span class="toc-number">1.1.6.6.</span> <span class="toc-text">LIMITS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E7%9A%84%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85"><span class="toc-number">1.1.7.</span> <span class="toc-text">Redis 的发布与订阅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis6%E4%B8%AD%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.8.</span> <span class="toc-text">Redis6 中新的数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bitmaps"><span class="toc-number">1.1.8.1.</span> <span class="toc-text">Bitmaps</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="toc-number">1.1.8.2.</span> <span class="toc-text">操作命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hyperloglog"><span class="toc-number">1.1.8.3.</span> <span class="toc-text">HyperLogLog</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#springboot%E6%95%B4%E5%90%88redis6"><span class="toc-number">1.1.9.</span> <span class="toc-text">Springboot 整合 Redis6</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.10.</span> <span class="toc-text">Redis 事务和锁机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.10.1.</span> <span class="toc-text">事务操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">1.1.10.2.</span> <span class="toc-text">悲观锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">1.1.10.3.</span> <span class="toc-text">乐观锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#watch-unwatch"><span class="toc-number">1.1.10.4.</span> <span class="toc-text">Watch、UnWatch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E4%B8%89%E7%89%B9%E6%80%A7"><span class="toc-number">1.1.10.5.</span> <span class="toc-text">事务三特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.1.11.</span> <span class="toc-text">Redis 持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rdb"><span class="toc-number">1.1.11.1.</span> <span class="toc-text">RDB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%87%E4%BB%BD%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84"><span class="toc-number">1.1.11.2.</span> <span class="toc-text">备份是如何执行的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fork"><span class="toc-number">1.1.11.3.</span> <span class="toc-text">Fork</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rdb%E6%8C%81%E4%B9%85%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.11.4.</span> <span class="toc-text">RDB 持久化流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE"><span class="toc-number">1.1.11.5.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">1.1.11.6.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">1.1.11.7.</span> <span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#aof"><span class="toc-number">1.1.11.8.</span> <span class="toc-text">AOF</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-2"><span class="toc-number">1.1.11.9.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-2"><span class="toc-number">1.1.11.10.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-2"><span class="toc-number">1.1.11.11.</span> <span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9"><span class="toc-number">1.1.11.12.</span> <span class="toc-text">选择</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">1.1.12.</span> <span class="toc-text">主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E9%87%8D%E5%A4%8D%E5%88%B6-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%BB%E5%A4%9A%E4%BB%8E"><span class="toc-number">1.1.12.1.</span> <span class="toc-text">主重复制 - 搭建一主多从</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%BB%E4%BA%8C%E4%BB%86"><span class="toc-number">1.1.12.2.</span> <span class="toc-text">一主二仆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.12.3.</span> <span class="toc-text">复制原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%96%AA%E7%81%AB%E7%9B%B8%E4%BC%A0"><span class="toc-number">1.1.12.4.</span> <span class="toc-text">薪火相传</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%AE%A2%E4%B8%BA%E4%B8%BB"><span class="toc-number">1.1.12.5.</span> <span class="toc-text">反客为主</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.12.6.</span> <span class="toc-text">哨兵模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E4%B8%BE%E8%A7%84%E5%88%99"><span class="toc-number">1.1.12.7.</span> <span class="toc-text">选举规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E9%9B%86%E7%BE%A4"><span class="toc-number">1.1.13.</span> <span class="toc-text">Redis 集群</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA-redis-%E9%9B%86%E7%BE%A4"><span class="toc-number">1.1.13.1.</span> <span class="toc-text">搭建 Redis 集群</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.13.2.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-3"><span class="toc-number">1.1.13.3.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-3"><span class="toc-number">1.1.13.4.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-number">1.1.14.</span> <span class="toc-text">应用问题解决</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">1.1.14.1.</span> <span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">1.1.14.2.</span> <span class="toc-text">缓存击穿</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">1.1.14.3.</span> <span class="toc-text">如何解决</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">1.1.14.4.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-2"><span class="toc-number">1.1.14.5.</span> <span class="toc-text">如何解决</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">1.1.14.6.</span> <span class="toc-text">分布式锁</span></a></li></ol></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/2022/09/15/redis/" rel="bookmark" title="redis">redis</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Xiao Gao" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Xiao Gao</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">3</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">3</span> <span class="name">分类</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lvdXJuYW1l" title="https:&#x2F;&#x2F;github.com&#x2F;yourname"><i class="ic i-github"></i></span> <span class="exturl item google" data-url="aHR0cHM6Ly9wbHVzLmdvb2dsZS5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;plus.google.com&#x2F;yourname"><i class="ic i-google"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;twitter.com&#x2F;yourname"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yourname"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPXlvdXJpZA==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;yourid"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;weibo.com&#x2F;yourname"><i class="ic i-weibo"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Xiao Gao @ Xiao Gao</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/09/15/redis/",favicon:{show:"（●´3｀●）loading",hide:"(´Д｀) 你快回来"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->