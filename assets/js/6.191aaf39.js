(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{469:function(t,e,s){t.exports=s.p+"assets/img/1.452212da.png"},470:function(t,e,s){t.exports=s.p+"assets/img/2.c938f615.png"},471:function(t,e,s){t.exports=s.p+"assets/img/3.af7f2b6c.png"},472:function(t,e,s){t.exports=s.p+"assets/img/4.1cc06e65.png"},510:function(t,e,s){"use strict";s.r(e);var a=s(65),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"key的作用与原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#key的作用与原理"}},[t._v("#")]),t._v(" key的作用与原理")]),t._v(" "),a("p",[a("img",{attrs:{src:s(469),alt:""}})]),t._v(" "),a("h4",{attrs:{id:"vue中的key有什么作用-key的内部原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue中的key有什么作用-key的内部原理"}},[t._v("#")]),t._v(" VUE中的KEY有什么作用（key的内部原理）")]),t._v(" "),a("p",[t._v("虚拟DOM中key的作用")]),t._v(" "),a("p",[t._v("可以是虚拟DOM对象的标识，当数据发生变化时，VUE会根据新数据生成新的"),a("strong",[t._v("虚拟DOM")]),t._v("，随后VUE进行"),a("strong",[t._v("新虚拟DOM")]),t._v("和"),a("strong",[t._v("旧虚拟DOM")]),t._v("的对比。")]),t._v(" "),a("p",[t._v("会根据key来进行比较，如果key相同，看下内容相不相同，相同则直接拿旧的虚拟DOM内容直接复用，不需要重新渲染，对比不相同则重新渲染。")]),t._v(" "),a("h4",{attrs:{id:"vue数据检测变化原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue数据检测变化原理"}},[t._v("#")]),t._v(" VUE数据检测变化原理")]),t._v(" "),a("p",[t._v("在vue中，data数据在经过"),a("strong",[t._v("vue加工后")]),t._v("，在给_data里。如何加工是重点，主要通过观察者模式进行检测。当你数据是一个对象时，会一直递归找到没有对象为止，给每个属性提供getter和setter方法，在setting中重新去渲染数据。")]),t._v(" "),a("p",[t._v("Vue.set(追加的目标，添加的属性，值)可以添加及时相应，直接在_data中添加getter和setter方法。vm.$set方法具有相同的效果。")]),t._v(" "),a("p",[a("img",{attrs:{src:s(470),alt:""}})]),t._v(" "),a("p",[a("img",{attrs:{src:s(471),alt:""}})]),t._v(" "),a("p",[a("strong",[t._v("VUE定义组件步骤")])]),t._v(" "),a("p",[a("img",{attrs:{src:s(472),alt:""}})])])}),[],!1,null,null,null);e.default=r.exports}}]);