(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{502:function(t,e,a){"use strict";a.r(e);var v=a(65),_=Object(v.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"react拓展"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react拓展"}},[t._v("#")]),t._v(" react拓展")]),t._v(" "),a("h4",{attrs:{id:"setstate更新状态的两种方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setstate更新状态的两种方法"}},[t._v("#")]),t._v(" setState更新状态的两种方法")]),t._v(" "),a("p",[t._v("setState后的操作是异步的。")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("对象式的setState")]),t._v(" "),a("p",[a("code",[t._v("setState(stateChange,[callback])")])]),t._v(" "),a("ol",[a("li",[a("p",[a("code",[t._v("stateChange")]),t._v("为状态改变对象（体现状态的更改）")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("callback")]),t._v("是可选的回调函数，它在状态更新完毕、界面也更新后（"),a("code",[t._v("render")]),t._v("调用后）才被调用")])])])]),t._v(" "),a("li",[a("p",[t._v("函数式的setState")]),t._v(" "),a("p",[a("code",[t._v("setState(updater,[callback])")])]),t._v(" "),a("ol",[a("li",[a("p",[a("code",[t._v("updater")]),t._v("为 返回"),a("code",[t._v("stateChange")]),t._v("对象的函数")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("updater")]),t._v("可以接收到"),a("code",[t._v("state")]),t._v("和"),a("code",[t._v("props")])])]),t._v(" "),a("li",[a("p",[a("code",[t._v("callback")]),t._v("是可选的回调函数，它在状态更新完毕、界面也更新后（"),a("code",[t._v("render")]),t._v("调用后）才被调用")])])])])]),t._v(" "),a("p",[t._v("总结：")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("对象式的setState是函数式的setState的简写方式（语法糖）")])]),t._v(" "),a("li",[a("p",[t._v("使用原则：")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("如果新状态不依赖于原状态，使用对象式写法")])]),t._v(" "),a("li",[a("p",[t._v("如果新状态依赖于原状态，使用函数式写法")])]),t._v(" "),a("li",[a("p",[t._v("如果需要在setState执行后获取最新的状态数据，要在第二个callback函数中获取。")])])])])]),t._v(" "),a("h4",{attrs:{id:"路由懒加载-需要在加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#路由懒加载-需要在加载"}},[t._v("#")]),t._v(" 路由懒加载，需要在加载")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("通过react的lazy函数配合import函数动态加载路由组件，路由组件代码会被分开打包。")]),t._v(" "),a("div",{staticClass:"language-react&#x20;jsx extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const Login = lazy(()=>import('@/page/Login'))\n")])])])]),t._v(" "),a("li",[a("p",[t._v("通过Suspense组件指定在加载得到路由打包文件前显示一个自定义loading页面")]),t._v(" "),a("div",{staticClass:"language-react&#x20;jsx extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("<Suspense fallback={<h1>loading.....</h1>}>\n  <Switch>\n    <Route path='xx/xx' component={xxxxx}/>\n  </Switch>\n\n")])])])])]),t._v(" "),a("h4",{attrs:{id:"hooks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hooks"}},[t._v("#")]),t._v(" Hooks")]),t._v(" "),a("p",[t._v("16.8版本后出现的Hooks，让函数式组件可以使用state、生命周期等。")]),t._v(" "),a("p",[a("strong",[t._v("三个常用的Hook")])]),t._v(" "),a("ol",[a("li",[a("p",[t._v("state Hook：React.useState()")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("state Hook让函数组件也可以有state状态，并进行状态数据的读写操作")])]),t._v(" "),a("li",[a("p",[t._v("语法："),a("code",[t._v("const [xxx,setXxx]=React.useState(initValue)")])])]),t._v(" "),a("li",[a("p",[a("code",[t._v("useState()")]),t._v("语法说明：")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("参数：第一次初始化指定的值在内部做缓存")])]),t._v(" "),a("li",[a("p",[t._v("返回值：包含两个元素的数组，第一个为内部当前状态值，第二个为更新状态值的函数。")])])])]),t._v(" "),a("li",[a("p",[t._v("setXxx()2种写法：")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("setXxx(newValue)：参数为非函数值，直接指定新的状态值，内部用其覆盖原来的状态值")])]),t._v(" "),a("li",[a("p",[t._v("setXxx(value=>newValue):参数为函数，接收原本的状态值，返回新的状态值，内部用其覆盖原来的状态值")])])])])])]),t._v(" "),a("li",[a("p",[t._v("Effect Hook: React.useEffect()")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("可以让函数组件模拟类似类组件中的生命周期钩子")])]),t._v(" "),a("li",[a("p",[t._v("语法和说明：")]),t._v(" "),a("div",{staticClass:"language-react&#x20;jsx extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("useEffect(()=>{\n  //在此可以执行任何带副作用操作\n  return ()=>{//在卸载组件前执行\n    //在此做一些收尾工作，比如清除定时器/取消订阅\n  }\n},[stateValue])//如果指定的是[]，回调函数只会在第一次render时调用\n")])])])])])]),t._v(" "),a("li",[a("p",[t._v("Ref Hook:React.useRef()")]),t._v(" "),a("p",[t._v("Ref Hook可以在函数式组件中存储/查找组件内的标签或其他任意数据")]),t._v(" "),a("p",[t._v("语法："),a("code",[t._v("const refContainer=useRef()")])]),t._v(" "),a("p",[t._v("作用：保存标签对象，功能和"),a("code",[t._v("react.createRef()")]),t._v("一样")])])]),t._v(" "),a("h4",{attrs:{id:"fragment组件使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fragment组件使用"}},[t._v("#")]),t._v(" Fragment组件使用")]),t._v(" "),a("p",[t._v("每个组件都需要包裹一个div，在解析时，就会多了这个无用的div标签，使用Fragment可以在react解析时去掉Fragment。")]),t._v(" "),a("div",{staticClass:"language-react&#x20;jsx extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<Fragment>\n  <input type="text"/>\n  <input type="text"/>\n</Fragment>\n')])])]),a("h4",{attrs:{id:"context-一种组件间通信的方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#context-一种组件间通信的方式"}},[t._v("#")]),t._v(" Context-一种组件间通信的方式")]),t._v(" "),a("p",[t._v("常用于祖组件与后代组件间通信")]),t._v(" "),a("p",[t._v("使用：")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("创建Context容器对象")]),t._v(" "),a("div",{staticClass:"language-react&#x20;jsx extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const xxxContext = React.createContext()//在祖组件的声明外定义\nexport default class A {\n  render(){\n  <xxxContext.Provider value={数据}>\n    子组件    \n    <B/>\n  </xxxContext.Provider>\n  }\n}\n")])])])]),t._v(" "),a("li",[a("p",[t._v("渲染子组件时，外面包裹xxxContext.Provider，通过value属性给后代组件传递数据")]),t._v(" "),a("div",{staticClass:"language-react&#x20;jsx extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("<xxxContext.Provider value={数据}>\n  子组件\n</xxxContext.Provider>\n")])])])]),t._v(" "),a("li",[a("p",[t._v("后代组件读取数据")]),t._v(" "),a("div",{staticClass:"language-react&#x20;jsx extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("//第一种方式：仅适用于类组件\nstatic contextType = xxxContext //声明接收context\nthis.context //读取context中的value数据\n//第二种方式：两种类型组件都可以使用\n<xxxContext.Consumer>\n  {\n    value=>(//value就是cintext中的value数据\n      要显示的内容\n    )\n  }\n</xxxContext.Consumer>\n\n")])])])])]),t._v(" "),a("h4",{attrs:{id:"purecomponent组件优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#purecomponent组件优化"}},[t._v("#")]),t._v(" PureComponent组件优化")]),t._v(" "),a("p",[a("strong",[t._v("component组件的2个问题")])]),t._v(" "),a("ol",[a("li",[a("p",[t._v("只要执行setState方法，即使不改变状态数据，组件也会重新render")])]),t._v(" "),a("li",[a("p",[t._v("只当前组件重新render，就会自动重新render子组件，即使子组件没有用到父组件的任何数据")])])]),t._v(" "),a("p",[a("strong",[t._v("效率高的办法")])]),t._v(" "),a("p",[t._v("只有当组件的props或state数据发生变化才重新render")]),t._v(" "),a("p",[a("strong",[t._v("原因")])]),t._v(" "),a("p",[t._v("component中的"),a("code",[t._v("shouldComponentUpdate()")]),t._v("总是返回true")]),t._v(" "),a("p",[a("strong",[t._v("解决")])]),t._v(" "),a("ol",[a("li",[a("p",[t._v("办法1")]),t._v(" "),a("p",[t._v("重写"),a("code",[t._v("shouldComponentUpdate()")]),t._v("方法")]),t._v(" "),a("p",[t._v("比较新旧state和props数据，有变化就返回true，没有变化返回false")])]),t._v(" "),a("li",[a("p",[t._v("办法2")]),t._v(" "),a("p",[t._v("使用"),a("code",[t._v("pureComponent")]),t._v("组件")]),t._v(" "),a("p",[a("code",[t._v("pureComponent")]),t._v("组件重写了"),a("code",[t._v("shouldComponentUpdate()")]),t._v("方法，只有state或props数据有变化才返回true")]),t._v(" "),a("p",[t._v("注意：")]),t._v(" "),a("p",[t._v("只是进行state和props数据的浅比较，如果只是数据对象内部数据变了，返回false")]),t._v(" "),a("p",[t._v("不要直接修改state数据，而是要产生新数据")])]),t._v(" "),a("li",[a("p",[t._v("项目中一般使用PureComponent优化，代替Component组件")])])]),t._v(" "),a("p",[a("strong",[t._v("render props类似vue插槽")])]),t._v(" "),a("p",[a("strong",[t._v("如何向组件内部动态传入带内容的结构（标签）")])]),t._v(" "),a("p",[t._v("vue中：")]),t._v(" "),a("p",[t._v("使用slot技术，也就是通过组件标签体传入结构"),a("code",[t._v("<A><B/></A>")])]),t._v(" "),a("p",[t._v("react中：")]),t._v(" "),a("p",[t._v("使用children props：通过组件标签体传入结构")]),t._v(" "),a("div",{staticClass:"language-react&#x20;jsx extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("<A>\n  <B>xxxxx</B>\n</A>\n{this.props.children}\n问题：如果B组件需要A组件内的数据，这种方式做不到\n")])])]),a("p",[t._v("使用render props：通过组件标签属性传入结构，一般用render函数属性")]),t._v(" "),a("div",{staticClass:"language-react&#x20;jsx extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("<A render={(data)=> <C data={data}></C>}></A>\n\nA组件：{this.props.render(内部state数据)}\nC组件：读取A组件传入的数据显示{this.props.data}\n")])])]),a("h4",{attrs:{id:"错误边界"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#错误边界"}},[t._v("#")]),t._v(" 错误边界")]),t._v(" "),a("p",[t._v("理解：")]),t._v(" "),a("p",[t._v("错误边界：用来捕获后代组件错误，渲染出备用页面，哪个组件可能出错，就找到它的父组件来编写错误边界")]),t._v(" "),a("p",[t._v("特点：")]),t._v(" "),a("p",[t._v("只能捕获后代组件生命周期产生的错误，不能捕获自己组件产生的错误和其他组件在合成事件、定时器中产生的错误")]),t._v(" "),a("p",[t._v("使用方式：")]),t._v(" "),a("p",[t._v("getDerivedStateFromError配合componentDidCatch")]),t._v(" "),a("div",{staticClass:"language-react&#x20;jsx extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("state = {hasError:false}\n//生命周期函数，一旦后代组件报错，就会触发\nstatic getDerivedStateFromError(error){\n  //在render之前触发\n  //返回新的state\n  return{hasError:true}\n}\ncomponentDidCatch(error,info){\n  //统计页面的错误。发送请求发送到后台去\n  console.log(error,info)\n}\n")])])]),a("h4",{attrs:{id:"通信方式总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#通信方式总结"}},[t._v("#")]),t._v(" 通信方式总结")]),t._v(" "),a("p",[a("strong",[t._v("组件间的关系")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("父子组件")])]),t._v(" "),a("li",[a("p",[t._v("兄弟组件")])]),t._v(" "),a("li",[a("p",[t._v("祖孙组件")])])]),t._v(" "),a("p",[a("strong",[t._v("通信方式")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("props")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("children props")])]),t._v(" "),a("li",[a("p",[t._v("render props")])])])]),t._v(" "),a("li",[a("p",[t._v("消息订阅-发布")]),t._v(" "),a("ul",[a("li",[t._v("pubs-sub、event等等")])])]),t._v(" "),a("li",[a("p",[t._v("集中式管理")]),t._v(" "),a("ul",[a("li",[t._v("redux、dva等")])])]),t._v(" "),a("li",[a("p",[t._v("conText")]),t._v(" "),a("ul",[a("li",[t._v("生产者-消费者")])])])]),t._v(" "),a("p",[a("strong",[t._v("比较好的搭配")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("父子组件：props")])]),t._v(" "),a("li",[a("p",[t._v("兄弟组件：消息订阅-发布、集中式管理")])]),t._v(" "),a("li",[a("p",[t._v("祖孙组件：消息订阅-发布、集中式管理、conText")])])])])}),[],!1,null,null,null);e.default=_.exports}}]);