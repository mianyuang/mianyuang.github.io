---
title: mysql
date: 2022-09-13 19:18:35
categories: 数据库
tags:
---
# MYSQL8新特性

## 窗口函数

窗口函数的作用类似于子查询中对数据进行分组，不同的是，分组操作会把分组的结果聚合成一条记录，而窗口函数是将结果置于每一条数据记录中。

## 窗口函数分类

可分为静态窗口函数和动态窗口函数。

-   静态窗口函数的窗口大小是固定的，不会因为记录的不同而不同
-   动态窗口函数的窗口大小会随着记录的不同而变化。

窗口函数总体上可以分为序号函数、分布函数、前后函数、首尾函数和其他函数，如下表：

![](image_naPtBYf8Gz.png)

## 语法结构

```sql
函数 OVER （[PARTTITION BY 字段名 ORDER BY 字段名 ASC｜DESC]）
```

或者是

```sql
函数 OVER 窗口名 ....WINDOW 窗口名 AS（[PARTTITION BY 字段名 ORDER BY 字段名 ASC｜DESC]）
```

-   OVER关键字指定函数窗口的范围
    -   如果省略后面括号的内容，则窗口会包含满足where条件的所有记录，窗口函数会基于所有满足WHERE条件的记录进行计算
    -   如果OVER关键字后面的括号不为空，则可以使用如下语法设置窗口。
-   窗口名：为窗口设置一个别名，用来标识窗口
-   PARTITION BY 子句：指定窗口函数按照哪些字段进行分组。分组后，窗口函数可以在每个分组分别执行。
-   ORDER BY 子句：指定窗口函数按照哪些字段进行排序。执行排序操作使窗口函数按照排序后的数据记录的顺序进行编号
-   FRAME 子句：为分区中的某个子集定义规则，可以用来作为滑动窗口使用。

## 分类讲解

### 序号函数：

1.  ROW\_NUMBER函数：

    ![](image_lLvr4-3LF9.png)
2.  RANK函数：

    ![](image_vastdTbnm0.png)
3.  DENSE\_RANK函数和RANK函数相反。

### 分布函数

1.  PERCENT\_RANK函数：

    此函数是等级值百分比函数，按照公式$(rank - 1) / (rows - 1)$来计算。

    其中rank的值为使用RANK函数产生的序号，rows值为当前窗口的总记录数。

    ![](image_7iIAJ0-Boa.png)
2.  CUME\_DIST函数:

    此函数主要用于查询小于或等于某个值的比例

    ![](image_TT0OB4ZKgE.png)

### 前后函数

1.  LAG(expr,n)函数：

    LAG(expr,n)函数返回当前行的前n行的expr值。

    ![](image_XZX5vJYxMF.png)
2.  LEAD(expr,n)函数：

    LEAD(expr,n)函数返回当前行的后n行的expr的值。

    ![](image_nXIhR2yQ5S.png)

### 首尾函数

1.  FIRST\_VALUE(expr)函数

    FIRST\_VALUE(expr)函数返回第一个expr的值。

    ![](image_ZKws6uAGXI.png)
2.  LAST\_VALUE(expr)函数：返回最后一个expr的值。

### 其他函数

1.  NTH\_VALUE(expr，n)函数：

    NTH\_VALUE(expr，n)函数返回第n个expr的值

    ![](image_72js3ghBW3.png)
2.  NTILE(n)函数：

    将分区中的有序数据分为n个桶，记录桶编号

    ![](image_YqqFsD-gJB.png)

# 字符集的相关操作

## 修改Mysql5.7字符集

在mysql8之前，默认字符集为`latin1`，utf8字符集指向的是`utf8mb3`，网站开发人员在数据库设计时往往会将编码修改为utf8。如果遗忘修改默认的编码，就会出现乱码的问题。从mysql8开始，数据库默认的编码就是utf8mb4，从而避免上述乱码的问题。

操作1：查看默认使用的字符集

```sql
show variables like 'character%';
或者
show variables like '%char%';
```

操作2：修改my.cnf配置文件，在配置文件中指定字符集

```sql
character_set_server=utf8
```

![](image_bhV525pXqp.png)

## 已有库已有表字符集的变更

mysql5.7版本中，以前创建的库，创建的表字符集还是latin1。

操作1：修改已有数据库的字符集

```sql
alter database 数据库名 character set 'utf8';
```

操作2：修改已有表的字符集

```sql
alter table 表名 convert to character set 'utf8';
```

## 各级别的字符集（底层原理说明）

mysql有4个级别的字符集和比较规则，分别是：

-   服务器级别
-   数据库级别
-   表级别
-   列级别

![](image_bhV525pXqp.png)

-   character\_set\_server：服务器级别的字符集
-   character\_set\_database：当前数据库的字符集
-   character\_set\_client：服务器解码请求时使用的字符集
-   character\_set\_connection：服务器处理请求时会把请求字符串从character\_set\_client转为character\_set\_connection
-   character\_set\_result：服务器向客户端返回数据时使用的字符集

设置server服务器级别的字符集后，相应的database字符集也会跟着变化。

-   当创建数据库时，不指定字符集，则使用database指定的字符集
-   当创建表时不指定字符集，则会根据所在库的字符集默认指定
-   当创建字段不指定字符集时，则会根据所在表的字符集默认指定

## 字符集与比较规则

### utf8与utf8mb4

utf8字符集表示一个字符需要使用1-4个字节，但是常使用的字符使用1-3个字节就可以表示了。而字符集表示一个字符所用到的最大字节长度，在某些方面会影响系统的存储和性能，所以定义了两个概念：

utf8mb3：阉割的utf8字符集，只使用1-3个字节表示字符。

utf8mb4：正宗的utf8字符集，使用1-4个字节表示字符。

查看mysql支持的字符集命令：show charset；

![](image_TJ24gtyOI7.png)

### 比较规则

Mysql一共支持41种字符集，其中的`Default collation`表示这些字符集中一种默认的比较规则，里面包含着该比较规则主要作用于哪种语言。如`utf8_polish_ci`表示以波兰语的规则比较，`utf8_general_ci`是一种通用的比较规则。

后缀表示该比较规则是否区分语言中的重音、大小写。具体如下：

![](image_1Mg_DVC-cB.png)

常用操作：

```sql
#查看GBK字符集的比较规则
show COLLATION LIKE 'gbk%';
#查看服务器的字符集和比较规则
show VARIABLES LIKE '%_server';
#查看数据库的字符集和比较规则
show VARIABLES DATABASE LIKE '%_database';
#查看具体数据库的字符集
show CREATE DATABASE 数据库名;
#修改数据库的字符集
ALTER DATABASE 数据库名 DEFAULT CHARACTER SET 'utf8' COLLATE 'utf8_general_ci';
#查看具体表的字符集
show CREATE TABLE 表名;
#修改表的字符集
ALTER TABLE 数据库名 DEFAULT CHARACTER SET 'utf8' COLLATE 'utf8_general_ci';

```

## 请求到相应过程中的编码

客户端请求mysql服务器时使用utf8编码，服务器使用character\_set\_client设置的字符集进行解码，在使用character\_set\_connection设置的字符集把character\_set\_client解码的内容编码到数据库中去查询，查询结果后在使用character\_set\_result设置的字符集编码返回给客户端，客户端在解码。

所以要求设置的编码必须要一致，可以添加如下配置到配置文件里可以指定character\_set\_client、character\_set\_connection、character\_set\_result三者的字符集。

```sql
[client]
default-character-set=utf8
```

## SQL大小写规范与sql\_mode的设置

### 查看大小写设置命令

```sql
show variables like 'lower_case_table_names';

```

![](image_PrFtsx8UW7.png)

lower\_case\_table\_names参数值的设置：

-   默认为0，大小写敏感
-   设置1，大小写不敏感。创建的表，数据库都是以小写的形式存在磁盘上，对于SQL语句都是转换为小写对表和数据库进行查找。
-   设置为2，创建的表和数据库依据语句上格式存放，凡是查找都是转换为小写进行。

### Linux下大小写规则设置

当想设置大小写不敏感时，要在`my.cnf`配置文件中\[mysqld]中加入`lower_case_table_names=1`，然后重启服务器。

-   但是要在重启数据库实例之前就需要将原来的数据库和表转换为小写，否则将找不到数据库名。
-   此参数适用于MYSQL5.7，在Mysql8下禁止在重新启动Mysql服务时将`lower_case_table_names`设置成不同于初始化mysql服务时设置的`lower_case_table_names`值。如果非要将mysql8是设置为大小写不敏感，具体步骤为：
    1.  停止mysql服务
    2.  删除数据目录，即删除/var/lib/mysql目录
    3.  在配置文件中添加`lower_case_table_names`=1
    4.  重新启动mysql服务

### SQL编写建议

![](image_MT0bejDC3j.png)

## sql\_mode的设置

sql\_mode会影响mysql支持的sql语法以及它执行的数据验证检查。通过设置mysql\_mode可以完成不同严格程度的数据校验，有效的保证数据准确性。

MYSQL服务器可以在不同的SQL模式下运行，并且可以针对不同的客户端以不同的方式应用这些模式，具体取决于sql\_mode系统变量的值。

mysql5.6和5.7默认的sql\_mode模式参数是不一样的：

-   5.6的mode默认值为空（即：NO\_ENGINE\_SUBSTITUTION），其实表示的是一个空值，相当于没有什么模式设置，可以理解为**宽松模式**。在这种设置下是可以允许一些非法操作的，比如允许一些非法数据的插入。
-   5.7的mode是STRICT\_TRANS\_TANLES，也就是**严格模式**，用于进行数据的严格校验，错误数据不能插入，报error错误，并且回滚事务。

### 宽松模式vs严格模式

-   宽松模式

    如果设置的是宽松模式，那么在插入数据时，即使给了一个错误的数据，也可能会被接受，并且不会报错。

    如：表中有一个name字段，类型为char（10），在插入数据时长度超过了10，例如‘1234567890abc’，超过了设定的长度，但不会报错，并且取前10个字符存上，也就是被存入了1234567890，abc忽略了。这就是宽松模式。
-   严格模式

    严格模式上面的情况出现就会报错。

### 模式的查看和设置

```sql
select @@session.sql_mode
select @@global.sql_mode
#或者
show variables like 'sql_mode';
#设置sql_mode模式
#session只在当前会话中生效，关闭当前会话就不生效了。
SET SESSION sql_mode = 想要的模式
#GLOBLA在当前服务生效，重启mysql服务后失效。
SET GLOBAL sql_mode = 想要的模式
#永久设置方式
在my.cnf配置文件中配置sql_mode
[mysqld]
sql_mode = 想要的模式,可以选择多个模式，多个模式使用，分割。
```

### 常用模式

![](image__G9svxLals.png)

# 数据库和文件系统的关系

像InnoDB、MyISAM这样的存储引擎都是把表存储在磁盘上的，操作系统用来管理磁盘的结构被称为文件系统，所以用专业一点的话来表示就是：像InnoDB、MyISAM这样的存储引擎都是把表存储在文件系统上的，`读取数据`时，`存储引擎`会把数据从文件系统中读取出来返回，`写入数据`时，存储引擎会把数据`写到文件系统去`。

## 表在文件系统中的表示

### InnoDB存储引擎模式

#### 在5.6.6版本之前

进入mysql数据存储目录`data`下

![](image_zFLAvRLKGv.png)

数据库表的数据都存放在`ibdata1`（称为系统表空间）中，进入创建的`testdb`数据库，可以看到：

![](image_MOB3JvcFmc.png)

有三个文件：

-   `db.opt`存放的是创建数据库时数据库的配置信息
-   `__.frm`文件存放的是创建表的结构
-   `__.ibd`文件存放的是表的数据（也称为独立表空间）5.6.6之前的版本应该是无。

#### 在5.7版本

![](image_zFLAvRLKGv.png)

数据库表的数据可以选择存放在`ibdata1`（称为系统表空间）中，进入创建的`testdb`数据库，可以看到：

![](image_MOB3JvcFmc.png)

有三个文件：

-   `db.opt`存放的是创建数据库时数据库的配置信息
-   `__.frm`文件存放的是创建表的结构
-   `__.ibd`文件存放的是表的数据（也称为独立表空间）。

#### 在8版本

![](image_zI0c41ME4U.png)

数据库表的数据可以选择存放在`ibdata1`（称为系统表空间）中，进入创建的`testdb`数据库，可以看到：

![](image_XQQJqu48ta.png)

不同于5.7版本，现在只有一个`__.ibd`（独立表空间）文件，不止是存放数据，把表结构也都放入该文件中。

> 储备知识：
>
> -   InnoDB其实是使用`页`作为基本单位来管理存储空间的，默认页的大小为16kb。
> -   对于InnoDB存储引擎来说，每个索引都对应着一颗B+树，该B+树的每个节点都是一个数据页，数据页之间不必要是物理连续的，因为数据页之间有`双向链表`来维护这些页的顺序
> -   InnoDB的聚簇索引的叶子节点存储了完整的用户记录，也就是所谓的索引即数据，数据即索引。

为了更好的管理这些页，InnoDB提出了一个`表空间`或者`文件空间`概念。这个表空间是一个抽象的概念，它可以对应文件系统上一个或多个真实文件（不同表空间对应的文件数量可能不同）。每一个表空间都可以被划分为很多`页`，我们的表数据就存放在某个表空间的某些页里。

表空间有几种个不同的类型：

#### 系统表空间

默认情况下，InnoDB会在数据目录下创建一个名为`ibdata1`，大小为12M的文件，这个文件就是对应的`系统表空间`，该文件是`自拓展文件`，当不够用时会自动增加文件大小。

如果想让系统表空间对应文件系统上多个实际文件，那么可以在mysql启动配置对应的文件路径以及它们的大小。

修改my.cnf配置文件：

```sql
[server]
innodb_data_file_path=data1:512M;data2:512M:autoextend
```

这样在mysql启动时就会创建这两个大小为512M大小的文件作为系统表空间，其中`autoextend`表明文件不够用时会自动拓展`data2`文件的大小。

需要注意的一点是：`在一个MYSQL服务器中，系统表空间只有一份。`从MYSQL5.5.7到5.6.6之间的各个版本中，我们**表中的数据都会被默认存储到这个系统表空间。**

#### 独立表空间

在mysql5.6.6之后的版本中，InnoDB并不会默认把各个表的数据存储到系统表空间中，而是`为每一个表创建一个独立表空间`，也就是创建了多少个表，就有多少个独立表空间。使用独立表空间来存储数据，会在该表所属的数据库对应的目录下创建一个表示该独立表空间的文件，文件名和表名相同，只不过添加了一个`.ibd`的拓展名而已。

#### 系统表空间与独立表空间的设置

可以指定使用`系统表空间`还是`独立表空间`来存储数据，这个功能由启动参数`innodb_file_per_table`控制。

```sql
[server]
innodb_file_per_table=0 #0代表使用系统表空间 1代表使用独立表空间
```

#### 证明在mysql8中idb文件中存放了表的结构信息

需要解析ibd文件。可以使用orancle提供的一个应用程序ibd2sdi。在mysql8中不需要下载此程序，自带。到存储ibd文件的目录下，执行下面的命令：

```sql
ibd2sdi --dump-file=student.txt student.ibd
```

### MyISAM存储引擎模式

#### 表结构

在该存储引擎模式下，会在数据目录下对应的数据库目录下创建一个专门用来描述表结构的文件：表名`.frm`

#### 表中数据和索引

索引都是`二级索引`，数据和索引是分开存放的。所以在文件系统中也是使用不同的文件来存储数据文件和索引文件，同时表数据都存放在对应的数据库子目录下。 例如`test`表使用MyISAM存储引擎的话，在数据库中对应的目录小爱就会创建这三个文件：

```sql
test.frm 存储表结构 5.7版本是这个文件  test.sdi 8版本是这个文件
test.MYD 存储数据
test.MYI 存储索引
```

# 用户与权限管理

## 用户管理

MYSQL用户可以分为`普通用户`和`root用户`。root用户是超级管理员，拥有所有权限，包括创建用户、删除用户、和修改用户密码等管理权限；普通用户只拥有被授予的各种权限。

Mysql提供了许多语句来管理用户账号，这些语句可以用来登陆和退出Mysql服务器、创建用户、删除用户、密码管理和权限管理等内容。

**MYSQL数据库安全性需要通过账户管理来保证。**

### 登陆MYSQL服务器

```bash
mysql -h hostname | hostIP -p port -u username -p
```

### 创建用户

使用CREATE USER语句来创建新用户，**必须拥有CREATE USER权限**。每增加一个用户，都会往MYSQL.user表中添加一条记录，但**新创建的用户没有任何权限**。添加的账户已经存在，会返回一个错误。

语法格式如下：

用户名由用户(User)和主机名(Host)构成

```sql
CREATE USER 用户名 [IDENTIFIED BY '密码'][,用户名[IDENTIFIED BY '密码']]
CREATE USER 'zhangsan'@'localhost' IDENTIFIED BY '123456';

```

### 修改用户

修改用户名：

```sql
UPDATE mysql.user set USER='li4' WHERE USER='wang5';

//在刷新一下 不然之前的没修改的账户还能登陆
FLUSH PRIVILEGES;
```

### 删除用户

使用`DROP USER`语句来删除`普通用户`，也可以直接在mysql.user表中删除用户。

```sql
DROP USER 用户名
DROP USER 'lisi'@'%';
```

### 设置当前用户密码

适用于root用户修改自己的密码，以及普通用户登陆后修改自己的密码。

推荐使用`ALTER USER`修改用户密码

旧的写法：

```sql
SET PASSWORD = PASSWORD('123456');
```

推荐写法：

使用ALTER命令来修改自身密码，如下命令修改当前登陆用户的密码。

```sql
#ALTER USER写法
ALTER USER USER(用户) IDENTIFIED BY ‘新密码’；

```

使用SET语句来修改当前用户密码

使用root用户登陆后，可以使用SET语句来修改密码，如下：

```sql
SET PASSWORD = ‘新密码’
```

### 修改其他用户的密码

root用户不仅可以修改自己的密码，还可以修改其他普通用户的密码。root登陆mysql服务器后，可以通过ALTER语句和SET语句来修改普通用户的密码。

-   使用ALTER语句来修改普通用户的密码
    ```sql
    ALTER USER user [IDENTIFIED BY ‘新密码’]
    例子如下：
    ALTER USER 'lisi'@'localhost' IDENTIFIED BY 'hello';
    ```
-   使用SET命令来修改普通用户密码
    ```sql
    SET PASSWORD FOR 'username'@'hostname'='新密码'
    ```

## 权限管理

查看mysql所有权限。

```sql
show privileges;
```

-   CREATE和DROP权限，可以创建新的数据库和表，或删除已有的数据库和表。
-   SELECT、ISNERT、UPDATE、DELETE权限允许在一个数据库现有的表上实施操作。
-   SELECT权限只有在它们真正从一个表中检索行时才被用到。
-   INDEX权限允许创建或删除索引，INDEX适用于已有的表。
-   ALTER权限可以使用ALTER TABLE来更改表的结构和重新命名表。
-   CREATE ROUTINE权限用来创建保存的程序（函数和程序）ALTER ROUTINE权限用来更改和删除保存的程序，EXECUTE权限用于执行保存的程序。
-   GRANT权限允许授权给其他用户，可用于数据库、表和保存的程序。
-   FILE权限使用户可以使用LOAD DATA INFILE 和SELECT ...INTO OUTFILE语句读或写服务器上的文件，任何被授权FILE权限的用户都能读或者写MYSQL服务器上的任何文件。

    ![](image_ZCOiPtq6fG.png)

    **授予权限原则**
    1.  只授予能满足需要的最小权限，防止用户干坏事。比如用户只是需要查询，那就只给select权限就可以了。
    2.  创建用户的时候限制用户的登录主机，一般是限制成指定Ip或者内网IP段。
    3.  为每个用户设置满足密码复杂度的密码。
    4.  定期清理不需要的用户，回收权限或者删除用户。
        **授予权限**
    给用户授予权限有两种方式，分别是通过把`角色赋予用户给用户授权`和`直接给用户授权`。

    授权命令：
    ```sql
    GRANT 权限1.....权限n ON 数据库名称.表名称 TO 用户名@用户地址 [IDENTIFIED BY '密码口令'];
    例子：
    给li4用户授予test库下所有表的CRUD权限
    GRANT SELECT,INSERT,DELETE,UPDATE ON TEST.* TO li4@localhost;
    授予joe用户对所有库所有表的全部权限，不包括grant权限。
    GRANT ALL PRIVILEGES ON *.* TO joe@'%';
    ```
    **查看权限**
    -   查看当前用户权限
        ```sql
        SHOW GRANTS;
        SHOW GRANTS FOR CURRENT_USER;
        SHOW GRANTS FOR CURRENT_USER();

        ```
    -   查看某用户的全局权限
        ```sql
        SHOW GRANTS FOR ‘user’@'主机地址';
        ```
    **收回权限**

    使用REVOKE语句来收回权限。

    收回权限命令
    ```sql
    REVOKE 权限1.....权限n ON 数据库名.表名 FROM 用户名@用户地址;
    ```

## 权限表

MYSQL通过`权限表来控制用户对数据库的访问`，权限表放在mysql数据库中。mysql数据库系统会根据这些权限表的内容为每个用户赋予相应的权限。这些权限表中最重要的是user表、db表。除此之外，还有table\_priv表、collumn\_priv表和proc\_priv表。在Mysql启动时，服务器将这些数据库表中权限信息的内容读人内存。

# 角色管理

角色是在8版本引入的新功能。在MYSQL中，角色是权限的集合，可以为角色添加或移除权限。用户可以被赋予角色，同时也被授予角色包含的权限。对角色进行操作需要较高的权限。并且像账户一样，角色可以拥有授予和撤销的权限。

## 角色创建

使用CREATE ROLE语句，创建角色

```sql
CREATE ROLE 'role_name'[@'host_name'] [,'role_name'[@'host_name']]

```

角色名称规则和用户类似，如果host\_name省略，默认为"%"，role\_name不可省略。

## 角色赋予权限

语法格式如下：

```sql
GRANT privileges ON db_name.table_name TO 'role_name'[@'host_name'];
```

privileges代表权限的名称，多个权限以逗号隔开。可使用SHOW语句查询权限名称。SHOW PRIVILEGES\G命令

## 查看角色权限

语法格式如下：

```sql
SHOW GRANTS FOR '角色名';
```

## 回收角色权限

语法格式如下：

```sql
REVOKE privileges ON db_name.table_name FROM ‘rolename’；
例如:撤销school_write角色插入、查询、更新在school数据库所有表的权限。
REVOKE INSERT,SELECT,UPDATE ON school.* FROM 'school_write'@'localhost';
```

## 删除角色

语法格式：

```sql
DROP ROLE role ,[role2]....
```

## 给用户赋予角色

语法格式：

```sql
GRANT role,... TO user [,user2,...];

```

`role`代表角色，`user`代表用户。可以将多个角色同时赋予多个用户。

## 激活角色

**MYSQL创建了角色后，默认都是没有激活的**，也就是不能用的。必须要**手动激活才能使用**。用户才能拥有该角色的对应的权限。

-   激活方式1

    使用set default role 命令激活角色
    ```sql
    SET DEFAULT role 角色 ALL TO 用户
    举例：为下面4个用户默认激活所有已拥有的角色：
    SET DEFAULT role 'manager'@'localhost' ALL TO 'dev'@'localhost','dev1'@'%',...
    ```
-   激活方式2

    将activate\_all\_roles\_on\_login设置为ON
    ```sql
    SET GLOBAL activate_all_roles_on_login = ON；
    ```
    意思是对所有角色永久激活。运行这条语句后，用户才真正拥有了赋予角色的所有权限。

## 撤销用户的角色

语法格式：

```sql
REVOKE role FROM user；
举例：撤销admin用户read角色
REVOKE read FROM 'admin'@'localhost';
```

# MYSQL逻辑架构

![](image_5m0nUvG1BX.png)

![](image_o4KBH6yr44.png)

## MYSQL Server结构可以分为三层结构：

### 第一层：连接层

（系统）客户端访问MYSQL服务器前，做的第一件事就是建立TCP连接。

经过三次握手建立连接后，MYSQL服务器对TCP传输过来的账号密码进行身份认证、权限获取。

一个系统只会和MYSQL服务器建立一次连接吗？只能有一个系统和MYSQL进行连接吗？

当然不是，多个系统都可以和MYSQL服务器进行连接，每个系统可以建立多个连接。为了解决创建与TCP频繁创建销毁带来的资源耗尽、性能下降问题。mysql服务器里有专门的`TCP连接池`限制连接数，采用`长连接模式`复用TCP连接。

### 第二层：服务层

第二层架构是核心服务层，很多核心功能放在这里。如SQL接口，并完成缓存查询，SQL的分析和优化及部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。

在该层，服务器会`解析查询`并创建相应的内部`解析树`，并对其完成相应的`优化`：如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作。

如果是SELECT语句，服务器还会`查询内部缓存`。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。

-   **SQL Interface：SQL接口**

    接收用户的SQL命令，并且返回用户需要查询的结果。

    Mysql支持DML、DDL、存储过程、视图、触发器、自定义函数等多种SQL语言接口
-   **Parser：解析器**

    在解析器中对SQL语句进行语法分析、语义分析。将SQL语句分解成数据结构，并且将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。

    在SQL命令传递到解析器的时候会被解析器验证和分析，并为其创建`语法树`，并根据数据字段丰富查询语法树，会验证该客户端是否具有执行该查询的权限。创建好语法树之后，MYSQL还会对SQL查询进行语法上的优化，进行查询重写。
-   **Optimizer：查询优化器**

    SQL语句在语法解析之后，插叙之前会使用查询优化器确定SQL语句的执行路径，生成一个执行计划。

    这个执行计划表明应该使用`哪些索引`进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。

    它使用`选取-投影-连接`策略进行查询。

    例如：
    ```sql
    select id，name from student where gender = '女'
    ```
    这个查询语句会先根据。WHERE条件进行`选取`，而不是将全部查询出来后再进行gender过滤。

    这个查询会先根据id和name来进行投影，而不是将属性全部取出来后再进行过滤，将这两个查询条件`连接`起来生成最终结果。
-   Caches & Buffer：查询缓存组件

    MYSQL内部维持着一些Caches & Buffer，比如QUery Cache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询结果，那么就没必要在进行查询解析，优化和执行的整个过程，直接将结果返回给用户。

    在8中已经删除。

### 第三层：引擎层

**存储引擎在MYSQL架构中是一个插件式的存储引擎**，可以根据业务的不同选择不同的存储引擎，也可以选择自己设置的存储引擎。

插件式存储引擎，真正负责了MYSQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，可以根据需求进行选取。

## **SQL执行流程**

mysql中SQL执行流程

![](image_nt2fyHnw5w.png)

## **存储引擎**

### InnoDB引擎：具备外建支持功能的事务存储引擎

-   InnoDB是mysql的默认事务性引擎，它被设计用来处理大量的短期事务。可以确保事务的完整提交和回滚。
-   除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎。
-   `InnoDB是为处理巨大数据量的最大性能设计`。
-   对比MyISAM存储引擎，`InnoDb写的处理效率差一些`，并且会占用更多的磁盘空间以保存数据和索引。
-   MyISAM只缓存索引，不缓存真实数据；InnoDB不仅仅缓存索引还要缓存真实数据，对`内存要求较高`，而且内存大小对性能有决定性的影响。

### MyISAM引擎：主要的非事务处理存储引擎

-   提供了大量的特性，包括全文索引、压缩、空间函数等，但`MyISAM不支持事务、行级锁、外建。`有一个毫无疑问的缺陷就是`崩溃后无法安全恢复`。
-   优势是访问的`速度快`，对事务完整性没有要求，主要以SELECT、INSERT为主。
-   针对数据统计有额外的常数存储。所以count( \*)查询效率高。
-   应用场景：只读应用或者以读为主的应用

# 索引

索引是帮助MYSQL高效获取数据的排好序的数据结构。

`索引是在存储引擎中实现的`，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的`最大索引数`和`最大索引长度`。所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。

**优点**

1.  提高查询效率
2.  通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。
3.  在实现数据的参考完整性方面，可以`加速表和表之间的连接`。换句话说，对于有依赖关系的父子表和父表联合查询时，可以提高查询速度。
4.  在使用分组和排序子句进行数据查询时，可以`显著减少查询中分组和排序时间`，降低CPU消耗。

**缺点**

1.  创建索引和维护索引要`耗费时间`，随着数据量的增加，所耗费的时间也会增加。
2.  索引需要占`据磁盘空间`，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，`存储在磁盘上`，如果有大量的索引，索引文件可能比数据文件更快达到最大文件尺寸。
3.  `降低更新表的速度`。当对表进行增加、更新和删除时，索引也需要动态维护，这样就降低了数据的维护速度。

## **InnoDB中索引的推演**

### **索引之前的查找**

先来看一个精确匹配的例子：

```sql
SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;
```

1.  在一个页中查找

    假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：
    -   以主键为搜索条件

        可以在页目录中使用 `二分法` 快速定位到对应的槽，然后再遍历该槽对用分组中的记录即可快速找到指定记录。
    -   以其他列作为搜索条件

        因为在数据页中并没有对非主键列简历所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从 `最小记录` 开始 `依次遍历单链表中的每条记录`， 然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。
2.  在很多页中查找

    在很多页中查找记录的活动可以分为两个步骤：
    1.  定位到记录所在的页
    2.  从所在的页内中查找相应的记录
    在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能 从第一个页沿着双向链表 一直往下找，在每一个页中根据我们上面的查找方式去查 找指定的记录。因为要遍历所有的数据页，所以这种方式显然是 超级耗时 的。如果一个表有一亿条记录呢？此时 索引 应运而生。

### **设计索引**

建一个表：

```sql
mysql> CREATE TABLE index_demo(
-> c1 INT,
-> c2 INT,
-> c3 CHAR(1),
-> PRIMARY KEY(c1)
-> ) ROW_FORMAT = Compact;
```

这个新建的 **index\_demo** 表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键， 这个表使用 **Compact** 行格式来实际存储记录的。这里我们简化了index\_demo表的行格式示意图：

![](image-20220616152453203_pNv7EMBnUt.png)

我们只在示意图里展示记录的这几个部分：

-   record\_type ：记录头信息的一项属性，表示记录的类型， 0 表示普通记录、 2 表示最小记 录、 3 表示最大记录、 1 暂时还没用过，下面讲。
-   mysql> CREATE TABLE index\_demo( -> c1 INT, -> c2 INT, -> c3 CHAR(1), -> PRIMARY KEY(c1) -> ) ROW\_FORMAT = Compact; next\_record ：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用 箭头来表明下一条记录是谁。
-   各个列的值 ：这里只记录在 index\_demo 表中的三个列，分别是 c1 、 c2 和 c3 。
-   其他信息 ：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。

将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：

![](image_KvplKb5zJD.png)

把一些记录放到页里的示意图就是：

![](image_v9TqEHbBVv.png)

### **一个简单的索引设计方案**

我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们 **想快速的定位到需要查找的记录在哪些数据页** 中该咋办？我们可以为快速定位记录所在的数据页而建立一个目录 ，建这个目录必须完成下边这些事：

**下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。**

假设：每个数据结构最多能存放3条记录（实际上一个数据页非常大，可以存放下好多记录）。

```sql
INSERT INTO index_demo VALUES(1, 4, 'u'), (3, 9, 'd'), (5, 3, 'y');
```

那么这些记录以及按照主键值的大小串联成一个单向链表了，如图所示：

![](image_uLGXNSb8P7.png)

从图中可以看出来， index\_demo 表中的3条记录都被插入到了编号为10的数据页中了。此时我们再来插入一条记录

```sql
INSERT INTO index_demo VALUES(4, 4, 'a');
```

因为 **页10** 最多只能放3条记录，所以我们不得不再分配一个新页：

![](image_YSjemuyizx.png)

注意：新分配的 **数据页编号可能并不是连续的**。它们只是通过维护者上一个页和下一个页的编号而建立了 **链表** 关系。另外，**页10**中用户记录最大的主键值是5，而**页28**中有一条记录的主键值是4，因为5>4，所以这就不符合下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值的要求，所以在插入主键值为4的记录的时候需要伴随着一次 **记录移动**，也就是把主键值为5的记录移动到页28中，然后再把主键值为4的记录插入到页10中，这个过程的示意图如下：

![](image_0hV66bgp9c.png)

这个过程表明了在对页中的记录进行增删改查操作的过程中，我们必须通过一些诸如 **记录移动** 的操作来始终保证这个状态一直成立：下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程称为 **页分裂**。

### **给所有的页建立一个目录项**

由于数据页的 **编号可能是不连续** 的，所以在向 index\_demo 表中插入许多条记录后，可能是这样的效果：

![](image_18HUsKwMMU.png)

我们需要给它们做个 **目录**，每个页对应一个目录项，每个目录项包括下边两个部分：

1）页的用户记录中最小的主键值，我们用 **key** 来表示。

2）页号，我们用 **page\_on** 表示。

![](image_4w5x2eH6ZZ.png)

以 页28 为例，它对应 目录项2 ，这个目录项中包含着该页的页号 28 以及该页中用户记录的最小主 键值 5 。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键 值快速查找某条记录的功能了。比如：查找主键值为 20 的记录，具体查找过程分两步：

1.  先从目录项中根据 二分法 快速确定出主键值为 20 的记录在 目录项3 中（因为 12 < 20 < 209 ），它对应的页是 页9 。
2.  再根据前边说的在页中查找记录的方式去 页9 中定位具体的记录。

至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为 **索引** 。

### **InnoDB中的索引方案**

**① 迭代1次：目录项纪录的页**

InnoDB怎么区分一条记录是普通的 **用户记录** 还是 **目录项记录** 呢？使用记录头信息里的 **record\_type** 属性，它的各自取值代表的意思如下：

-   0：普通的用户记录
-   1：目录项记录
-   2：最小记录
-   3：最大记录

我们把前边使用到的目录项放到数据页中的样子就是这样：

![](image_Vy5ABkmZjG.png)

从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调 **目录项记录** 和普通的 **用户记录** 的不同点：

-   **目录项记录** 的 record\_type 值是1，而 **普通用户记录** 的 record\_type 值是0。
-   目录项记录只有 **主键值和页的编号** 两个列，而普通的用户记录的列是用户自己定义的，可能包含 **很多列** ，另外还有InnoDB自己添加的隐藏列。
-   了解：记录头信息里还有一个叫 **min\_rec\_mask** 的属性，只有在存储 **目录项记录** 的页中的主键值最小的 **目录项记录** 的 **min\_rec\_mask** 值为 **1** ，其他别的记录的 **min\_rec\_mask** 值都是 **0** 。

**相同点**：两者用的是一样的数据页，都会为主键值生成 **Page Directory （页目录）**，从而在按照主键值进行查找时可以使用 **二分法** 来加快查询速度。

现在以查找主键为 20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：

1.  先到存储 目录项记录 的页，也就是页30中通过 二分法 快速定位到对应目录项，因为 12 < 20 < 209 ，所以定位到对应的记录所在的页就是页9。
2.  再到存储用户记录的页9中根据 二分法 快速定位到主键值为 20 的用户记录。

**② 迭代2次：多个目录项纪录的页**

![](image_2I0GRG8zhQ.png)

从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页：

-   为存储该用户记录而新生成了 页31 。
-   因为原先存储目录项记录的 页30的容量已满 （我们前边假设只能存储4条目录项记录），所以不得 不需要一个新的 页32 来存放 页31 对应的目录项。

现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为 20 的记录为例：

1.  确定 目录项记录页 我们现在的存储目录项记录的页有两个，即 页30 和 页32 ，又因为页30表示的目录项的主键值的 范围是 \[1, 320) ，页32表示的目录项的主键值不小于 320 ，所以主键值为 20 的记录对应的目 录项记录在 页30 中。
2.  通过目录项记录页 确定用户记录真实所在的页 。 在一个存储 目录项记录 的页中通过主键值定位一条目录项记录的方式说过了。
3.  在真实存储用户记录的页中定位到具体的记录。

**③ 迭代3次：目录项记录页的目录页**

如果我们表中的数据非常多则会`产生很多存储目录项记录的页`，那我们怎么根据主键值快速定位一个存储目录项记录的页呢？那就为这些存储目录项记录的页再生成一个`更高级的目录`，就像是一个多级目录一样，`大目录里嵌套小目录`，小目录里才是实际的数据，所以现在各个页的示意图就是这样子：

![](image_xbiEapWah3.png)

如图，我们生成了一个存储更高级目录项的 页33 ，这个页中的两条记录分别代表页30和页32，如果用 户记录的主键值在 \[1, 320) 之间，则到页30中查找更详细的目录项记录，如果主键值 不小于320 的 话，就到页32中查找更详细的目录项记录。

我们可以用下边这个图来描述它：

![](image_J-T1ZMDyev.png)

这个数据结构，它的名称是 B+树 。

**④ B+Tree**

一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第 0 层， 之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页 最多存放3条记录 ，存放目录项 记录的页 最多存放4条记录 。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录 的叶子节点代表的数据页可以存放 100条用户记录 ，所有存放目录项记录的内节点代表的数据页可以存 放 1000条目录项记录 ，那么：

-   如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录。
-   如果B+树有2层，最多能存放 1000×100=10,0000 条记录。
-   如果B+树有3层，最多能存放 1000×1000×100=1,0000,0000 条记录。
-   如果B+树有4层，最多能存放 1000×1000×1000×100=1000,0000,0000 条记录。相当多的记录！

你的表里能存放 **100000000000** 条记录吗？所以一般情况下，我们用到的 **B+树都不会超过4层** ，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的 **Page Directory** （页目录），所以在页面内也可以通过 **二分法** 实现快速 定位记录。

## 常见索引概念

索引按照物理实现方式，索引可以分为2种：`聚簇（聚集）`和`非聚簇（非聚集）索引`，`非聚簇（非聚集）索引`也称为`二级索引或者辅助索引`。

### 聚簇索引

`聚簇索引`并不是一种单独的索引类型，而是`一种数据存储方式`（所有的用户记录都存储在叶子节点），也就是所谓的`索引即数据，数据即索引`。

`聚簇`表示数据行和相邻的键值聚簇的存储在一起。

**特点：**

-   使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：
    -   `页内` 的记录是按照主键的大小顺序排成一个 `单向链表` 。
    -   各个存放 `用户记录的页` 也是根据页中用户记录的主键大小顺序排成一个 `双向链表` 。
    -   存放 `目录项记录的页` 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个 `双向链表` 。
-   B+树的 叶子节点 存储的是完整的用户记录。

    所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。

我们把具有这两种特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个`聚簇索引`的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使用INDEX 语句去创建， `InnDB` 存储引擎会 `自动` 的为我们创建聚簇索引。

**优点：**

-   `数据访问更快` ，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快
-   聚簇索引对于主键的 `排序查找` 和 `范围查找` 速度非常快
-   按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多 个数据块中提取数据，所以 `节省了大量的io操作` 。

**缺点：**

-   `插入速度严重依赖于插入顺序` ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个`自增的ID列为主键`
-   `更新主键的代价很高` ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义**主键为不可更新**
-   `二级索引访问需要两次索引查找` ，第一次找到主键值，第二次根据主键值找到行数据

### 二级索引（辅助索引、非聚簇索引）

如果我们想以别的列作为搜索条件该怎么办？肯定不能是从头到尾沿着链表依次遍历记录一遍。

答案：我们可以`多建几颗B+树`，不同的B+树中的数据采用不同的排列规则。比方说我们用`c2`列的大小作为数据页、页中记录的排序规则，再建一课B+树，效果如下图所示：

![](image_vhnqoa7hsY.png)

这个B+树与上边介绍的聚簇索引有几处不同：

![](image_W63MeNE5uw.png)

### **回表概念**

我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根 据c2列的值查找到完整的用户记录的话，仍然需要到 聚簇索引 中再查一遍，这个过程称为 回表 。也就 是根据c2列的值查询一条完整的用户记录需要使用到 2 棵B+树！

**问题**：为什么我们还需要一次 回表 操作呢？直接把完整的用户记录放到叶子节点不OK吗？

**回答**：

如果把完整的用户记录放到叶子结点是可以不用回表。但是`太占地方`了，相当于每建立一课B+树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。

因为这种按照`非主键列`建立的B+树需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为`二级索引`，或者辅助索引。由于使用的是c2列的大小作为B+树的排序规则，所以我们也称这个B+树为c2列简历的索引。

非聚簇索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个非聚簇索引。

![](image_nMyAysYjEh.png)

小结：聚簇索引与非聚簇索引的原理不同，在使用上也有一些区别：

1.  聚簇索引的`叶子节点`存储的就是我们的`数据记录`, 非聚簇索引的叶子节点存储的是`数据位置`。非聚簇索引不会影响数据表的物理存储顺序。
2.  一个表`只能有一个聚簇索引`，因为只能有一种排序存储的方式，但可以有`多个非聚簇索引`，也就是多个索引目录提供数据检索。
3.  使用聚簇索引的时候，数据的`查询效率高`，但如果对数据进行插入，删除，更新等操作，效率会比非聚簇索引低。

### 联合索引

我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按 照 c2和c3列 的大小进行排序，这个包含两层含义：

-   先把各个记录和页按照c2列进行排序。
-   在记录的c2列相同的情况下，采用c3列进行排序

为c2和c3建立的索引的示意图如下：

![](image_T7j9bTbPLt.png)

如图所示，我们需要注意以下几点：

-   每条目录项都有c2、c3、页号这三个部分组成，各条记录先按照c2列的值进行排序，如果记录的c2列相同，则按照c3列的值进行排序
-   B+树叶子节点处的用户记录由c2、c3和主键c1列组成

注意一点，以c2和c3列的大小为排序规则建立的B+树称为 联合索引 ，本质上也是一个二级索引。它的意 思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：

-   建立 联合索引 只会建立如上图一样的1棵B+树。
-   为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。

### InnoDB的B+树索引的注意事项

**根页面位置万年不动**

实际上B+树的形成过程是这样的：

-   每当为某个表创建一个B+树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个 `根结点` 页面。最开始表中没有数据的时候，每个B+树索引对应的 `根结点` 中即没有用户记录，也没有目录项记录。
-   随后向表中插入用户记录时，先把用户记录存储到这个`根节点` 中。
-   当根节点中的可用 `空间用完时` 继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如 `页a` 中，然后对这个新页进行 `页分裂` 的操作，得到另一个新页，比如`页b` 。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到 `页a` 或者 `页b` 中，而 `根节点` 便升级为存储目录项记录的页。

这个过程特别注意的是：一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建议一个索引，那么它的根节点的页号便会被记录到某个地方。然后凡是 `InnoDB` 存储引擎需要用到这个索引的时候，都会从哪个固定的地方取出根节点的页号，从而来访问这个索引。

**内节点中目录项记录的唯一性**

我们知道B+树索引的内节点中目录项记录的内容是 `索引列 + 页号` 的搭配，但是这个搭配对于二级索引来说有点不严谨。还拿 index\_demo 表为例，假设这个表中的数据是这样的：

![](image_aQcBasDP5S.png)

如果二级索引中目录项记录的内容只是 `索引列 + 页号` 的搭配的话，那么为 `c2` 列简历索引后的B+树应该长这样：

![](image_6NVEVx4w0a.png)

如果我们想新插入一行记录，其中 `c1` 、`c2` 、`c3` 的值分别是: `9`、`1`、`c`, 那么在修改这个为 c2 列建立的二级索引对应的 B+ 树时便碰到了个大问题：由于 `页3` 中存储的目录项记录是由 `c2列 + 页号` 的值构成的，`页3` 中的两条目录项记录对应的 c2 列的值都是1，而我们 `新插入的这条记录` 的 c2 列的值也是 `1`，那我们这条新插入的记录到底应该放在 `页4` 中，还是应该放在 `页5` 中？答案：对不起，懵了

为了让新插入记录找到自己在那个页面，我们需要**保证在B+树的同一层页节点的目录项记录除页号这个字段以外是唯一的**。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：

-   索引列的值
-   主键值
-   页号

也就是我们把`主键值`也添加到二级索引内节点中的目录项记录，这样就能保住 B+ 树每一层节点中各条目录项记录除页号这个字段外是唯一的，所以我们为c2建立二级索引后的示意图实际上应该是这样子的：

![](image_Ea-XzraBeJ.png)

这样我们再插入记录`(9, 1, 'c')` 时，由于 `页3` 中存储的目录项记录是由 `c2列 + 主键 + 页号` 的值构成的，可以先把新纪录的 `c2` 列的值和 `页3` 中各目录项记录的 `c2` 列的值作比较，如果 `c2` 列的值相同的话，可以接着比较主键值，因为B+树同一层中不同目录项记录的 `c2列 + 主键`的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新纪录应该被插入到 `页5` 中。

**一个页面最少存储 2 条记录**

一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度相当不错！这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录。那如果一个大的目录中只存放一个子目录是个啥效果呢？那就是目录层级非常非常多，而且最后的那个存放真实数据的目录中只存放一条数据。所以 **InnoDB 的一个数据页至少可以存放两条记录**。

## MyISAM中的索引方案

### MyISAM索引的原理

我们知道 `InnoDB中索引即数据`，也就是聚族索引的那棵B+树的叶子节点中已经把所有完整的用户记录都包含了，而MyISAM的索引方案虽然也使用树形结构，但是却将索引和数据分开存储：

-   将表中的记录`  按照记录的插入顾序  `单独存储在一个文件中，称之为 `数据文件`。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。由于在插入数据的时候并没有`刻意按照主键大小排序`，所以我们并不能在这些数据上使用二分法进行查找。
-   使用 MyISAM 存储引擎的表会把索引信息另外存储到一个称为`索引文件`的另一个文件中。MyISAM会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是`主键值 ＋数据记录地址`的组合。

![](image_1DEbCN2cS0.png)

这里设表一共有三列，假设我们以col1为主键，上图是一个MyISAM表的主索引(Primary key)示意。可以看出`MyISAM的索引文件仅仅保存数据记录的地址`。在MyISAM中，主键索引和二级素引(Secondary key）在结构上没有任何区别，只是主键索引要求key是唯一的，而二级素引的key可以重复。如果我们在Col2上建立一个二级索引，则此素引的结构如下图所示：

![](image_77C2YjMpp5.png)

同样也是一棵B+Tree， data域保存数据记录的地址。因此，MyISAM中索引检索的算法为：首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。

### MyISAM 与 InnoDB对比

**MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。小结两种引擎中索引的区别：**

-   在InnoDB存储引擎中，我们只需要根据主键值对 聚簇索引 进行一次查找就能找到对应的记录，而在 MyISAM 中却需要进行一次 回表 操作，意味着MyISAM中建立的索引相当于全部都是 二级索引 。
-   InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是 分离的 ，索引文件仅保存数 据记录的地址。
-   &#x20;InnoDB的非聚簇索引data域存储相应记录 主键的值 ，而MyISAM索引记录的是 地址 。换句话说， InnoDB的所有非聚簇索引都引用主键作为data域。
-   MyISAM的回表操作是十分 快速 的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通 过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。
-   &#x20;InnoDB要求表 必须有主键 （ MyISAM可以没有 ）。如果没有显式指定，则MySQL系统会自动选择一个 可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐 含字段作为主键，这个字段长度为6个字节，类型为长整型。

**小结：**

了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助。比如：
举例1：知道了InnoDB的索引实现后，就很容易明白 `为什么不建议使用过长的字段作为主键`，因为所有二级索引都引用主键索引，过长的主键索引会令二级索引变得过大。
举例2：用非单调的字段作为主键在innoDB中不是个好主意，因为InnoDB数据文件本身是一棵B+Tree，非单调的主键会造成在插入新记录时，数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用` 自增字段作为主键则是一个很好的选择`。

## 索引的代价

索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：

-   空间上的代价

    每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会 占用 16KB 的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。
-   时间上的代价

    每次对表中的数据进行 增、删、改 操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每 层节点都是按照索引列的值 从小到大的顺序排序 而组成了 双向链表 。不论是叶子节点中的记录，还 是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序 而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需 要额外的时间进行一些 记录移位 ， 页面分裂 、 页面回收 等操作来维护好节点和记录的排序。如果 我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。

> 一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。为了能建立又好又少的索引，我们得学学这些索引在哪些条件下起作用的。

# 索引创建与设计原则

## 索引的声明和使用

### 索引的分类

MysQL的索引包括普通索引、唯一性索引、全文素引、单列索引、多列索引和空间索引等。

-   从`功能逻辑`上说，索引主要有 4种，分别是普通索引、 唯一索引、主键索引、 全文索引。
-   按照`物理实现方式`，索引可以分为2种：聚族索引和非聚筷索引。
-   按照`作用宇段个数`进行划分，分成单列索引和联合索引。

#### 普通索引

在创建普通索引时，不附加任何限制条件，只是用于提高查询效率。这类索引可以创建在 `任何数据类型`中，其值是否唯一和非空，要由字段本身的完整性约束条件决定。建立索引以后，可以通过索引进行查询。例如，在表`student` 的字段`name` 上建立一个普通索引，查询记录时就可以根据该索引进行查询。

#### 唯一性索引

体用`UNTIQUE`参数 可以设置索引为唯一性索引，在创建唯一性索引，限制该索引的值必须是唯一的，但允许有空值。在一张数据表里`可以有多个`唯一索引。

#### 主键索引

主键索引就是一种`特殊的唯一性索引`，在唯一索引的基础上增加了不为空的约束，也就是NOT NULL + UNIQUE，一张表里最多`只能有一个主键`索引。

#### 单列索引

在表中的单个字段上创建索引。单列索引只根据该字段进行索引。单列索引可以是普通索引，也可以是唯一性索引，还可以是全文索引。只要保证该索引只对应一个字段即可。一个表可以`有多个`单列索引。

#### 多列（组合、联合）索引

多列索引是在表的`多个字段组合`上创建一个索引。该索引指向创建时对应的多个字段，可以通过这几个字段进行查询，但是只有查询条件中使用了这些字段中的第一个字段时才会被使用。

例如：在表中字段id、name、和gender上创建一个多列索引，只有查询条件中使用了字段id时索引才会被使用。使用组合索引时遵循`最左前缀集合`。

## 创建索引

### 创建表时创建索引

使用CREATE TABLE创建表时，除了可以定义列的数据类型外，还可以定义主键约束、外建约束或者唯一性约束，而无论创建哪种约束，在定义约束的同时相当于在指定列上创建了一个索引。

格式如下：

```sql
CREATE TABLE table_name [col_name data_type] [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name[length]) [ASC | DESC]]
```

-   UNIQUE、FULLTEXT和SPATIAL为可选参数，分别表示唯一索引、全文索引和空间索引。
-   INDEX和KEY为同义词，两者的作用相同，用来指定创建索引
-   index\_name指定索引的名称，为可选参数。如果不指定，那么MYSQL默认col\_name为索引名
-   col\_name为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择
-   length为可选参数，表示索引长度，只有字符串类型的字段才需要指定索引长度
-   ASC或DESC指定升序或者降序的索引值存储。

### 在已经存在的表上创建索引

#### 使用ALTER TABLE语句创建索引

语法格式如下：

```sql
ALTER TABLE table_name ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY]
[index_name] (col_name[length],....) [ASC | DESC]
```

#### 使用CREATE INDEX创建索引

语法格式如下：

```sql
CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name ON table_name (col_name[length],...) [ASC | DESC]
```

## 删除索引

MYSQL中删除索引使用`ALTER TABLE`或者`DROP INDEX`语句。

### **使用ALTER TABLE删除索引**

语法格式如下：

```sql
ALTER TABLE table_name DROP INDEX index_name
```

### 使用DROP INDEX删除索引

语法格式如下：

```sql
DROP INDEX index_name ON table_name
```

## MYSQL8新特性

### 支持降序索引

降序索引以降序存储键值。虽然在语法上，从MySQL 4版本开始就已经支持降序索引的语法了，但实际上DESC定义是被忽略的，直到MySQL 8.x版本才开始真正支持降序索引 (仅限于InnoDBc存储引擎)。

MySQL在8.0版本之前创建的仍然是升序索引，使用时进行反向扫描，这大大降低了数据库的效率。在某些场景下，降序索引意义重大。例如，如果一个查询，需要对多个列进行排序，且顺序要求不一致，那么使用降序索引将会避免数据库使用额外的文件排序操作，从而提高性能。

举例：分别在MySQL 5.7版本和MySQL 8.0版本中创建数据表ts1，结果如下：

```sql
CREATE TABLE ts1(a int,b int,index idx_a_b(a,b desc));
```

在MySQL 5.7版本中查看数据表ts1的结构，结果如下:

![](image_yWUTXBuROo.png)

从结果可以看出，索引仍然是默认的升序

在MySQL 8.0版本中查看数据表ts1的结构，结果如下：

![](image_cH0PIU4h0J.png)

从结果可以看出，索引已经是降序了。

### 隐藏索引

在MySQL 5.7版本及之前，只能通过显式的方式删除索引。此时，如果发现删除索引后出现错误，又只能通过显式创建索引的方式将删除的索引创建回来。如果数据表中的数据量非常大，或者数据表本身比较 大，这种操作就会消耗系统过多的资源，操作成本非常高。

从MySQL 8.x开始支持 `隐藏索引（invisible indexes）` ，只需要将待删除的索引设置为隐藏索引，使 `查询优化器不再使用这个索引`（即使使用force index（强制使用索引），优化器也不会使用该索引）， 确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。 `这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除。`

同时，如果你想验证某个索引删除之后的 `查询性能影响`，就可以暂时先隐藏该索引。

> 主键不能被设置为隐藏索引。当表中没有显式主键时，表中第一个唯一非空索引会成为隐式主键，也不能设置为隐藏索引。

#### 创建表时直接创建

在MySQL中创建隐藏索引通过SQL语句INVISIBLE来实现，其语法形式如下：

```sql
CREATE TABLE tablename(
propname1 type1[CONSTRAINT1],
propname2 type2[CONSTRAINT2],
……
propnamen typen,
INDEX [indexname](propname1 [(length)]) INVISIBLE
);
```

上述语句比普通索引多了一个`关键字INVISIBLE`，用来标记索引为`不可见索引`。

#### 在已经存在的表上创建

可以为已经存在的表设置隐藏索引，其语法形式如下：

```sql
CREATE INDEX indexname
ON tablename(propname[(length)]) INVISIBLE;
```

#### 通过ALTER TABLE语句创建

语法形式如下：

```sql
ALTER TABLE tablename
ADD INDEX indexname (propname [(length)]) INVISIBLE;
```

#### 切换索引可见状态

已存在的索引可通过如下语句切换可见状态：

```sql
ALTER TABLE tablename ALTER INDEX index_name INVISIBLE; #切换成隐藏索引
ALTER TABLE tablename ALTER INDEX index_name VISIBLE; #切换成非隐藏索引
```

如果将index\_cname索引切换成可见状态，通过explain查看执行计划，发现优化器选择了index\_cname索引。

> 注意 当索引被隐藏时，它的内容仍然是和正常索引一样实时更新的。如果一个索引需要长期被隐藏，那么可以将其删除，因为索引的存在会影响插入、更新和删除的性能。

#### 使隐藏索引对查询优化器可见

在MySQL 8.x版本中，为索引提供了一种新的测试方式，可以通过查询优化器的一个开关 (use\_invisible\_indexes) 来打开某个设置，使隐藏索引对查询优化器可见。如果use\_invisible\_indexes 设置为off (默认)，优化器会忽略隐藏索引。如果设置为on，即使隐藏索引不可见，优化器在生成执行计 划时仍会考虑使用隐藏索引。

在MySQL命令行执行如下命令查看查询优化器的开关设置。

```sql
mysql> select @@optimizer_switch \G
```

在输出的结果信息中找到如下属性配置。

```sql
use_invisible_indexes=off
```

此属性配置值为off，说明隐藏索引默认对查询优化器不可见。

使隐藏索引对查询优化器可见，需要在MySQL命令行执行如下命令：

```sql
mysql> set session optimizer_switch="use_invisible_indexes=on";
Query OK, 0 rows affected (0.00 sec)
```

## 索引的设计原则

为了使索引的使用效率更高，在创建索引时，必须考虑在哪些字段上创建索引和创建什么类型的索引。**索引设计不合理或者缺少索引都会对数据库和应用程序的性能造成障碍。** 高效的索引对于获得良好的性能非常重要。设计索引时，应该考虑相应准则。

### 数据准备

#### 第1步：创建数据库、创建表

```sql
CREATE DATABASE atguigudb1;
USE atguigudb1;
#1.创建学生表和课程表
CREATE TABLE `student_info` (
`id` INT(11) NOT NULL AUTO_INCREMENT,
`student_id` INT NOT NULL ,
`name` VARCHAR(20) DEFAULT NULL,
`course_id` INT NOT NULL ,
`class_id` INT(11) DEFAULT NULL,
`create_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
PRIMARY KEY (`id`)
) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;

CREATE TABLE `course` (
`id` INT(11) NOT NULL AUTO_INCREMENT,
`course_id` INT NOT NULL ,
`course_name` VARCHAR(40) DEFAULT NULL,
PRIMARY KEY (`id`)
) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
```

#### 第2步：创建模拟数据必需的存储函数

```sql
#函数1：创建随机产生字符串函数
DELIMITER //
CREATE FUNCTION rand_string(n INT)
  RETURNS VARCHAR(255) #该函数会返回一个字符串
BEGIN
  DECLARE chars_str VARCHAR(100) DEFAULT
'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';
  DECLARE return_str VARCHAR(255) DEFAULT '';
    DECLARE i INT DEFAULT 0;
    WHILE i < n DO
      SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));
      SET i = i + 1;
    END WHILE;
    RETURN return_str;
END //
DELIMITER ;
```

```sql
#函数2：创建随机数函数
DELIMITER //
CREATE FUNCTION rand_num (from_num INT ,to_num INT) RETURNS INT(11)
BEGIN
DECLARE i INT DEFAULT 0;
SET i = FLOOR(from_num +RAND()*(to_num - from_num+1)) ;
RETURN i;
END //
DELIMITER ;
```

创建函数，假如报错：

```sql
This function has none of DETERMINISTIC......
```

由于开启过慢查询日志bin-log, 我们就必须为我们的function指定一个参数。

主从复制，主机会将写操作记录在bin-log日志中。从机读取bin-log日志，执行语句来同步数据。如果使 用函数来操作数据，会导致从机和主键操作时间不一致。所以，默认情况下，mysql不开启创建函数设置。

-   查看mysql是否允许创建函数：
    ```sql
    show variables like 'log_bin_trust_function_creators';
    ```
-   命令开启：允许创建函数设置：
    ```sql
    set global log_bin_trust_function_creators=1; # 不加global只是当前窗口有效。
    ```
-   mysqld重启，上述参数又会消失。永久方法：
    -   windows下：my.ini\[mysqld]加上：
        ```sql
        og_bin_trust_function_creators=1
        ```
    -   linux下：/etc/my.cnf下my.cnf\[mysqld]加上：
        ```sql
        log_bin_trust_function_creators=1
        ```

#### 第3步：创建插入模拟数据的存储过程

```sql
# 存储过程1：创建插入课程表存储过程
DELIMITER //
CREATE PROCEDURE insert_course( max_num INT )
BEGIN
DECLARE i INT DEFAULT 0;
SET autocommit = 0; #设置手动提交事务
REPEAT #循环
SET i = i + 1; #赋值
INSERT INTO course (course_id, course_name ) VALUES
(rand_num(10000,10100),rand_string(6));
UNTIL i = max_num
END REPEAT;
COMMIT; #提交事务
END //
DELIMITER ;
```

```sql
# 存储过程2：创建插入学生信息表存储过程
DELIMITER //
CREATE PROCEDURE insert_stu( max_num INT )
BEGIN
DECLARE i INT DEFAULT 0;
SET autocommit = 0; #设置手动提交事务
REPEAT #循环
SET i = i + 1; #赋值
INSERT INTO student_info (course_id, class_id ,student_id ,NAME ) VALUES
(rand_num(10000,10100),rand_num(10000,10200),rand_num(1,200000),rand_string(6));
UNTIL i = max_num
END REPEAT;
COMMIT; #提交事务
END //
DELIMITER ;
```

#### 第4步：调用存储过程

```sql
CALL insert_course(100);
CALL insert_stu(1000000);

```

### 哪些情况适合创建索引

#### 字段的数值有唯一性的限制

索引本身可以起到约束的作用，比如唯一索引、主键索引都是可以起到唯一性约束的，因此在我们的数据表中，如果`某个字段是唯一性的`，就可以直接`创建唯一性索引`，或者`主键索引`。这样可以更快的通过该索引来确定某条记录。

> 业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba） 说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。

#### 频繁作为 WHERE 查询条件的字段

某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在 数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。

#### 经常 GROUP BY 和 ORDER BY 的列

索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要对分组或者排序的字段进行索引 。如果待排序的列有多个，那么可以在这些列上建立组合索引 。

#### UPDATE、DELETE 的 WHERE 条件列

对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。**如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。**

#### DISTINCT 字段需要创建索引

有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。

#### 多表 JOIN 连接操作时，创建索引注意事项

首先， `连接表的数量尽量不要超过 3 张` ，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增 长会非常快，严重影响查询的效率。

其次， `对 WHERE 条件创建索引` ，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下， 没有 WHERE 条件过滤是非常可怕的。

最后， `对用于连接的字段创建索引` ，并且该字段在多张表中的 类型必须一致 。比如 course\_id 在 student\_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。

举个例子，如果我们只对 student\_id 创建索引，执行 SQL 语句：

```sql
SELECT s.course_id, name, s.student_id, c.course_name
FROM student_info s JOIN course c
ON s.course_id = c.course_id
WHERE name = '462eed7ac6e791292a79';
```

运行结果（1 条数据，运行时间 0.189s ）

这里我们对 name 创建索引，再执行上面的 SQL 语句，运行时间为 0.002s 。

#### 使用列的类型小的创建索引

我们这里所说的 `类型大小`指的就是该类型表示的数据范围的大小。
我们在定义表结构的时候要显式的指定列的类型，以整数类型为例，有`TINYINT`、`MEDIUMINT`、`INT`、`BIGINT` 等，它们占用的存储空间依次递增，能表示的整数范围当然也是依次递增。如果我们想要对某个整数列建立索引的话，在表示的整数范围允许的情况下，尽量让索引列使用较小的类型，比如我们能使用 `INT` 就不要使用 `BIGINT`，能使用`MEDIUMINT` 就不要使用 `INT`。这是因为：

-   数据类型越小，在查询时进行的比较操作越快
-   数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以`放下更多的记录`，从而减少磁盘`I/O`带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率，

这个建议对于表的 `主键来说更加适用`，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的I/O。

#### 使用字符串前缀创建索引

假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们需要为这个字符串列建立索引时，那就意味着在对应的B+树中有这么两个问题：

-   B+树索引中的记录需要把该列的完整字符串存储起来，更费时。而且字符串越长，`在索引中占用的存储空间越大`。
-   如果B+树索引中索引列存储的字符串很长，那在做字符串 `比较时会占用更多的时间`。

我们可以通过截取宇段的前面一部分内容建立索引，这个就叫`前缀素引`。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值。既`节约空间`，又`减少了字符串的比较时间`，还大体能解决排序的问题。
例如，TEXT和BLOG类型的字段，进行全文检索会很浪费时间，如果只检索字段前面的若干字符，这样可以提高检索速度。

创建一张商户表，因为地址字段比较长，在地址字段上建立前缀索引

```sql
create table shop(address varchar(120) not null);
alter table shop add index(address(12));
```

问题是，截取多少呢？截取得多了，达不到节省索引存储空间的目的；截取得少了，重复内容太多，字 段的散列度(选择性)会降低。怎么计算不同的长度的选择性呢？

先看一下字段在全部数据中的选择度：

```sql
select count(distinct address) / count(*) from shop
```

通过不同长度去计算，与全表的选择性对比：

公式：

```sql
count(distinct left(列名, 索引长度))/count(*)
```

例如：

```sql
select count(distinct left(address,10)) / count(*) as sub10, -- 截取前10个字符的选择度
count(distinct left(address,15)) / count(*) as sub11, -- 截取前15个字符的选择度
count(distinct left(address,20)) / count(*) as sub12, -- 截取前20个字符的选择度
count(distinct left(address,25)) / count(*) as sub13 -- 截取前25个字符的选择度
from shop;
```

> 越接近于1越好，说明越有区分度

#### 引申另一个问题：索引列前缀对排序的影响

如果使用了索引列前缀，比方说前边只把address列的 `前12个字符` 放到了二级索引中，下边这个查询可能就有点尴尬了：

```sql
SELECT * FROM shopORDER BY address LIMIT 12;
```

因为二级索引中不包含完整的address列信息，所以无法对前12个字符相同，后边的字符不同的记录进行排序，也就是使用索引列前缀的方式 `无法支持使用索引排序` ，只能使用文件排序。

#### 拓展：Alibaba《Java开发手册》

【 强制 】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本 区分度决定索引长度。

说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90% 以上 ，可以使用 count(distinct left(列名, 索引长度))/count( \*)的区分度来确定。

#### 区分度高(散列性高)的列适合作为索引

`列的基数` 指的是某一列中不重复数据的个数，比方说某个列包含值 `2, 5, 8, 2, 5, 8, 2, 5, 8`，虽然有`9`条记录，但该列的基数却是3。也就是说**在记录行数一定的情况下，列的基数越大，该列中的值越分散；列的基数越小，该列中的值越集中。** 这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好为列的基数大的列简历索引，为基数太小的列的简历索引效果可能不好。

可以使用公式`select count(distinct a) / count(*) from t1` 计算区分度，越接近1越好，一般超过33%就算比较高效的索引了。

扩展：联合索引把区分度高(散列性高)的列放在前面。

#### 使用最频繁的列放到联合索引的左侧

这样也可以较少的建立一些索引。同时，由于"最左前缀原则"，可以增加联合索引的使用率。

#### 在多个字段都要创建索引的情况下，联合索引优于单值索引

#### 限制索引的数目

索引数目每张表上最好不超过6个。原因：

1.  每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。
2.  索引会影响INSERT、DELETE、UPDATE等语句性能，因为表中的数据更改的同时，索引也会进行调整和更新，会照成负担。
3.  优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会增加MYSQL优化器生成执行计划时间，降低查询性能。

### 哪些情况不适合创建索引

#### 在where中使用不到的字段，不要设置索引

WHERE条件 (包括 GROUP BY、ORDER BY) 里用不到的字段不需要创建索引，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的。举个

#### 数据量小的表最好不要使用索引

如果表记录太少，比如少于1000个，那么是不需要创建索引的。表记录太少，是否创建索引 `对查询效率的影响并不大`。甚至说，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。

#### 有大量重复数据的列上不要建立索引

在条件表达式中经常用到的不同值较多的列上建立索引，但字段中如果有大量重复数据，也不用创建索引。比如在学生表的"性别"字段上只有“男”与“女”两个不同值，因此无须建立索引。如果建立索引，不但不会提高查询效率，反而会`严重降低数据更新速度`。

结论：当数据重复度大，比如 高于 10% 的时候，也不需要对这个字段使用索引。

#### 避免对经常更新的表创建过多的索引

第一层含义：频繁更新的字段不一定要创建索引。因为更新数据的时候，也需要更新索引，如果索引太多，在更新索引的时候也会造成负担，从而影响效率。

第二层含义：避免对经常更新的表创建过多的索引，并且索引中的列尽可能少。此时，虽然提高了查询速度，同时却降低更新表的速度。

#### 不建议用无序的值作为索引

例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字 符串等。

#### 删除不再使用或者很少使用的索引

表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。

#### 不要定义夯余或重复的索引
