---
title: mysql
date: 2022-09-13 19:18:35
categories: 数据库
tags:
---
# MYSQL8新特性

## 窗口函数

窗口函数的作用类似于子查询中对数据进行分组，不同的是，分组操作会把分组的结果聚合成一条记录，而窗口函数是将结果置于每一条数据记录中。

## 窗口函数分类

可分为静态窗口函数和动态窗口函数。

-   静态窗口函数的窗口大小是固定的，不会因为记录的不同而不同
-   动态窗口函数的窗口大小会随着记录的不同而变化。

窗口函数总体上可以分为序号函数、分布函数、前后函数、首尾函数和其他函数，如下表：

![](image_naPtBYf8Gz.png)

## 语法结构

```sql
函数 OVER （[PARTTITION BY 字段名 ORDER BY 字段名 ASC｜DESC]）
```

或者是

```sql
函数 OVER 窗口名 ....WINDOW 窗口名 AS（[PARTTITION BY 字段名 ORDER BY 字段名 ASC｜DESC]）
```

-   OVER关键字指定函数窗口的范围
    -   如果省略后面括号的内容，则窗口会包含满足where条件的所有记录，窗口函数会基于所有满足WHERE条件的记录进行计算
    -   如果OVER关键字后面的括号不为空，则可以使用如下语法设置窗口。
-   窗口名：为窗口设置一个别名，用来标识窗口
-   PARTITION BY 子句：指定窗口函数按照哪些字段进行分组。分组后，窗口函数可以在每个分组分别执行。
-   ORDER BY 子句：指定窗口函数按照哪些字段进行排序。执行排序操作使窗口函数按照排序后的数据记录的顺序进行编号
-   FRAME 子句：为分区中的某个子集定义规则，可以用来作为滑动窗口使用。

## 分类讲解

### 序号函数：

1.  ROW\_NUMBER函数：

    ![](image_lLvr4-3LF9.png)
2.  RANK函数：

    ![](image_vastdTbnm0.png)
3.  DENSE\_RANK函数和RANK函数相反。

### 分布函数

1.  PERCENT\_RANK函数：

    此函数是等级值百分比函数，按照公式$(rank - 1) / (rows - 1)$来计算。

    其中rank的值为使用RANK函数产生的序号，rows值为当前窗口的总记录数。

    ![](image_7iIAJ0-Boa.png)
2.  CUME\_DIST函数:

    此函数主要用于查询小于或等于某个值的比例

    ![](image_TT0OB4ZKgE.png)

### 前后函数

1.  LAG(expr,n)函数：

    LAG(expr,n)函数返回当前行的前n行的expr值。

    ![](image_XZX5vJYxMF.png)
2.  LEAD(expr,n)函数：

    LEAD(expr,n)函数返回当前行的后n行的expr的值。

    ![](image_nXIhR2yQ5S.png)

### 首尾函数

1.  FIRST\_VALUE(expr)函数

    FIRST\_VALUE(expr)函数返回第一个expr的值。

    ![](image_ZKws6uAGXI.png)
2.  LAST\_VALUE(expr)函数：返回最后一个expr的值。

### 其他函数

1.  NTH\_VALUE(expr，n)函数：

    NTH\_VALUE(expr，n)函数返回第n个expr的值

    ![](image_72js3ghBW3.png)
2.  NTILE(n)函数：

    将分区中的有序数据分为n个桶，记录桶编号

    ![](image_YqqFsD-gJB.png)

# 字符集的相关操作

## 修改Mysql5.7字符集

在mysql8之前，默认字符集为`latin1`，utf8字符集指向的是`utf8mb3`，网站开发人员在数据库设计时往往会将编码修改为utf8。如果遗忘修改默认的编码，就会出现乱码的问题。从mysql8开始，数据库默认的编码就是utf8mb4，从而避免上述乱码的问题。

操作1：查看默认使用的字符集

```sql
show variables like 'character%';
或者
show variables like '%char%';
```

操作2：修改my.cnf配置文件，在配置文件中指定字符集

```sql
character_set_server=utf8
```

![](image_bhV525pXqp.png)

## 已有库已有表字符集的变更

mysql5.7版本中，以前创建的库，创建的表字符集还是latin1。

操作1：修改已有数据库的字符集

```sql
alter database 数据库名 character set 'utf8';
```

操作2：修改已有表的字符集

```sql
alter table 表名 convert to character set 'utf8';
```

## 各级别的字符集（底层原理说明）

mysql有4个级别的字符集和比较规则，分别是：

-   服务器级别
-   数据库级别
-   表级别
-   列级别

![](image_bhV525pXqp.png)

-   character\_set\_server：服务器级别的字符集
-   character\_set\_database：当前数据库的字符集
-   character\_set\_client：服务器解码请求时使用的字符集
-   character\_set\_connection：服务器处理请求时会把请求字符串从character\_set\_client转为character\_set\_connection
-   character\_set\_result：服务器向客户端返回数据时使用的字符集

设置server服务器级别的字符集后，相应的database字符集也会跟着变化。

-   当创建数据库时，不指定字符集，则使用database指定的字符集
-   当创建表时不指定字符集，则会根据所在库的字符集默认指定
-   当创建字段不指定字符集时，则会根据所在表的字符集默认指定

## 字符集与比较规则

### utf8与utf8mb4

utf8字符集表示一个字符需要使用1-4个字节，但是常使用的字符使用1-3个字节就可以表示了。而字符集表示一个字符所用到的最大字节长度，在某些方面会影响系统的存储和性能，所以定义了两个概念：

utf8mb3：阉割的utf8字符集，只使用1-3个字节表示字符。

utf8mb4：正宗的utf8字符集，使用1-4个字节表示字符。

查看mysql支持的字符集命令：show charset；

![](image_TJ24gtyOI7.png)

### 比较规则

Mysql一共支持41种字符集，其中的`Default collation`表示这些字符集中一种默认的比较规则，里面包含着该比较规则主要作用于哪种语言。如`utf8_polish_ci`表示以波兰语的规则比较，`utf8_general_ci`是一种通用的比较规则。

后缀表示该比较规则是否区分语言中的重音、大小写。具体如下：

![](image_1Mg_DVC-cB.png)

常用操作：

```sql
#查看GBK字符集的比较规则
show COLLATION LIKE 'gbk%';
#查看服务器的字符集和比较规则
show VARIABLES LIKE '%_server';
#查看数据库的字符集和比较规则
show VARIABLES DATABASE LIKE '%_database';
#查看具体数据库的字符集
show CREATE DATABASE 数据库名;
#修改数据库的字符集
ALTER DATABASE 数据库名 DEFAULT CHARACTER SET 'utf8' COLLATE 'utf8_general_ci';
#查看具体表的字符集
show CREATE TABLE 表名;
#修改表的字符集
ALTER TABLE 数据库名 DEFAULT CHARACTER SET 'utf8' COLLATE 'utf8_general_ci';

```

## 请求到相应过程中的编码

客户端请求mysql服务器时使用utf8编码，服务器使用character\_set\_client设置的字符集进行解码，在使用character\_set\_connection设置的字符集把character\_set\_client解码的内容编码到数据库中去查询，查询结果后在使用character\_set\_result设置的字符集编码返回给客户端，客户端在解码。

所以要求设置的编码必须要一致，可以添加如下配置到配置文件里可以指定character\_set\_client、character\_set\_connection、character\_set\_result三者的字符集。

```sql
[client]
default-character-set=utf8
```

## SQL大小写规范与sql\_mode的设置

### 查看大小写设置命令

```sql
show variables like 'lower_case_table_names';

```

![](image_PrFtsx8UW7.png)

lower\_case\_table\_names参数值的设置：

-   默认为0，大小写敏感
-   设置1，大小写不敏感。创建的表，数据库都是以小写的形式存在磁盘上，对于SQL语句都是转换为小写对表和数据库进行查找。
-   设置为2，创建的表和数据库依据语句上格式存放，凡是查找都是转换为小写进行。

### Linux下大小写规则设置

当想设置大小写不敏感时，要在`my.cnf`配置文件中\[mysqld]中加入`lower_case_table_names=1`，然后重启服务器。

-   但是要在重启数据库实例之前就需要将原来的数据库和表转换为小写，否则将找不到数据库名。
-   此参数适用于MYSQL5.7，在Mysql8下禁止在重新启动Mysql服务时将`lower_case_table_names`设置成不同于初始化mysql服务时设置的`lower_case_table_names`值。如果非要将mysql8是设置为大小写不敏感，具体步骤为：
    1.  停止mysql服务
    2.  删除数据目录，即删除/var/lib/mysql目录
    3.  在配置文件中添加`lower_case_table_names`=1
    4.  重新启动mysql服务

### SQL编写建议

![](image_MT0bejDC3j.png)

## sql\_mode的设置

sql\_mode会影响mysql支持的sql语法以及它执行的数据验证检查。通过设置mysql\_mode可以完成不同严格程度的数据校验，有效的保证数据准确性。

MYSQL服务器可以在不同的SQL模式下运行，并且可以针对不同的客户端以不同的方式应用这些模式，具体取决于sql\_mode系统变量的值。

mysql5.6和5.7默认的sql\_mode模式参数是不一样的：

-   5.6的mode默认值为空（即：NO\_ENGINE\_SUBSTITUTION），其实表示的是一个空值，相当于没有什么模式设置，可以理解为**宽松模式**。在这种设置下是可以允许一些非法操作的，比如允许一些非法数据的插入。
-   5.7的mode是STRICT\_TRANS\_TANLES，也就是**严格模式**，用于进行数据的严格校验，错误数据不能插入，报error错误，并且回滚事务。

### 宽松模式vs严格模式

-   宽松模式

    如果设置的是宽松模式，那么在插入数据时，即使给了一个错误的数据，也可能会被接受，并且不会报错。

    如：表中有一个name字段，类型为char（10），在插入数据时长度超过了10，例如‘1234567890abc’，超过了设定的长度，但不会报错，并且取前10个字符存上，也就是被存入了1234567890，abc忽略了。这就是宽松模式。
-   严格模式

    严格模式上面的情况出现就会报错。

### 模式的查看和设置

```sql
select @@session.sql_mode
select @@global.sql_mode
#或者
show variables like 'sql_mode';
#设置sql_mode模式
#session只在当前会话中生效，关闭当前会话就不生效了。
SET SESSION sql_mode = 想要的模式
#GLOBLA在当前服务生效，重启mysql服务后失效。
SET GLOBAL sql_mode = 想要的模式
#永久设置方式
在my.cnf配置文件中配置sql_mode
[mysqld]
sql_mode = 想要的模式,可以选择多个模式，多个模式使用，分割。
```

### 常用模式

![](image__G9svxLals.png)

# 数据库和文件系统的关系

像InnoDB、MyISAM这样的存储引擎都是把表存储在磁盘上的，操作系统用来管理磁盘的结构被称为文件系统，所以用专业一点的话来表示就是：像InnoDB、MyISAM这样的存储引擎都是把表存储在文件系统上的，`读取数据`时，`存储引擎`会把数据从文件系统中读取出来返回，`写入数据`时，存储引擎会把数据`写到文件系统去`。

## 表在文件系统中的表示

### InnoDB存储引擎模式

#### 在5.6.6版本之前

进入mysql数据存储目录`data`下

![](image_zFLAvRLKGv.png)

数据库表的数据都存放在`ibdata1`（称为系统表空间）中，进入创建的`testdb`数据库，可以看到：

![](image_MOB3JvcFmc.png)

有三个文件：

-   `db.opt`存放的是创建数据库时数据库的配置信息
-   `__.frm`文件存放的是创建表的结构
-   `__.ibd`文件存放的是表的数据（也称为独立表空间）5.6.6之前的版本应该是无。

#### 在5.7版本

![](image_zFLAvRLKGv.png)

数据库表的数据可以选择存放在`ibdata1`（称为系统表空间）中，进入创建的`testdb`数据库，可以看到：

![](image_MOB3JvcFmc.png)

有三个文件：

-   `db.opt`存放的是创建数据库时数据库的配置信息
-   `__.frm`文件存放的是创建表的结构
-   `__.ibd`文件存放的是表的数据（也称为独立表空间）。

#### 在8版本

![](image_zI0c41ME4U.png)

数据库表的数据可以选择存放在`ibdata1`（称为系统表空间）中，进入创建的`testdb`数据库，可以看到：

![](image_XQQJqu48ta.png)

不同于5.7版本，现在只有一个`__.ibd`（独立表空间）文件，不止是存放数据，把表结构也都放入该文件中。

> 储备知识：
>
> -   InnoDB其实是使用`页`作为基本单位来管理存储空间的，默认页的大小为16kb。
> -   对于InnoDB存储引擎来说，每个索引都对应着一颗B+树，该B+树的每个节点都是一个数据页，数据页之间不必要是物理连续的，因为数据页之间有`双向链表`来维护这些页的顺序
> -   InnoDB的聚簇索引的叶子节点存储了完整的用户记录，也就是所谓的索引即数据，数据即索引。

为了更好的管理这些页，InnoDB提出了一个`表空间`或者`文件空间`概念。这个表空间是一个抽象的概念，它可以对应文件系统上一个或多个真实文件（不同表空间对应的文件数量可能不同）。每一个表空间都可以被划分为很多`页`，我们的表数据就存放在某个表空间的某些页里。

表空间有几种个不同的类型：

#### 系统表空间

默认情况下，InnoDB会在数据目录下创建一个名为`ibdata1`，大小为12M的文件，这个文件就是对应的`系统表空间`，该文件是`自拓展文件`，当不够用时会自动增加文件大小。

如果想让系统表空间对应文件系统上多个实际文件，那么可以在mysql启动配置对应的文件路径以及它们的大小。

修改my.cnf配置文件：

```sql
[server]
innodb_data_file_path=data1:512M;data2:512M:autoextend
```

这样在mysql启动时就会创建这两个大小为512M大小的文件作为系统表空间，其中`autoextend`表明文件不够用时会自动拓展`data2`文件的大小。

需要注意的一点是：`在一个MYSQL服务器中，系统表空间只有一份。`从MYSQL5.5.7到5.6.6之间的各个版本中，我们**表中的数据都会被默认存储到这个系统表空间。**

#### 独立表空间

在mysql5.6.6之后的版本中，InnoDB并不会默认把各个表的数据存储到系统表空间中，而是`为每一个表创建一个独立表空间`，也就是创建了多少个表，就有多少个独立表空间。使用独立表空间来存储数据，会在该表所属的数据库对应的目录下创建一个表示该独立表空间的文件，文件名和表名相同，只不过添加了一个`.ibd`的拓展名而已。

#### 系统表空间与独立表空间的设置

可以指定使用`系统表空间`还是`独立表空间`来存储数据，这个功能由启动参数`innodb_file_per_table`控制。

```sql
[server]
innodb_file_per_table=0 #0代表使用系统表空间 1代表使用独立表空间
```

#### 证明在mysql8中idb文件中存放了表的结构信息

需要解析ibd文件。可以使用orancle提供的一个应用程序ibd2sdi。在mysql8中不需要下载此程序，自带。到存储ibd文件的目录下，执行下面的命令：

```sql
ibd2sdi --dump-file=student.txt student.ibd
```

### MyISAM存储引擎模式

#### 表结构

在该存储引擎模式下，会在数据目录下对应的数据库目录下创建一个专门用来描述表结构的文件：表名`.frm`

#### 表中数据和索引

索引都是`二级索引`，数据和索引是分开存放的。所以在文件系统中也是使用不同的文件来存储数据文件和索引文件，同时表数据都存放在对应的数据库子目录下。 例如`test`表使用MyISAM存储引擎的话，在数据库中对应的目录小爱就会创建这三个文件：

```sql
test.frm 存储表结构 5.7版本是这个文件  test.sdi 8版本是这个文件
test.MYD 存储数据
test.MYI 存储索引
```

# 用户与权限管理

## 用户管理

MYSQL用户可以分为`普通用户`和`root用户`。root用户是超级管理员，拥有所有权限，包括创建用户、删除用户、和修改用户密码等管理权限；普通用户只拥有被授予的各种权限。

Mysql提供了许多语句来管理用户账号，这些语句可以用来登陆和退出Mysql服务器、创建用户、删除用户、密码管理和权限管理等内容。

**MYSQL数据库安全性需要通过账户管理来保证。**

### 登陆MYSQL服务器

```bash
mysql -h hostname | hostIP -p port -u username -p
```

### 创建用户

使用CREATE USER语句来创建新用户，**必须拥有CREATE USER权限**。每增加一个用户，都会往MYSQL.user表中添加一条记录，但**新创建的用户没有任何权限**。添加的账户已经存在，会返回一个错误。

语法格式如下：

用户名由用户(User)和主机名(Host)构成

```sql
CREATE USER 用户名 [IDENTIFIED BY '密码'][,用户名[IDENTIFIED BY '密码']]
CREATE USER 'zhangsan'@'localhost' IDENTIFIED BY '123456';

```

### 修改用户

修改用户名：

```sql
UPDATE mysql.user set USER='li4' WHERE USER='wang5';

//在刷新一下 不然之前的没修改的账户还能登陆
FLUSH PRIVILEGES;
```

### 删除用户

使用`DROP USER`语句来删除`普通用户`，也可以直接在mysql.user表中删除用户。

```sql
DROP USER 用户名
DROP USER 'lisi'@'%';
```

### 设置当前用户密码

适用于root用户修改自己的密码，以及普通用户登陆后修改自己的密码。

推荐使用`ALTER USER`修改用户密码

旧的写法：

```sql
SET PASSWORD = PASSWORD('123456');
```

推荐写法：

使用ALTER命令来修改自身密码，如下命令修改当前登陆用户的密码。

```sql
#ALTER USER写法
ALTER USER USER(用户) IDENTIFIED BY ‘新密码’；

```

使用SET语句来修改当前用户密码

使用root用户登陆后，可以使用SET语句来修改密码，如下：

```sql
SET PASSWORD = ‘新密码’
```

### 修改其他用户的密码

root用户不仅可以修改自己的密码，还可以修改其他普通用户的密码。root登陆mysql服务器后，可以通过ALTER语句和SET语句来修改普通用户的密码。

-   使用ALTER语句来修改普通用户的密码
    ```sql
    ALTER USER user [IDENTIFIED BY ‘新密码’]
    例子如下：
    ALTER USER 'lisi'@'localhost' IDENTIFIED BY 'hello';
    ```
-   使用SET命令来修改普通用户密码
    ```sql
    SET PASSWORD FOR 'username'@'hostname'='新密码'
    ```

## 权限管理

查看mysql所有权限。

```sql
show privileges;
```

-   CREATE和DROP权限，可以创建新的数据库和表，或删除已有的数据库和表。
-   SELECT、ISNERT、UPDATE、DELETE权限允许在一个数据库现有的表上实施操作。
-   SELECT权限只有在它们真正从一个表中检索行时才被用到。
-   INDEX权限允许创建或删除索引，INDEX适用于已有的表。
-   ALTER权限可以使用ALTER TABLE来更改表的结构和重新命名表。
-   CREATE ROUTINE权限用来创建保存的程序（函数和程序）ALTER ROUTINE权限用来更改和删除保存的程序，EXECUTE权限用于执行保存的程序。
-   GRANT权限允许授权给其他用户，可用于数据库、表和保存的程序。
-   FILE权限使用户可以使用LOAD DATA INFILE 和SELECT ...INTO OUTFILE语句读或写服务器上的文件，任何被授权FILE权限的用户都能读或者写MYSQL服务器上的任何文件。

    ![](image_ZCOiPtq6fG.png)

    **授予权限原则**
    1.  只授予能满足需要的最小权限，防止用户干坏事。比如用户只是需要查询，那就只给select权限就可以了。
    2.  创建用户的时候限制用户的登录主机，一般是限制成指定Ip或者内网IP段。
    3.  为每个用户设置满足密码复杂度的密码。
    4.  定期清理不需要的用户，回收权限或者删除用户。
        **授予权限**
    给用户授予权限有两种方式，分别是通过把`角色赋予用户给用户授权`和`直接给用户授权`。

    授权命令：
    ```sql
    GRANT 权限1.....权限n ON 数据库名称.表名称 TO 用户名@用户地址 [IDENTIFIED BY '密码口令'];
    例子：
    给li4用户授予test库下所有表的CRUD权限
    GRANT SELECT,INSERT,DELETE,UPDATE ON TEST.* TO li4@localhost;
    授予joe用户对所有库所有表的全部权限，不包括grant权限。
    GRANT ALL PRIVILEGES ON *.* TO joe@'%';
    ```
    **查看权限**
    -   查看当前用户权限
        ```sql
        SHOW GRANTS;
        SHOW GRANTS FOR CURRENT_USER;
        SHOW GRANTS FOR CURRENT_USER();

        ```
    -   查看某用户的全局权限
        ```sql
        SHOW GRANTS FOR ‘user’@'主机地址';
        ```
    **收回权限**

    使用REVOKE语句来收回权限。

    收回权限命令
    ```sql
    REVOKE 权限1.....权限n ON 数据库名.表名 FROM 用户名@用户地址;
    ```

## 权限表

MYSQL通过`权限表来控制用户对数据库的访问`，权限表放在mysql数据库中。mysql数据库系统会根据这些权限表的内容为每个用户赋予相应的权限。这些权限表中最重要的是user表、db表。除此之外，还有table\_priv表、collumn\_priv表和proc\_priv表。在Mysql启动时，服务器将这些数据库表中权限信息的内容读人内存。

# 角色管理

角色是在8版本引入的新功能。在MYSQL中，角色是权限的集合，可以为角色添加或移除权限。用户可以被赋予角色，同时也被授予角色包含的权限。对角色进行操作需要较高的权限。并且像账户一样，角色可以拥有授予和撤销的权限。

## 角色创建

使用CREATE ROLE语句，创建角色

```sql
CREATE ROLE 'role_name'[@'host_name'] [,'role_name'[@'host_name']]

```

角色名称规则和用户类似，如果host\_name省略，默认为"%"，role\_name不可省略。

## 角色赋予权限

语法格式如下：

```sql
GRANT privileges ON db_name.table_name TO 'role_name'[@'host_name'];
```

privileges代表权限的名称，多个权限以逗号隔开。可使用SHOW语句查询权限名称。SHOW PRIVILEGES\G命令

## 查看角色权限

语法格式如下：

```sql
SHOW GRANTS FOR '角色名';
```

## 回收角色权限

语法格式如下：

```sql
REVOKE privileges ON db_name.table_name FROM ‘rolename’；
例如:撤销school_write角色插入、查询、更新在school数据库所有表的权限。
REVOKE INSERT,SELECT,UPDATE ON school.* FROM 'school_write'@'localhost';
```

## 删除角色

语法格式：

```sql
DROP ROLE role ,[role2]....
```

## 给用户赋予角色

语法格式：

```sql
GRANT role,... TO user [,user2,...];

```

`role`代表角色，`user`代表用户。可以将多个角色同时赋予多个用户。

## 激活角色

**MYSQL创建了角色后，默认都是没有激活的**，也就是不能用的。必须要**手动激活才能使用**。用户才能拥有该角色的对应的权限。

-   激活方式1

    使用set default role 命令激活角色
    ```sql
    SET DEFAULT role 角色 ALL TO 用户
    举例：为下面4个用户默认激活所有已拥有的角色：
    SET DEFAULT role 'manager'@'localhost' ALL TO 'dev'@'localhost','dev1'@'%',...
    ```
-   激活方式2

    将activate\_all\_roles\_on\_login设置为ON
    ```sql
    SET GLOBAL activate_all_roles_on_login = ON；
    ```
    意思是对所有角色永久激活。运行这条语句后，用户才真正拥有了赋予角色的所有权限。

## 撤销用户的角色

语法格式：

```sql
REVOKE role FROM user；
举例：撤销admin用户read角色
REVOKE read FROM 'admin'@'localhost';
```

# MYSQL逻辑架构

![](image_5m0nUvG1BX.png)

![](image_o4KBH6yr44.png)

## MYSQL Server结构可以分为三层结构：

### 第一层：连接层

（系统）客户端访问MYSQL服务器前，做的第一件事就是建立TCP连接。

经过三次握手建立连接后，MYSQL服务器对TCP传输过来的账号密码进行身份认证、权限获取。

一个系统只会和MYSQL服务器建立一次连接吗？只能有一个系统和MYSQL进行连接吗？

当然不是，多个系统都可以和MYSQL服务器进行连接，每个系统可以建立多个连接。为了解决创建与TCP频繁创建销毁带来的资源耗尽、性能下降问题。mysql服务器里有专门的`TCP连接池`限制连接数，采用`长连接模式`复用TCP连接。

### 第二层：服务层

第二层架构是核心服务层，很多核心功能放在这里。如SQL接口，并完成缓存查询，SQL的分析和优化及部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。

在该层，服务器会`解析查询`并创建相应的内部`解析树`，并对其完成相应的`优化`：如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作。

如果是SELECT语句，服务器还会`查询内部缓存`。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。

-   **SQL Interface：SQL接口**

    接收用户的SQL命令，并且返回用户需要查询的结果。

    Mysql支持DML、DDL、存储过程、视图、触发器、自定义函数等多种SQL语言接口
-   **Parser：解析器**

    在解析器中对SQL语句进行语法分析、语义分析。将SQL语句分解成数据结构，并且将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。

    在SQL命令传递到解析器的时候会被解析器验证和分析，并为其创建`语法树`，并根据数据字段丰富查询语法树，会验证该客户端是否具有执行该查询的权限。创建好语法树之后，MYSQL还会对SQL查询进行语法上的优化，进行查询重写。
-   **Optimizer：查询优化器**

    SQL语句在语法解析之后，插叙之前会使用查询优化器确定SQL语句的执行路径，生成一个执行计划。

    这个执行计划表明应该使用`哪些索引`进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。

    它使用`选取-投影-连接`策略进行查询。

    例如：
    ```sql
    select id，name from student where gender = '女'
    ```
    这个查询语句会先根据。WHERE条件进行`选取`，而不是将全部查询出来后再进行gender过滤。

    这个查询会先根据id和name来进行投影，而不是将属性全部取出来后再进行过滤，将这两个查询条件`连接`起来生成最终结果。
-   Caches & Buffer：查询缓存组件

    MYSQL内部维持着一些Caches & Buffer，比如QUery Cache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询结果，那么就没必要在进行查询解析，优化和执行的整个过程，直接将结果返回给用户。

    在8中已经删除。

### 第三层：引擎层

**存储引擎在MYSQL架构中是一个插件式的存储引擎**，可以根据业务的不同选择不同的存储引擎，也可以选择自己设置的存储引擎。

插件式存储引擎，真正负责了MYSQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，可以根据需求进行选取。

## **SQL执行流程**

mysql中SQL执行流程

![](image_nt2fyHnw5w.png)

## **存储引擎**

### InnoDB引擎：具备外建支持功能的事务存储引擎

-   InnoDB是mysql的默认事务性引擎，它被设计用来处理大量的短期事务。可以确保事务的完整提交和回滚。
-   除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎。
-   `InnoDB是为处理巨大数据量的最大性能设计`。
-   对比MyISAM存储引擎，`InnoDb写的处理效率差一些`，并且会占用更多的磁盘空间以保存数据和索引。
-   MyISAM只缓存索引，不缓存真实数据；InnoDB不仅仅缓存索引还要缓存真实数据，对`内存要求较高`，而且内存大小对性能有决定性的影响。

### MyISAM引擎：主要的非事务处理存储引擎

-   提供了大量的特性，包括全文索引、压缩、空间函数等，但`MyISAM不支持事务、行级锁、外建。`有一个毫无疑问的缺陷就是`崩溃后无法安全恢复`。
-   优势是访问的`速度快`，对事务完整性没有要求，主要以SELECT、INSERT为主。
-   针对数据统计有额外的常数存储。所以count( \*)查询效率高。
-   应用场景：只读应用或者以读为主的应用

# 索引

索引是帮助MYSQL高效获取数据的排好序的数据结构。

`索引是在存储引擎中实现的`，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的`最大索引数`和`最大索引长度`。所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。

**优点**

1.  提高查询效率
2.  通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。
3.  在实现数据的参考完整性方面，可以`加速表和表之间的连接`。换句话说，对于有依赖关系的父子表和父表联合查询时，可以提高查询速度。
4.  在使用分组和排序子句进行数据查询时，可以`显著减少查询中分组和排序时间`，降低CPU消耗。

**缺点**

1.  创建索引和维护索引要`耗费时间`，随着数据量的增加，所耗费的时间也会增加。
2.  索引需要占`据磁盘空间`，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，`存储在磁盘上`，如果有大量的索引，索引文件可能比数据文件更快达到最大文件尺寸。
3.  `降低更新表的速度`。当对表进行增加、更新和删除时，索引也需要动态维护，这样就降低了数据的维护速度。

## **InnoDB中索引的推演**

### **索引之前的查找**

先来看一个精确匹配的例子：

```sql
SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;
```

1.  在一个页中查找

    假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：
    -   以主键为搜索条件

        可以在页目录中使用 `二分法` 快速定位到对应的槽，然后再遍历该槽对用分组中的记录即可快速找到指定记录。
    -   以其他列作为搜索条件

        因为在数据页中并没有对非主键列简历所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从 `最小记录` 开始 `依次遍历单链表中的每条记录`， 然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。
2.  在很多页中查找

    在很多页中查找记录的活动可以分为两个步骤：
    1.  定位到记录所在的页
    2.  从所在的页内中查找相应的记录
    在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能 从第一个页沿着双向链表 一直往下找，在每一个页中根据我们上面的查找方式去查 找指定的记录。因为要遍历所有的数据页，所以这种方式显然是 超级耗时 的。如果一个表有一亿条记录呢？此时 索引 应运而生。

### **设计索引**

建一个表：

```sql
mysql> CREATE TABLE index_demo(
-> c1 INT,
-> c2 INT,
-> c3 CHAR(1),
-> PRIMARY KEY(c1)
-> ) ROW_FORMAT = Compact;
```

这个新建的 **index\_demo** 表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键， 这个表使用 **Compact** 行格式来实际存储记录的。这里我们简化了index\_demo表的行格式示意图：

![](image-20220616152453203_pNv7EMBnUt.png)

我们只在示意图里展示记录的这几个部分：

-   record\_type ：记录头信息的一项属性，表示记录的类型， 0 表示普通记录、 2 表示最小记 录、 3 表示最大记录、 1 暂时还没用过，下面讲。
-   mysql> CREATE TABLE index\_demo( -> c1 INT, -> c2 INT, -> c3 CHAR(1), -> PRIMARY KEY(c1) -> ) ROW\_FORMAT = Compact; next\_record ：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用 箭头来表明下一条记录是谁。
-   各个列的值 ：这里只记录在 index\_demo 表中的三个列，分别是 c1 、 c2 和 c3 。
-   其他信息 ：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。

将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：

![](image_KvplKb5zJD.png)

把一些记录放到页里的示意图就是：

![](image_v9TqEHbBVv.png)

### **一个简单的索引设计方案**

我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们 **想快速的定位到需要查找的记录在哪些数据页** 中该咋办？我们可以为快速定位记录所在的数据页而建立一个目录 ，建这个目录必须完成下边这些事：

**下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。**

假设：每个数据结构最多能存放3条记录（实际上一个数据页非常大，可以存放下好多记录）。

```sql
INSERT INTO index_demo VALUES(1, 4, 'u'), (3, 9, 'd'), (5, 3, 'y');
```

那么这些记录以及按照主键值的大小串联成一个单向链表了，如图所示：

![](image_uLGXNSb8P7.png)

从图中可以看出来， index\_demo 表中的3条记录都被插入到了编号为10的数据页中了。此时我们再来插入一条记录

```sql
INSERT INTO index_demo VALUES(4, 4, 'a');
```

因为 **页10** 最多只能放3条记录，所以我们不得不再分配一个新页：

![](image_YSjemuyizx.png)

注意：新分配的 **数据页编号可能并不是连续的**。它们只是通过维护者上一个页和下一个页的编号而建立了 **链表** 关系。另外，**页10**中用户记录最大的主键值是5，而**页28**中有一条记录的主键值是4，因为5>4，所以这就不符合下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值的要求，所以在插入主键值为4的记录的时候需要伴随着一次 **记录移动**，也就是把主键值为5的记录移动到页28中，然后再把主键值为4的记录插入到页10中，这个过程的示意图如下：

![](image_0hV66bgp9c.png)

这个过程表明了在对页中的记录进行增删改查操作的过程中，我们必须通过一些诸如 **记录移动** 的操作来始终保证这个状态一直成立：下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程称为 **页分裂**。

### **给所有的页建立一个目录项**

由于数据页的 **编号可能是不连续** 的，所以在向 index\_demo 表中插入许多条记录后，可能是这样的效果：

![](image_18HUsKwMMU.png)

我们需要给它们做个 **目录**，每个页对应一个目录项，每个目录项包括下边两个部分：

1）页的用户记录中最小的主键值，我们用 **key** 来表示。

2）页号，我们用 **page\_on** 表示。

![](image_4w5x2eH6ZZ.png)

以 页28 为例，它对应 目录项2 ，这个目录项中包含着该页的页号 28 以及该页中用户记录的最小主 键值 5 。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键 值快速查找某条记录的功能了。比如：查找主键值为 20 的记录，具体查找过程分两步：

1.  先从目录项中根据 二分法 快速确定出主键值为 20 的记录在 目录项3 中（因为 12 < 20 < 209 ），它对应的页是 页9 。
2.  再根据前边说的在页中查找记录的方式去 页9 中定位具体的记录。

至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为 **索引** 。

### **InnoDB中的索引方案**

**① 迭代1次：目录项纪录的页**

InnoDB怎么区分一条记录是普通的 **用户记录** 还是 **目录项记录** 呢？使用记录头信息里的 **record\_type** 属性，它的各自取值代表的意思如下：

-   0：普通的用户记录
-   1：目录项记录
-   2：最小记录
-   3：最大记录

我们把前边使用到的目录项放到数据页中的样子就是这样：

![](image_Vy5ABkmZjG.png)

从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调 **目录项记录** 和普通的 **用户记录** 的不同点：

-   **目录项记录** 的 record\_type 值是1，而 **普通用户记录** 的 record\_type 值是0。
-   目录项记录只有 **主键值和页的编号** 两个列，而普通的用户记录的列是用户自己定义的，可能包含 **很多列** ，另外还有InnoDB自己添加的隐藏列。
-   了解：记录头信息里还有一个叫 **min\_rec\_mask** 的属性，只有在存储 **目录项记录** 的页中的主键值最小的 **目录项记录** 的 **min\_rec\_mask** 值为 **1** ，其他别的记录的 **min\_rec\_mask** 值都是 **0** 。

**相同点**：两者用的是一样的数据页，都会为主键值生成 **Page Directory （页目录）**，从而在按照主键值进行查找时可以使用 **二分法** 来加快查询速度。

现在以查找主键为 20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：

1.  先到存储 目录项记录 的页，也就是页30中通过 二分法 快速定位到对应目录项，因为 12 < 20 < 209 ，所以定位到对应的记录所在的页就是页9。
2.  再到存储用户记录的页9中根据 二分法 快速定位到主键值为 20 的用户记录。

**② 迭代2次：多个目录项纪录的页**

![](image_2I0GRG8zhQ.png)

从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页：

-   为存储该用户记录而新生成了 页31 。
-   因为原先存储目录项记录的 页30的容量已满 （我们前边假设只能存储4条目录项记录），所以不得 不需要一个新的 页32 来存放 页31 对应的目录项。

现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为 20 的记录为例：

1.  确定 目录项记录页 我们现在的存储目录项记录的页有两个，即 页30 和 页32 ，又因为页30表示的目录项的主键值的 范围是 \[1, 320) ，页32表示的目录项的主键值不小于 320 ，所以主键值为 20 的记录对应的目 录项记录在 页30 中。
2.  通过目录项记录页 确定用户记录真实所在的页 。 在一个存储 目录项记录 的页中通过主键值定位一条目录项记录的方式说过了。
3.  在真实存储用户记录的页中定位到具体的记录。

**③ 迭代3次：目录项记录页的目录页**

如果我们表中的数据非常多则会`产生很多存储目录项记录的页`，那我们怎么根据主键值快速定位一个存储目录项记录的页呢？那就为这些存储目录项记录的页再生成一个`更高级的目录`，就像是一个多级目录一样，`大目录里嵌套小目录`，小目录里才是实际的数据，所以现在各个页的示意图就是这样子：

![](image_xbiEapWah3.png)

如图，我们生成了一个存储更高级目录项的 页33 ，这个页中的两条记录分别代表页30和页32，如果用 户记录的主键值在 \[1, 320) 之间，则到页30中查找更详细的目录项记录，如果主键值 不小于320 的 话，就到页32中查找更详细的目录项记录。

我们可以用下边这个图来描述它：

![](image_J-T1ZMDyev.png)

这个数据结构，它的名称是 B+树 。

**④ B+Tree**

一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第 0 层， 之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页 最多存放3条记录 ，存放目录项 记录的页 最多存放4条记录 。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录 的叶子节点代表的数据页可以存放 100条用户记录 ，所有存放目录项记录的内节点代表的数据页可以存 放 1000条目录项记录 ，那么：

-   如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录。
-   如果B+树有2层，最多能存放 1000×100=10,0000 条记录。
-   如果B+树有3层，最多能存放 1000×1000×100=1,0000,0000 条记录。
-   如果B+树有4层，最多能存放 1000×1000×1000×100=1000,0000,0000 条记录。相当多的记录！

你的表里能存放 **100000000000** 条记录吗？所以一般情况下，我们用到的 **B+树都不会超过4层** ，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的 **Page Directory** （页目录），所以在页面内也可以通过 **二分法** 实现快速 定位记录。

## 常见索引概念

索引按照物理实现方式，索引可以分为2种：`聚簇（聚集）`和`非聚簇（非聚集）索引`，`非聚簇（非聚集）索引`也称为`二级索引或者辅助索引`。

### 聚簇索引

`聚簇索引`并不是一种单独的索引类型，而是`一种数据存储方式`（所有的用户记录都存储在叶子节点），也就是所谓的`索引即数据，数据即索引`。

`聚簇`表示数据行和相邻的键值聚簇的存储在一起。

**特点：**

-   使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：
    -   `页内` 的记录是按照主键的大小顺序排成一个 `单向链表` 。
    -   各个存放 `用户记录的页` 也是根据页中用户记录的主键大小顺序排成一个 `双向链表` 。
    -   存放 `目录项记录的页` 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个 `双向链表` 。
-   B+树的 叶子节点 存储的是完整的用户记录。

    所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。

我们把具有这两种特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个`聚簇索引`的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使用INDEX 语句去创建， `InnDB` 存储引擎会 `自动` 的为我们创建聚簇索引。

**优点：**

-   `数据访问更快` ，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快
-   聚簇索引对于主键的 `排序查找` 和 `范围查找` 速度非常快
-   按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多 个数据块中提取数据，所以 `节省了大量的io操作` 。

**缺点：**

-   `插入速度严重依赖于插入顺序` ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个`自增的ID列为主键`
-   `更新主键的代价很高` ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义**主键为不可更新**
-   `二级索引访问需要两次索引查找` ，第一次找到主键值，第二次根据主键值找到行数据

### 二级索引（辅助索引、非聚簇索引）

如果我们想以别的列作为搜索条件该怎么办？肯定不能是从头到尾沿着链表依次遍历记录一遍。

答案：我们可以`多建几颗B+树`，不同的B+树中的数据采用不同的排列规则。比方说我们用`c2`列的大小作为数据页、页中记录的排序规则，再建一课B+树，效果如下图所示：

![](image_vhnqoa7hsY.png)

这个B+树与上边介绍的聚簇索引有几处不同：

![](image_W63MeNE5uw.png)

### **回表概念**

我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根 据c2列的值查找到完整的用户记录的话，仍然需要到 聚簇索引 中再查一遍，这个过程称为 回表 。也就 是根据c2列的值查询一条完整的用户记录需要使用到 2 棵B+树！

**问题**：为什么我们还需要一次 回表 操作呢？直接把完整的用户记录放到叶子节点不OK吗？

**回答**：

如果把完整的用户记录放到叶子结点是可以不用回表。但是`太占地方`了，相当于每建立一课B+树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。

因为这种按照`非主键列`建立的B+树需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为`二级索引`，或者辅助索引。由于使用的是c2列的大小作为B+树的排序规则，所以我们也称这个B+树为c2列简历的索引。

非聚簇索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个非聚簇索引。

![](image_nMyAysYjEh.png)

小结：聚簇索引与非聚簇索引的原理不同，在使用上也有一些区别：

1.  聚簇索引的`叶子节点`存储的就是我们的`数据记录`, 非聚簇索引的叶子节点存储的是`数据位置`。非聚簇索引不会影响数据表的物理存储顺序。
2.  一个表`只能有一个聚簇索引`，因为只能有一种排序存储的方式，但可以有`多个非聚簇索引`，也就是多个索引目录提供数据检索。
3.  使用聚簇索引的时候，数据的`查询效率高`，但如果对数据进行插入，删除，更新等操作，效率会比非聚簇索引低。

### 联合索引

我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按 照 c2和c3列 的大小进行排序，这个包含两层含义：

-   先把各个记录和页按照c2列进行排序。
-   在记录的c2列相同的情况下，采用c3列进行排序

为c2和c3建立的索引的示意图如下：

![](image_T7j9bTbPLt.png)

如图所示，我们需要注意以下几点：

-   每条目录项都有c2、c3、页号这三个部分组成，各条记录先按照c2列的值进行排序，如果记录的c2列相同，则按照c3列的值进行排序
-   B+树叶子节点处的用户记录由c2、c3和主键c1列组成

注意一点，以c2和c3列的大小为排序规则建立的B+树称为 联合索引 ，本质上也是一个二级索引。它的意 思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：

-   建立 联合索引 只会建立如上图一样的1棵B+树。
-   为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。

### InnoDB的B+树索引的注意事项

**根页面位置万年不动**

实际上B+树的形成过程是这样的：

-   每当为某个表创建一个B+树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个 `根结点` 页面。最开始表中没有数据的时候，每个B+树索引对应的 `根结点` 中即没有用户记录，也没有目录项记录。
-   随后向表中插入用户记录时，先把用户记录存储到这个`根节点` 中。
-   当根节点中的可用 `空间用完时` 继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如 `页a` 中，然后对这个新页进行 `页分裂` 的操作，得到另一个新页，比如`页b` 。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到 `页a` 或者 `页b` 中，而 `根节点` 便升级为存储目录项记录的页。

这个过程特别注意的是：一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建议一个索引，那么它的根节点的页号便会被记录到某个地方。然后凡是 `InnoDB` 存储引擎需要用到这个索引的时候，都会从哪个固定的地方取出根节点的页号，从而来访问这个索引。

**内节点中目录项记录的唯一性**

我们知道B+树索引的内节点中目录项记录的内容是 `索引列 + 页号` 的搭配，但是这个搭配对于二级索引来说有点不严谨。还拿 index\_demo 表为例，假设这个表中的数据是这样的：

![](image_aQcBasDP5S.png)

如果二级索引中目录项记录的内容只是 `索引列 + 页号` 的搭配的话，那么为 `c2` 列简历索引后的B+树应该长这样：

![](image_6NVEVx4w0a.png)

如果我们想新插入一行记录，其中 `c1` 、`c2` 、`c3` 的值分别是: `9`、`1`、`c`, 那么在修改这个为 c2 列建立的二级索引对应的 B+ 树时便碰到了个大问题：由于 `页3` 中存储的目录项记录是由 `c2列 + 页号` 的值构成的，`页3` 中的两条目录项记录对应的 c2 列的值都是1，而我们 `新插入的这条记录` 的 c2 列的值也是 `1`，那我们这条新插入的记录到底应该放在 `页4` 中，还是应该放在 `页5` 中？答案：对不起，懵了

为了让新插入记录找到自己在那个页面，我们需要**保证在B+树的同一层页节点的目录项记录除页号这个字段以外是唯一的**。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：

-   索引列的值
-   主键值
-   页号

也就是我们把`主键值`也添加到二级索引内节点中的目录项记录，这样就能保住 B+ 树每一层节点中各条目录项记录除页号这个字段外是唯一的，所以我们为c2建立二级索引后的示意图实际上应该是这样子的：

![](image_Ea-XzraBeJ.png)

这样我们再插入记录`(9, 1, 'c')` 时，由于 `页3` 中存储的目录项记录是由 `c2列 + 主键 + 页号` 的值构成的，可以先把新纪录的 `c2` 列的值和 `页3` 中各目录项记录的 `c2` 列的值作比较，如果 `c2` 列的值相同的话，可以接着比较主键值，因为B+树同一层中不同目录项记录的 `c2列 + 主键`的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新纪录应该被插入到 `页5` 中。

**一个页面最少存储 2 条记录**

一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度相当不错！这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录。那如果一个大的目录中只存放一个子目录是个啥效果呢？那就是目录层级非常非常多，而且最后的那个存放真实数据的目录中只存放一条数据。所以 **InnoDB 的一个数据页至少可以存放两条记录**。

## MyISAM中的索引方案

### MyISAM索引的原理

我们知道 `InnoDB中索引即数据`，也就是聚族索引的那棵B+树的叶子节点中已经把所有完整的用户记录都包含了，而MyISAM的索引方案虽然也使用树形结构，但是却将索引和数据分开存储：

-   将表中的记录`  按照记录的插入顾序  `单独存储在一个文件中，称之为 `数据文件`。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。由于在插入数据的时候并没有`刻意按照主键大小排序`，所以我们并不能在这些数据上使用二分法进行查找。
-   使用 MyISAM 存储引擎的表会把索引信息另外存储到一个称为`索引文件`的另一个文件中。MyISAM会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是`主键值 ＋数据记录地址`的组合。

![](image_1DEbCN2cS0.png)

这里设表一共有三列，假设我们以col1为主键，上图是一个MyISAM表的主索引(Primary key)示意。可以看出`MyISAM的索引文件仅仅保存数据记录的地址`。在MyISAM中，主键索引和二级素引(Secondary key）在结构上没有任何区别，只是主键索引要求key是唯一的，而二级素引的key可以重复。如果我们在Col2上建立一个二级索引，则此素引的结构如下图所示：

![](image_77C2YjMpp5.png)

同样也是一棵B+Tree， data域保存数据记录的地址。因此，MyISAM中索引检索的算法为：首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。

### MyISAM 与 InnoDB对比

**MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。小结两种引擎中索引的区别：**

-   在InnoDB存储引擎中，我们只需要根据主键值对 聚簇索引 进行一次查找就能找到对应的记录，而在 MyISAM 中却需要进行一次 回表 操作，意味着MyISAM中建立的索引相当于全部都是 二级索引 。
-   InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是 分离的 ，索引文件仅保存数 据记录的地址。
-   &#x20;InnoDB的非聚簇索引data域存储相应记录 主键的值 ，而MyISAM索引记录的是 地址 。换句话说， InnoDB的所有非聚簇索引都引用主键作为data域。
-   MyISAM的回表操作是十分 快速 的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通 过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。
-   &#x20;InnoDB要求表 必须有主键 （ MyISAM可以没有 ）。如果没有显式指定，则MySQL系统会自动选择一个 可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐 含字段作为主键，这个字段长度为6个字节，类型为长整型。

**小结：**

了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助。比如：
举例1：知道了InnoDB的索引实现后，就很容易明白 `为什么不建议使用过长的字段作为主键`，因为所有二级索引都引用主键索引，过长的主键索引会令二级索引变得过大。
举例2：用非单调的字段作为主键在innoDB中不是个好主意，因为InnoDB数据文件本身是一棵B+Tree，非单调的主键会造成在插入新记录时，数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用` 自增字段作为主键则是一个很好的选择`。

## 索引的代价

索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：

-   空间上的代价

    每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会 占用 16KB 的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。
-   时间上的代价

    每次对表中的数据进行 增、删、改 操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每 层节点都是按照索引列的值 从小到大的顺序排序 而组成了 双向链表 。不论是叶子节点中的记录，还 是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序 而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需 要额外的时间进行一些 记录移位 ， 页面分裂 、 页面回收 等操作来维护好节点和记录的排序。如果 我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。

> 一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。为了能建立又好又少的索引，我们得学学这些索引在哪些条件下起作用的。

# 索引创建与设计原则

## 索引的声明和使用

### 索引的分类

MysQL的索引包括普通索引、唯一性索引、全文素引、单列索引、多列索引和空间索引等。

-   从`功能逻辑`上说，索引主要有 4种，分别是普通索引、 唯一索引、主键索引、 全文索引。
-   按照`物理实现方式`，索引可以分为2种：聚族索引和非聚筷索引。
-   按照`作用宇段个数`进行划分，分成单列索引和联合索引。

#### 普通索引

在创建普通索引时，不附加任何限制条件，只是用于提高查询效率。这类索引可以创建在 `任何数据类型`中，其值是否唯一和非空，要由字段本身的完整性约束条件决定。建立索引以后，可以通过索引进行查询。例如，在表`student` 的字段`name` 上建立一个普通索引，查询记录时就可以根据该索引进行查询。

#### 唯一性索引

体用`UNTIQUE`参数 可以设置索引为唯一性索引，在创建唯一性索引，限制该索引的值必须是唯一的，但允许有空值。在一张数据表里`可以有多个`唯一索引。

#### 主键索引

主键索引就是一种`特殊的唯一性索引`，在唯一索引的基础上增加了不为空的约束，也就是NOT NULL + UNIQUE，一张表里最多`只能有一个主键`索引。

#### 单列索引

在表中的单个字段上创建索引。单列索引只根据该字段进行索引。单列索引可以是普通索引，也可以是唯一性索引，还可以是全文索引。只要保证该索引只对应一个字段即可。一个表可以`有多个`单列索引。

#### 多列（组合、联合）索引

多列索引是在表的`多个字段组合`上创建一个索引。该索引指向创建时对应的多个字段，可以通过这几个字段进行查询，但是只有查询条件中使用了这些字段中的第一个字段时才会被使用。

例如：在表中字段id、name、和gender上创建一个多列索引，只有查询条件中使用了字段id时索引才会被使用。使用组合索引时遵循`最左前缀集合`。

## 创建索引

### 创建表时创建索引

使用CREATE TABLE创建表时，除了可以定义列的数据类型外，还可以定义主键约束、外建约束或者唯一性约束，而无论创建哪种约束，在定义约束的同时相当于在指定列上创建了一个索引。

格式如下：

```sql
CREATE TABLE table_name [col_name data_type] [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name[length]) [ASC | DESC]]
```

-   UNIQUE、FULLTEXT和SPATIAL为可选参数，分别表示唯一索引、全文索引和空间索引。
-   INDEX和KEY为同义词，两者的作用相同，用来指定创建索引
-   index\_name指定索引的名称，为可选参数。如果不指定，那么MYSQL默认col\_name为索引名
-   col\_name为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择
-   length为可选参数，表示索引长度，只有字符串类型的字段才需要指定索引长度
-   ASC或DESC指定升序或者降序的索引值存储。

### 在已经存在的表上创建索引

#### 使用ALTER TABLE语句创建索引

语法格式如下：

```sql
ALTER TABLE table_name ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY]
[index_name] (col_name[length],....) [ASC | DESC]
```

#### 使用CREATE INDEX创建索引

语法格式如下：

```sql
CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name ON table_name (col_name[length],...) [ASC | DESC]
```

## 删除索引

MYSQL中删除索引使用`ALTER TABLE`或者`DROP INDEX`语句。

### **使用ALTER TABLE删除索引**

语法格式如下：

```sql
ALTER TABLE table_name DROP INDEX index_name
```

### 使用DROP INDEX删除索引

语法格式如下：

```sql
DROP INDEX index_name ON table_name
```

## MYSQL8新特性

### 支持降序索引

降序索引以降序存储键值。虽然在语法上，从MySQL 4版本开始就已经支持降序索引的语法了，但实际上DESC定义是被忽略的，直到MySQL 8.x版本才开始真正支持降序索引 (仅限于InnoDBc存储引擎)。

MySQL在8.0版本之前创建的仍然是升序索引，使用时进行反向扫描，这大大降低了数据库的效率。在某些场景下，降序索引意义重大。例如，如果一个查询，需要对多个列进行排序，且顺序要求不一致，那么使用降序索引将会避免数据库使用额外的文件排序操作，从而提高性能。

举例：分别在MySQL 5.7版本和MySQL 8.0版本中创建数据表ts1，结果如下：

```sql
CREATE TABLE ts1(a int,b int,index idx_a_b(a,b desc));
```

在MySQL 5.7版本中查看数据表ts1的结构，结果如下:

![](image_yWUTXBuROo.png)

从结果可以看出，索引仍然是默认的升序

在MySQL 8.0版本中查看数据表ts1的结构，结果如下：

![](image_cH0PIU4h0J.png)

从结果可以看出，索引已经是降序了。

### 隐藏索引

在MySQL 5.7版本及之前，只能通过显式的方式删除索引。此时，如果发现删除索引后出现错误，又只能通过显式创建索引的方式将删除的索引创建回来。如果数据表中的数据量非常大，或者数据表本身比较 大，这种操作就会消耗系统过多的资源，操作成本非常高。

从MySQL 8.x开始支持 `隐藏索引（invisible indexes）` ，只需要将待删除的索引设置为隐藏索引，使 `查询优化器不再使用这个索引`（即使使用force index（强制使用索引），优化器也不会使用该索引）， 确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。 `这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除。`

同时，如果你想验证某个索引删除之后的 `查询性能影响`，就可以暂时先隐藏该索引。

> 主键不能被设置为隐藏索引。当表中没有显式主键时，表中第一个唯一非空索引会成为隐式主键，也不能设置为隐藏索引。

#### 创建表时直接创建

在MySQL中创建隐藏索引通过SQL语句INVISIBLE来实现，其语法形式如下：

```sql
CREATE TABLE tablename(
propname1 type1[CONSTRAINT1],
propname2 type2[CONSTRAINT2],
……
propnamen typen,
INDEX [indexname](propname1 [(length)]) INVISIBLE
);
```

上述语句比普通索引多了一个`关键字INVISIBLE`，用来标记索引为`不可见索引`。

#### 在已经存在的表上创建

可以为已经存在的表设置隐藏索引，其语法形式如下：

```sql
CREATE INDEX indexname
ON tablename(propname[(length)]) INVISIBLE;
```

#### 通过ALTER TABLE语句创建

语法形式如下：

```sql
ALTER TABLE tablename
ADD INDEX indexname (propname [(length)]) INVISIBLE;
```

#### 切换索引可见状态

已存在的索引可通过如下语句切换可见状态：

```sql
ALTER TABLE tablename ALTER INDEX index_name INVISIBLE; #切换成隐藏索引
ALTER TABLE tablename ALTER INDEX index_name VISIBLE; #切换成非隐藏索引
```

如果将index\_cname索引切换成可见状态，通过explain查看执行计划，发现优化器选择了index\_cname索引。

> 注意 当索引被隐藏时，它的内容仍然是和正常索引一样实时更新的。如果一个索引需要长期被隐藏，那么可以将其删除，因为索引的存在会影响插入、更新和删除的性能。

#### 使隐藏索引对查询优化器可见

在MySQL 8.x版本中，为索引提供了一种新的测试方式，可以通过查询优化器的一个开关 (use\_invisible\_indexes) 来打开某个设置，使隐藏索引对查询优化器可见。如果use\_invisible\_indexes 设置为off (默认)，优化器会忽略隐藏索引。如果设置为on，即使隐藏索引不可见，优化器在生成执行计 划时仍会考虑使用隐藏索引。

在MySQL命令行执行如下命令查看查询优化器的开关设置。

```sql
mysql> select @@optimizer_switch \G
```

在输出的结果信息中找到如下属性配置。

```sql
use_invisible_indexes=off
```

此属性配置值为off，说明隐藏索引默认对查询优化器不可见。

使隐藏索引对查询优化器可见，需要在MySQL命令行执行如下命令：

```sql
mysql> set session optimizer_switch="use_invisible_indexes=on";
Query OK, 0 rows affected (0.00 sec)
```

## 索引的设计原则

为了使索引的使用效率更高，在创建索引时，必须考虑在哪些字段上创建索引和创建什么类型的索引。**索引设计不合理或者缺少索引都会对数据库和应用程序的性能造成障碍。** 高效的索引对于获得良好的性能非常重要。设计索引时，应该考虑相应准则。

### 数据准备

#### 第1步：创建数据库、创建表

```sql
CREATE DATABASE atguigudb1;
USE atguigudb1;
#1.创建学生表和课程表
CREATE TABLE `student_info` (
`id` INT(11) NOT NULL AUTO_INCREMENT,
`student_id` INT NOT NULL ,
`name` VARCHAR(20) DEFAULT NULL,
`course_id` INT NOT NULL ,
`class_id` INT(11) DEFAULT NULL,
`create_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
PRIMARY KEY (`id`)
) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;

CREATE TABLE `course` (
`id` INT(11) NOT NULL AUTO_INCREMENT,
`course_id` INT NOT NULL ,
`course_name` VARCHAR(40) DEFAULT NULL,
PRIMARY KEY (`id`)
) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
```

#### 第2步：创建模拟数据必需的存储函数

```sql
#函数1：创建随机产生字符串函数
DELIMITER //
CREATE FUNCTION rand_string(n INT)
  RETURNS VARCHAR(255) #该函数会返回一个字符串
BEGIN
  DECLARE chars_str VARCHAR(100) DEFAULT
'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';
  DECLARE return_str VARCHAR(255) DEFAULT '';
    DECLARE i INT DEFAULT 0;
    WHILE i < n DO
      SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));
      SET i = i + 1;
    END WHILE;
    RETURN return_str;
END //
DELIMITER ;
```

```sql
#函数2：创建随机数函数
DELIMITER //
CREATE FUNCTION rand_num (from_num INT ,to_num INT) RETURNS INT(11)
BEGIN
DECLARE i INT DEFAULT 0;
SET i = FLOOR(from_num +RAND()*(to_num - from_num+1)) ;
RETURN i;
END //
DELIMITER ;
```

创建函数，假如报错：

```sql
This function has none of DETERMINISTIC......
```

由于开启过慢查询日志bin-log, 我们就必须为我们的function指定一个参数。

主从复制，主机会将写操作记录在bin-log日志中。从机读取bin-log日志，执行语句来同步数据。如果使 用函数来操作数据，会导致从机和主键操作时间不一致。所以，默认情况下，mysql不开启创建函数设置。

-   查看mysql是否允许创建函数：
    ```sql
    show variables like 'log_bin_trust_function_creators';
    ```
-   命令开启：允许创建函数设置：
    ```sql
    set global log_bin_trust_function_creators=1; # 不加global只是当前窗口有效。
    ```
-   mysqld重启，上述参数又会消失。永久方法：
    -   windows下：my.ini\[mysqld]加上：
        ```sql
        og_bin_trust_function_creators=1
        ```
    -   linux下：/etc/my.cnf下my.cnf\[mysqld]加上：
        ```sql
        log_bin_trust_function_creators=1
        ```

#### 第3步：创建插入模拟数据的存储过程

```sql
# 存储过程1：创建插入课程表存储过程
DELIMITER //
CREATE PROCEDURE insert_course( max_num INT )
BEGIN
DECLARE i INT DEFAULT 0;
SET autocommit = 0; #设置手动提交事务
REPEAT #循环
SET i = i + 1; #赋值
INSERT INTO course (course_id, course_name ) VALUES
(rand_num(10000,10100),rand_string(6));
UNTIL i = max_num
END REPEAT;
COMMIT; #提交事务
END //
DELIMITER ;
```

```sql
# 存储过程2：创建插入学生信息表存储过程
DELIMITER //
CREATE PROCEDURE insert_stu( max_num INT )
BEGIN
DECLARE i INT DEFAULT 0;
SET autocommit = 0; #设置手动提交事务
REPEAT #循环
SET i = i + 1; #赋值
INSERT INTO student_info (course_id, class_id ,student_id ,NAME ) VALUES
(rand_num(10000,10100),rand_num(10000,10200),rand_num(1,200000),rand_string(6));
UNTIL i = max_num
END REPEAT;
COMMIT; #提交事务
END //
DELIMITER ;
```

#### 第4步：调用存储过程

```sql
CALL insert_course(100);
CALL insert_stu(1000000);

```

### 哪些情况适合创建索引

#### 字段的数值有唯一性的限制

索引本身可以起到约束的作用，比如唯一索引、主键索引都是可以起到唯一性约束的，因此在我们的数据表中，如果`某个字段是唯一性的`，就可以直接`创建唯一性索引`，或者`主键索引`。这样可以更快的通过该索引来确定某条记录。

> 业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba） 说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。

#### 频繁作为 WHERE 查询条件的字段

某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在 数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。

#### 经常 GROUP BY 和 ORDER BY 的列

索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要对分组或者排序的字段进行索引 。如果待排序的列有多个，那么可以在这些列上建立组合索引 。

#### UPDATE、DELETE 的 WHERE 条件列

对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。**如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。**

#### DISTINCT 字段需要创建索引

有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。

#### 多表 JOIN 连接操作时，创建索引注意事项

首先， `连接表的数量尽量不要超过 3 张` ，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增 长会非常快，严重影响查询的效率。

其次， `对 WHERE 条件创建索引` ，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下， 没有 WHERE 条件过滤是非常可怕的。

最后， `对用于连接的字段创建索引` ，并且该字段在多张表中的 类型必须一致 。比如 course\_id 在 student\_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。

举个例子，如果我们只对 student\_id 创建索引，执行 SQL 语句：

```sql
SELECT s.course_id, name, s.student_id, c.course_name
FROM student_info s JOIN course c
ON s.course_id = c.course_id
WHERE name = '462eed7ac6e791292a79';
```

运行结果（1 条数据，运行时间 0.189s ）

这里我们对 name 创建索引，再执行上面的 SQL 语句，运行时间为 0.002s 。

#### 使用列的类型小的创建索引

我们这里所说的 `类型大小`指的就是该类型表示的数据范围的大小。
我们在定义表结构的时候要显式的指定列的类型，以整数类型为例，有`TINYINT`、`MEDIUMINT`、`INT`、`BIGINT` 等，它们占用的存储空间依次递增，能表示的整数范围当然也是依次递增。如果我们想要对某个整数列建立索引的话，在表示的整数范围允许的情况下，尽量让索引列使用较小的类型，比如我们能使用 `INT` 就不要使用 `BIGINT`，能使用`MEDIUMINT` 就不要使用 `INT`。这是因为：

-   数据类型越小，在查询时进行的比较操作越快
-   数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以`放下更多的记录`，从而减少磁盘`I/O`带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率，

这个建议对于表的 `主键来说更加适用`，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的I/O。

#### 使用字符串前缀创建索引

假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们需要为这个字符串列建立索引时，那就意味着在对应的B+树中有这么两个问题：

-   B+树索引中的记录需要把该列的完整字符串存储起来，更费时。而且字符串越长，`在索引中占用的存储空间越大`。
-   如果B+树索引中索引列存储的字符串很长，那在做字符串 `比较时会占用更多的时间`。

我们可以通过截取宇段的前面一部分内容建立索引，这个就叫`前缀素引`。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值。既`节约空间`，又`减少了字符串的比较时间`，还大体能解决排序的问题。
例如，TEXT和BLOG类型的字段，进行全文检索会很浪费时间，如果只检索字段前面的若干字符，这样可以提高检索速度。

创建一张商户表，因为地址字段比较长，在地址字段上建立前缀索引

```sql
create table shop(address varchar(120) not null);
alter table shop add index(address(12));
```

问题是，截取多少呢？截取得多了，达不到节省索引存储空间的目的；截取得少了，重复内容太多，字 段的散列度(选择性)会降低。怎么计算不同的长度的选择性呢？

先看一下字段在全部数据中的选择度：

```sql
select count(distinct address) / count(*) from shop
```

通过不同长度去计算，与全表的选择性对比：

公式：

```sql
count(distinct left(列名, 索引长度))/count(*)
```

例如：

```sql
select count(distinct left(address,10)) / count(*) as sub10, -- 截取前10个字符的选择度
count(distinct left(address,15)) / count(*) as sub11, -- 截取前15个字符的选择度
count(distinct left(address,20)) / count(*) as sub12, -- 截取前20个字符的选择度
count(distinct left(address,25)) / count(*) as sub13 -- 截取前25个字符的选择度
from shop;
```

> 越接近于1越好，说明越有区分度

#### 引申另一个问题：索引列前缀对排序的影响

如果使用了索引列前缀，比方说前边只把address列的 `前12个字符` 放到了二级索引中，下边这个查询可能就有点尴尬了：

```sql
SELECT * FROM shopORDER BY address LIMIT 12;
```

因为二级索引中不包含完整的address列信息，所以无法对前12个字符相同，后边的字符不同的记录进行排序，也就是使用索引列前缀的方式 `无法支持使用索引排序` ，只能使用文件排序。

#### 拓展：Alibaba《Java开发手册》

【 强制 】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本 区分度决定索引长度。

说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90% 以上 ，可以使用 count(distinct left(列名, 索引长度))/count( \*)的区分度来确定。

#### 区分度高(散列性高)的列适合作为索引

`列的基数` 指的是某一列中不重复数据的个数，比方说某个列包含值 `2, 5, 8, 2, 5, 8, 2, 5, 8`，虽然有`9`条记录，但该列的基数却是3。也就是说**在记录行数一定的情况下，列的基数越大，该列中的值越分散；列的基数越小，该列中的值越集中。** 这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好为列的基数大的列简历索引，为基数太小的列的简历索引效果可能不好。

可以使用公式`select count(distinct a) / count(*) from t1` 计算区分度，越接近1越好，一般超过33%就算比较高效的索引了。

扩展：联合索引把区分度高(散列性高)的列放在前面。

#### 使用最频繁的列放到联合索引的左侧

这样也可以较少的建立一些索引。同时，由于"最左前缀原则"，可以增加联合索引的使用率。

#### 在多个字段都要创建索引的情况下，联合索引优于单值索引

#### 限制索引的数目

索引数目每张表上最好不超过6个。原因：

1.  每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。
2.  索引会影响INSERT、DELETE、UPDATE等语句性能，因为表中的数据更改的同时，索引也会进行调整和更新，会照成负担。
3.  优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会增加MYSQL优化器生成执行计划时间，降低查询性能。

### 哪些情况不适合创建索引

#### 在where中使用不到的字段，不要设置索引

WHERE条件 (包括 GROUP BY、ORDER BY) 里用不到的字段不需要创建索引，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的。举个

#### 数据量小的表最好不要使用索引

如果表记录太少，比如少于1000个，那么是不需要创建索引的。表记录太少，是否创建索引 `对查询效率的影响并不大`。甚至说，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。

#### 有大量重复数据的列上不要建立索引

在条件表达式中经常用到的不同值较多的列上建立索引，但字段中如果有大量重复数据，也不用创建索引。比如在学生表的"性别"字段上只有“男”与“女”两个不同值，因此无须建立索引。如果建立索引，不但不会提高查询效率，反而会`严重降低数据更新速度`。

结论：当数据重复度大，比如 高于 10% 的时候，也不需要对这个字段使用索引。

#### 避免对经常更新的表创建过多的索引

第一层含义：频繁更新的字段不一定要创建索引。因为更新数据的时候，也需要更新索引，如果索引太多，在更新索引的时候也会造成负担，从而影响效率。

第二层含义：避免对经常更新的表创建过多的索引，并且索引中的列尽可能少。此时，虽然提高了查询速度，同时却降低更新表的速度。

#### 不建议用无序的值作为索引

例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字 符串等。

#### 删除不再使用或者很少使用的索引

表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。

#### 不要定义夯余或重复的索引

# 性能分析工具的使用

## 数据库服务器的优化步骤

当我们遇到数据库调优问题的时候，该如何思考呢？这里把思考的流程整理成下面这张图。

整个流程划分成了 `观察（Show status）` 和 `行动（Action）` 两个部分。字母 S 的部分代表观察（会使 用相应的分析工具），字母 A 代表的部分是行动（对应分析可以采取的行动）。

![](image_aqO5XMie5E.png)

![](image_mkkVZQiHAC.png)

我们可以通过观察了解数据库整体的运行状态，通过性能分析工具可以让我们了解执行慢的SQL都有哪些，查看具体的SQL执行计划，甚至是SQL执行中的每一步的成本代价，这样才能定位问题所在，找到了问题，再采取相应的行动。

## 查看系统性能参数

在MySQL中，可以使用 `SHOW STATUS` 语句查询一些MySQL数据库服务器的`性能参数、执行频率`。

SHOW STATUS语句语法如下：

```sql
SHOW [GLOBAL|SESSION] STATUS LIKE '参数';
```

一些常用的性能参数如下：

-   Connections：连接MySQL服务器的次数。
-   Uptime：MySQL服务器的上线时间。
-   Slow\_queries：慢查询的次数。
-   Innodb\_rows\_read：Select查询返回的行数
-   Innodb\_rows\_inserted：执行INSERT操作插入的行数
-   Innodb\_rows\_updated：执行UPDATE操作更新的 行数
-   Innodb\_rows\_deleted：执行DELETE操作删除的行数
-   Com\_select：查询操作的次数。
-   Com\_insert：插入操作的次数。对于批量插入的 INSERT 操作，只累加一次。
-   Com\_update：更新操作 的次数。
-   Com\_delete：删除操作的次数。

若查询MySQL服务器的慢查询次数，则可以执行如下语句:

```sql
SHOW STATUS LIKE 'Slow_queries';
```

慢查询次数参数可以结合慢查询日志找出慢查询语句，然后针对慢查询语句进行`表结构优化`或者`查询语句优化`。

再比如，如下的指令可以查看相关的指令情况：

```sql
SHOW STATUS LIKE 'Innodb_rows_%';
```

## 统计SQL的查询成本：last\_query\_cost

一条SQL查询语句在执行前需要查询执行计划，如果存在多种执行计划的话，MySQL会计算每个执行计划所需要的成本，从中选择`成本最小`的一个作为最终执行的执行计划。

如果我们想要查看某条SQL语句的查询成本，可以在执行完这条SQL语句之后，通过查看当前会话中的`last_query_cost`变量值来得到当前查询的成本。它通常也是我们`评价一个查询的执行效率`的一个常用指标。这个查询成本对应的是`SQL 语句所需要读取的读页的数量`。

以student\_info 表为例：

```sql
CREATE TABLE `student_info` (
    `id` INT(11) NOT NULL AUTO_INCREMENT,
    `student_id` INT NOT NULL ,
    `name` VARCHAR(20) DEFAULT NULL,
    `course_id` INT NOT NULL ,
    `class_id` INT(11) DEFAULT NULL,
    `create_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (`id`)
) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
```

如果我们想要查询 id=900001 的记录，然后看下查询成本，我们可以直接在聚簇索引上进行查找：

```sql
SELECT student_id, class_id, NAME, create_time FROM student_info WHERE id = 900001;
```

运行结果（1 条记录，运行时间为 0.042s ）

然后再看下查询优化器的成本，实际上我们只需要检索一个页即可：

```sql
mysql> SHOW STATUS LIKE 'last_query_cost';
+-----------------+----------+
| Variable_name   |   Value  |
+-----------------+----------+
| Last_query_cost | 1.000000 |
+-----------------+----------+
```

如果我们想要查询 id 在 900001 到 9000100 之间的学生记录呢？

```sql
SELECT student_id, class_id, NAME, create_time FROM student_info WHERE id BETWEEN 900001 AND 900100;
```

运行结果（100 条记录，运行时间为 0.046s ）：

然后再看下查询优化器的成本，这时我们大概需要进行 20 个页的查询。

```sql
mysql> SHOW STATUS LIKE 'last_query_cost';
+-----------------+-----------+
| Variable_name   |   Value   |
+-----------------+-----------+
| Last_query_cost | 21.134453 |
+-----------------+-----------+
```

你能看到页的数量是刚才的 20 倍，但是查询的效率并没有明显的变化，实际上这两个 SQL 查询的时间 基本上一样，就是因为采用了顺序读取的方式将页面一次性加载到缓冲池中，然后再进行查找。虽然 页 数量（last\_query\_cost）增加了不少 ，但是通过缓冲池的机制，并 没有增加多少查询时间 。

**使用场景：** 它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。

SQL查询是一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论：

1.  `位置决定效率`。如果页就在数据库 `缓冲池` 中，那么效率是最高的，否则还需要从 `内存` 或者 `磁盘` 中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。
2.  `批量决定效率`。如果我们从磁盘中对单一页进行随机读，那么效率是很低的(差不多10ms)，而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。

所以说，遇到I/O并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是进程使用的数据就要尽量放到`缓冲池`中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。

## 定位执行慢的SQL：慢查询日志

MysQL的慢查询日志，用来记录在MySQL中 `响应时间超过阀值` 的语句，具体指运行时间超过 `long_query_time` 值的SQL，则会被记录到慢查询日志中。long\_query\_time的默认值为 `10`，意思是运行10秒以上 （不含10秒）的语句，认为是超出了我们的最大忍耐时间值。
它的主要作用是，帮助我们发现那些执行时间特别长的SQL 查询，并且有针对性地进行优化，从而提高系统的整体效率。当我们的数据库服务器发生阻塞、运行变慢的时候，检查一下慢查询日志，找到那些慢查询，对解決问题很有帮助。比如一条sql执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒的sql，结合explain进行全面分析。
默认情况下，MySQL数据库` 没有开启慢查询日志` ，需要我们手动来设置这个参数。`如果不是调优需要的话，一般不建议启动该参数`，因为开启慢查询日志会或多或少带来一定的性能影响。
慢查询日志支持将日志记录写入文件。

### 开启慢查询日志参数

#### 开启 slow\_query\_log

在使用前，我们需要先查下慢查询是否已经开启，使用下面这条命令即可：

```sql
mysql > show variables like '%slow_query_log';
```

![](image_u0KjnWO-Mn.png)

我们可以看到 `slow_query_log=OFF`，我们可以把慢查询日志打开，注意设置变量值的时候需要使用 global，否则会报错：

```sql
mysql > set global slow_query_log='ON';
```

然后我们再来查看下慢查询日志是否开启，以及慢查询日志文件的位置：

![](image_VijH4WT4FO.png)

#### 修改 long\_query\_time 阈值

接下来我们来看下慢查询的时间阈值设置，使用如下命令：

```sql
mysql > show variables like '%long_query_time%';
```

![](image_SQG_k2X4AJ.png)

这里如果我们想把时间缩短，比如设置为 1 秒，可以这样设置：

```sql
#测试发现：设置global的方式对当前session的long_query_time失效。对新连接的客户端有效。所以可以一并
执行下述语句
mysql > set global long_query_time = 1;
mysql> show global variables like '%long_query_time%';

mysql> set long_query_time=1;
mysql> show variables like '%long_query_time%';
```

![](image_MDl3s1w8gb.png)

**补充：配置文件中一并设置参数**

如下的方式相较于前面的命令行方式，可以看做是永久设置的方式。

修改 `my.cnf` 文件，\[mysqld] 下增加或修改参数 `long_query_time、slow_query_log` 和 `slow_query_log_file` 后，然后重启 MySQL 服务器。

```sql
[mysqld]
slow_query_log=ON  # 开启慢查询日志开关
slow_query_log_file=/var/lib/mysql/atguigu-low.log  # 慢查询日志的目录和文件名信息
long_query_time=3  # 设置慢查询的阈值为3秒，超出此设定值的SQL即被记录到慢查询日志
log_output=FILE
```

如果不指定存储路径，慢查询日志默认存储到MySQL数据库的数据文件夹下。如果不指定文件名，默认文件名为hostname\_slow\.log。

### 查看慢查询数目

查询当前系统中有多少条慢查询记录

```sql
SHOW GLOBAL STATUS LIKE '%Slow_queries%';
```

> 补充说明：
>
> 除了上述变量，控制慢查询日志的还有一个系统变量：min\_examined\_row\_limit。这个变量的意思是，`查询扫描过的最少记录`。这个变量和查询执行时间，共同组成了判别一个查询是否是慢查询的条件。如果查询扫描过的记录数大于等于这个变量的值，并且查询执行时间超过long\_query\_time的值，那么，这个查询就被记录到慢查询日志中；反之，则不被记录到慢查询日志中。
>
> ```sql
> show variables like 'min%';
>
> ```
>
> 这个值默认是0，与long\_query\_time=10合在一起，表示只要查询的执行时间超过10秒，哪怕一个记录也没有扫描过，都要被记录到慢查询日志中。你也可以根据需要，通过修改配置文件，来修改查询时长，或者通过SET指令，用SQL语句修改'min\_examined\_row\_limit'的值。

### 慢查询日志分析工具：mysqldumpslow

在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具 `mysqldumpslow` 。

查看mysqldumpslow的帮助信息

```sql
mysqldumpslow --help
```

![](image_r8W6krY-bZ.png)

mysqldumpslow 命令的具体参数如下：

-   \-a: 不将数字抽象成N，字符串抽象成S
-   \-s: 是表示按照何种方式排序：
    -   c: 访问次数
    -   l: 锁定时间
    -   r: 返回记录
    -   t: 查询时间
    -   al:平均锁定时间
    -   ar:平均返回记录数
    -   at:平均查询时间 （默认方式）
    -   ac:平均查询次数
-   \-t: 即为返回前面多少条的数据；
-   \-g: 后边搭配一个正则匹配模式，大小写不敏感的；

举例：我们想要按照查询时间排序，查看前五条 SQL 语句，这样写即可：

```sql
mysqldumpslow -s t -t 5 /var/lib/mysql/atguigu01-slow.log
```

```sql
[root@bogon ~]# mysqldumpslow -s t -t 5 /var/lib/mysql/atguigu01-slow.log

Reading mysql slow query log from /var/lib/mysql/atguigu01-slow.log
Count: 1 Time=2.39s (2s) Lock=0.00s (0s) Rows=13.0 (13), root[root]@localhost
SELECT * FROM student WHERE name = 'S'

Count: 1 Time=2.09s (2s) Lock=0.00s (0s) Rows=2.0 (2), root[root]@localhost
SELECT * FROM student WHERE stuno = N

Died at /usr/bin/mysqldumpslow line 162, <> chunk 2.
```

**工作常用参考：**

```sql
#得到返回记录集最多的10个SQL
mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log

#得到访问次数最多的10个SQL
mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log

#得到按照时间排序的前10条里面含有左连接的查询语句
mysqldumpslow -s t -t 10 -g "left join" /var/lib/mysql/atguigu-slow.log

#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况
mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more
```

### 关闭慢查询日志

MySQL服务器停止慢查询日志功能有两种方法：

#### 方式1：永久性方式

```sql
[mysqld]
slow_query_log=OFF
```

或者，把slow\_query\_log一项注释掉 或 删除

```sql
[mysqld]
#slow_query_log =OFF
```

重启MySQL服务，执行如下语句查询慢日志功能。

```sql
SHOW VARIABLES LIKE '%slow%'; #查询慢查询日志所在目录
SHOW VARIABLES LIKE '%long_query_time%'; #查询超时时长
```

#### 方式2：临时性方式

使用SET语句来设置。

1.  停止MySQL慢查询日志功能，具体SQL语句如下。
    ```sql
    SET GLOBAL slow_query_log=off;
    ```
2.  **重启MySQL服务**，使用SHOW语句查询慢查询日志功能信息，具体SQL语句如下。
    ```sql
    SHOW VARIABLES LIKE '%slow%';
    #以及
    SHOW VARIABLES LIKE '%long_query_time%';
    ```

### 删除慢查询日志

使用SHOW语句显示慢查询日志信息，具体SQL语句如下。

```sql
SHOW VARIABLES LIKE `slow_query_log%`;
```

![](image_CkCjxOtfSC.png)

从执行结果可以看出，慢查询日志的目录默认为MySQL的数据目录，在该目录下 `手动删除慢查询日志文件` 即可。

使用命令 `mysqladmin flush-logs` 来重新生成查询日志文件，具体命令如下，执行完毕会在数据目录下重新生成慢查询日志文件。

```sql
mysqladmin -uroot -p flush-logs slow
```

> 提示
> 慢查询日志都是使用mysqladmin flush-logs命令来删除重建的。使用时一定要注意，一旦执行了这个命令，慢查询日志都只存在新的日志文件中，如果需要旧的查询日志，就必须事先备份。

### 查看 SQL 执行成本：SHOW PROFILE

show profile 是 MySQL 提供的可以用来分析当前会话中 SQL 都做了什么、执行的资源消耗工具的情况，可用于 sql 调优的测量。`默认情况下处于关闭状态`，并保存最近15次的运行结果。

我们可以在会话级别开启这个功能。

```sql
mysql > show variables like 'profiling';
```

![](image_F8XoOmgWKI.png)

通过设置 profiling='ON' 来开启 show profile:

```sql
mysql > set profiling = 'ON';
```

然后执行相关的查询语句。接着看下当前会话都有哪些 profiles，使用下面这条命令：

```sql
mysql > show profiles;
```

![](image_euRB_UiXoj.png)

你能看到当前会话一共有 2 个查询。如果我们想要查看最近一次查询的开销，可以使用：

```sql
mysql > show profile;
```

![](image_r5AsHltS6N.png)

```sql
mysql> show profile cpu,block io for query 2
```

![](image_tF4RQ7bBiX.png)

**show profile的常用查询参数：**

① ALL：显示所有的开销信息。

② BLOCK IO：显示块IO开销。

③ CONTEXT SWITCHES：上下文切换开销。

④ CPU：显示CPU开销信息。

⑤ IPC：显示发送和接收开销信息。

⑥ MEMORY：显示内存开销信 息。

⑦ PAGE FAULTS：显示页面错误开销信息。

⑧ SOURCE：显示和Source\_function，Source\_file， Source\_line相关的开销信息。

⑨ SWAPS：显示交换次数开销信息。

**日常开发需注意的结论：**

① `converting HEAP to MyISAM`: 查询结果太大，内存不够，数据往磁盘上搬了。

② `Creating tmp table`：创建临时表。先拷贝数据到临时表，用完后再删除临时表。

③ `Copying to tmp table on disk`：把内存中临时表复制到磁盘上，警惕！

④ `locked`。

如果在show profile诊断结果中出现了以上4条结果中的任何一条，则sql语句需要优化。

**注意：**

不过SHOW PROFILE命令将被弃用，我们可以从 information\_schema 中的 profiling 数据表进行查看。

## 分析查询语句：EXPLAIN

### 概述

**定位了查询慢的SQL之后，我们就可以使用EXPLAIN或DESCRIBE工具做针对的分析查询语句。** DESCRIBE语句的使用方法与EXPLAIN语句是一样的，并且分析结果也是一样的。

MYSQL中有专门负责优化SELECT语句的优化器模块，主要功能：通过计算分析系统中收集到的统计信息，为客户端请求的Query提供它认为最优的`执行计划`。

这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。MYSQL为我们提供了`EXPLAIN`语句来帮助我们查看某个查询语句的具体执行计划，看懂`EXPLAIN`语句的各个输出项，可以有针对性的提升我们查询语句的性能。

**能做什么？**

-   表的读取顺序
-   数据读取操作的操作类型
-   哪些索引可以使用
-   **哪些索引被实际使用**
-   表之间的引用
-   **每张表有多少行被优化器查询**

### 基本语法

EXPLAIN 或 DESCRIBE语句的语法形式如下：

```sql
EXPLAIN SELECT select_options
或者
DESCRIBE SELECT select_options
```

如果我们想看看某个查询的执行计划的话，可以在具体的查询语句前边加一个 EXPLAIN ，就像这样：

```sql
mysql> EXPLAIN SELECT 1;
```

![](image_QyM4sDcXA3.png)

EXPLAIN 语句输出的各个列的作用如下：

![](image_AztLQ3XyhD.png)

### EXPLAIN各列作用

-   **table**

    不论我们的查询语句有多复杂，里边儿 包含了多少个表 ，到最后也是需要对每个表进行 单表访问 的，所 以MySQL规定EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该 表的表名（有时不是真实的表名字，可能是简称）。
    ```sql
    mysql > EXPLAIN SELECT * FROM s1;
    ```
    ![](image_SS_Y_FdJwB.png)

    这个查询语句只涉及对s1表的单表查询，所以 `EXPLAIN` 输出中只有一条记录，其中的table列的值为s1，表明这条记录是用来说明对s1表的单表访问方法的。

    下边我们看一个连接查询的执行计划
    ```sql
    mysql > EXPLAIN SELECT * FROM s1 INNER JOIN s2;
    ```
    ![](image_alRa5L1pG6.png)

    可以看出这个连接查询的执行计划中有两条记录，这两条记录的table列分别是s1和s2，这两条记录用来分别说明对s1表和s2表的访问方法是什么。
-   **id**

    我们写的查询语句一般都以 SELECT 关键字开头，比较简单的查询语句里只有一个 SELECT 关键字，比 如下边这个查询语句：
    ```sql
    SELECT * FROM s1 WHERE key1 = 'a';
    ```
    稍微复杂一点的连接查询中也只有一个 SELECT 关键字，比如：
    ```sql
    SELECT * FROM s1 INNER JOIN s2
    ON s1.key1 = s2.key1
    WHERE s1.common_field = 'a';
    ```
    但是下边两种情况下在一条查询语句中会出现多个SELECT关键字：

    ![](image_eVcUlQgeu3.png)
    ```sql
    mysql > EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';
    ```
    ![](image_IDTMQaQcix.png)

    对于连接查询来说，一个SELECT关键字后边的FROM字句中可以跟随多个表，所以在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的id值都是相同的，比如：

    ![](image_hP1ln7gJEo.png)

    可以看到，上述连接查询中参与连接的s1和s2表分别对应一条记录，但是这两条记录对应的`id`都是1。这里需要大家记住的是，**在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的**，出现在前边的表表示`驱动表`，出现在后面的表表示`被驱动表`。所以从上边的EXPLAIN输出中我们可以看到，查询优化器准备让s1表作为驱动表，让s2表作为被驱动表来执行查询。

    对于包含子查询的查询语句来说，就可能涉及多个`SELECT`关键字，所以在\*\*包含子查询的查询语句的执行计划中，每个`SELECT`关键字都会对应一个唯一的id值，比如这样：
    ```sql
    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = 'a';
    ```
    ![](image_ZRIQD9W9Te.png)

    ![](image_PEk9EfAmpP.png)
    ```sql
    # 查询优化器可能对涉及子查询的查询语句进行重写，转变为多表查询的操作。  
    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key2 FROM s2 WHERE common_field = 'a');
    ```
    ![](image_9Cmzw5_2Uo.png)

    可以看到，虽然我们的查询语句是一个子查询，但是执行计划中s1和s2表对应的记录的`id`值全部是1，这就表明`查询优化器将子查询转换为了连接查询`。

    对于包含`UNION`子句的查询语句来说，每个`SELECT`关键字对应一个`id`值也是没错的，不过还是有点儿特别的东西，比方说下边的查询：
    ```sql
    # Union去重
    mysql> EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;
    ```
    ![](image_ZUXXUdPNtv.png)

    ![](image_a_ygSkiL1H.png)
    ```sql
    mysql> EXPLAIN SELECT * FROM s1 UNION ALL SELECT * FROM s2;
    ```
    ![](image_eCMZslLq8o.png)

    **小结:**
    -   id如果相同，可以认为是一组，从上往下顺序执行
    -   在所有组中，id值越大，优先级越高，越先执行
    -   关注点：id号每个号码，表示一趟独立的查询, 一个sql的查询趟数越少越好
-   select\_type

    ![](image_HYRwQB3k8H.png)

    ![](image_v58g8L9q6f.png)
    -   PRIMARY

        对于包含`UNION、UNION ALL`或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的`select_type`的值就是`PRIMARY`。
    -   UNION

        对于包含`UNION`或者`UNION ALL`的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询意外，其余的小查询的`select_type`值就是UNION。
    -   UNION RESULT

        MySQL 选择使用临时表来完成`UNION`查询的去重工作，针对该临时表的查询的`select_type`就是`UNION RESULT`, 例子上边有。
    -   SUBQUERY

        如果包含子查询的查询语句不能够转为对应的`semi-join`的形式，并且该子查询是不相关子查询，并且查询优化器决定采用将该子查询物化的方案来执行该子查询时，该子查询的第一个`SELECT`关键字代表的那个查询的`select_type`就是`SUBQUERY`。
    -   DEPENDENT SUBQUERY
        ```sql
        mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE s1.key2 = s2.key2) OR key3 = 'a';
        ```
        ![](image_dp3JtqSEhu.png)
    -   DEPENDENT UNION
        ```sql
        mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE key1 = 'a' UNION SELECT key1 FROM s1 WHERE key1 = 'b');
        ```
        ![](image_v6cHf88D-S.png)
    -   DERIVED
        ```sql
        mysql> EXPLAIN SELECT * FROM (SELECT key1, count(*) as c FROM s1 GROUP BY key1) AS derived_s1 where c > 1;
        ```
        ![](image_RXrTK0nL-O.png)

        从执行计划中可以看出，id为2的记录就代表子查询的执行方式，它的select\_type是DERIVED, 说明该子查询是以物化的方式执行的。id为1的记录代表外层查询，大家注意看它的table列显示的是derived2，表示该查询时针对将派生表物化之后的表进行查询的。
-   type ☆

    执行计划的一条记录就代表着MySQL对某个表的 `执行查询时的访问方法` , 又称“访问类型”，其中的 `type` 列就表明了这个访问方法是啥，是较为重要的一个指标。比如，看到`type`列的值是`ref`，表明`MySQL`即将使用`ref`访问方法来执行对`s1`表的查询。

    完整的访问方法如下： `system ， const ， eq_ref ， ref ， fulltext ， ref_or_null ， index_merge ， unique_subquery ， index_subquery ， range ， index ， ALL` 。
    -   const

        当我们根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是`const`
    -   eq\_ref

        在连接查询时，如果`被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较）`。则对该被驱动表的访问方法就是eq\_ref
    -   ref

        当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是`ref`。
    -   fulltext

        全文索引
    -   ref\_or\_null

        当对普通二级索引进行等值匹配查询，该索引列的值也可以是`NULL`值时，那么对该表的访问方法就可能是`ref_or_null`。
    -   index\_merge

        一般情况下对于某个表的查询只能使用到一个索引，但单表访问方法时在某些场景下可以使用`Interseation、union、Sort-Union`这三种索引合并的方式来执行查询。我们看一下执行计划中是怎么体现MySQL使用索引合并的方式来对某个表执行查询的：
        ```sql
        mysql> EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' OR key3 = 'a';
        ```
        ![](image_lwjCDWMgZa.png)

        从执行计划的 `type` 列的值是 `index_merge` 就可以看出，MySQL 打算使用索引合并的方式来执行 对 s1 表的查询。
    -   unique\_subquery

        类似于两表连接中被驱动表的`eq_ref`访问方法，`unique_subquery`是针对在一些包含`IN`子查询的查询语句中，如果查询优化器决定将`IN`子查询转换为`EXISTS`子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的`type`列的值就是`unique_subquery`。
    -   index\_subquery

        `index_subquery` 与 `unique_subquery` 类似，只不过访问子查询中的表时使用的是普通的索引。
    -   range
        ```sql
        mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN ('a', 'b', 'c');
        ```
        ![](image_NnsJXrWm6f.png)
    -   index

        当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是`index`。
        ```sql
        mysql> EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = 'a';
        ```
        ![](image_sVezvfZCyh.png)

        上述查询中的所有列表中只有key\_part2 一个列，而且搜索条件中也只有 key\_part3 一个列，这两个列又恰好包含在idx\_key\_part这个索引中，可是搜索条件key\_part3不能直接使用该索引进行`ref`和`range`方式的访问，只能扫描整个`idx_key_part`索引的记录，所以查询计划的`type`列的值就是`index`。
    -   ALL

        全表扫描
        \*\*小结: \*\*
    \*\*结果值从最好到最坏依次是： \*\*

    **system > const > eq\_ref > ref** > fulltext > ref\_or\_null > index\_merge > unique\_subquery > index\_subquery > **range** > **index** > **ALL**

    **其中比较重要的几个提取出来（见上图中的粗体）。SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，最好是 consts级别。（阿里巴巴 开发手册要求）**
-   possible\_keys和key

    在EXPLAIN语句输出的执行计划中，`possible_keys`列表示在某个查询语句中，对某个列执行`单表查询时可能用到的索引`有哪些。一般查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。`key`列表示`实际用到的索引`有哪些，如果为NULL，则没有使用索引。
-   key\_len ☆

    实际使用到的索引长度 (即：字节数)

    帮你检查`是否充分的利用了索引`，`值越大越好`，主要针对于联合索引，有一定的参考意义。

    key\_len的长度计算公式：
    ```sql
    varchar(10)变长字段且允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+1(NULL)+2(变长字段)

    varchar(10)变长字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+2(变长字段)

    char(10)固定字段且允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+1(NULL)

    char(10)固定字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)
    ```
-   ref

    ![](image_x_yU9OrrbA.png)
-   rows ☆

    预估的需要读取的记录条数，`值越小越好`。
-   Extra ☆

    `Extra`列是用来说明一些额外信息的，包含不适合在其他列中显示但十分重要的额外信息。我们可以通过这些额外信息来`更准确的理解MySQL到底将如何执行给定的查询语句`。
    -   Impossible WHERE

        当查询语句的`WHERE`子句永远为`FALSE`时将会提示该额外信息
    -   Using where

        ![](image_YloCBOdI8Z.png)
        ```sql
        mysql> EXPLAIN SELECT * FROM s1 WHERE common_field = 'a';
        ```
        ![](image_AJf_1bo43g.png)
        ```sql
        mysql> EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' AND common_field = 'a';
        ```
        ![](image_17K11K709D.png)
    -   No matching min/max row

        当查询列表处有`MIN`或者`MAX`聚合函数，但是并没有符合`WHERE`子句中的搜索条件的记录时。
    -   Using index

        当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用覆盖索引的情况下，在`Extra`列将会提示该额外信息。比方说下边这个查询中只需要用到`idx_key1`而不需要回表操作:
        ```sql
        mysql> EXPLAIN SELECT key1 FROM s1 WHERE key1 = 'a';
        ```
        ![](image_VCfdMG9dGd.png)
    -   Using index condition

        有些搜索条件中虽然出现了索引列，但却不能使用到索引，比如下边这个查询：
        ```sql
        SELECT * FROM s1 WHERE key1 > 'z' AND key1 LIKE '%a';
        ```
        ![](image_BLaPreo9CU.png)

        ![](image_uAB2vf8rdN.png)
    -   Using join buffer (Block Nested Loop)

        在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，MySQL一般会为其分配一块名叫`join buffer`的内存块来加快查询速度，也就是我们所讲的`基于块的嵌套循环算法`。
    -   Not exists

        当我们使用左(外)连接时，如果`WHERE`子句中包含要求被驱动表的某个列等于`NULL`值的搜索条件，而且那个列是不允许存储`NULL`值的，那么在该表的执行计划的Extra列就会提示这个信息：
        ```sql
        mysql> EXPLAIN SELECT * FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.id IS NULL;
        ```
    -   Using intersect(...) 、 Using union(...) 和 Using sort\_union(...)

        如果执行计划的`Extra`列出现了`Using intersect(...)`提示，说明准备使用`Intersect`索引合并的方式执行查询，括号中的`...`表示需要进行索引合并的索引名称；

        如果出现`Using union(...)`提示，说明准备使用`Union`索引合并的方式执行查询;

        如果出现`Using sort_union(...)`提示，说明准备使用`Sort-Union`索引合并的方式执行查询。
    -   Zero limit

        当我们的`LIMIT`子句的参数为`0`时，表示压根儿不打算从表中读取任何记录
    -   Using filesort

        有一些情况下对结果集中的记录进行排序是可以使用到索引的。
    -   Using temporary

        ![](image_Fe_gAd-6IF.png)

#### &#x20;小结

-   EXPLAIN不考虑各种Cache
-   EXPLAIN不能显示MySQL在执行查询时所作的优化工作
-   EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况
-   部分统计信息是估算的，并非精确值

## EXPLAIN的进一步使用

### EXPLAIN四种输出格式

EXPLAIN可以输出四种格式： `传统格式` ，`JSON格式` ， `TREE格式` 以及 `可视化输出` 。用户可以根据需要选择适用于自己的格式。

#### 传统格式

传统格式简单明了，输出是一个表格形式，概要说明查询计划。

```sql
mysql> EXPLAIN SELECT s1.key1, s2.key1 FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.common_field IS NOT NULL;
```

![](image_oLYjmxJIyH.png)

#### JSON格式

第1种格式中介绍的`EXPLAIN`语句输出中缺少了一个衡量执行好坏的重要属性 —— `成本`。而JSON格式是四种格式里面输出`信息最详尽`的格式，里面包含了执行的成本信息。

-   JSON格式：在EXPLAIN单词和真正的查询语句中间加上 FORMAT=JSON 。

```sql
EXPLAIN FORMAT=JSON SELECT ....
```

-   EXPLAIN的Column与JSON的对应关系

    ![](image_DyooC0mhwd.png)

### SHOW WARNINGS的使用

在我们使用`EXPLAIN`语句查看了某个查询的执行计划后，紧接着还可以使用`SHOW WARNINGS`语句查看与这个查询的执行计划有关的一些扩展信息，比如这样：

```sql
mysql> EXPLAIN SELECT s1.key1, s2.key1 FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.common_field IS NOT NULL;
```

![](image_YOF2oiE3sH.png)

```sql
mysql> SHOW WARNINGS\G
*************************** 1. row ***************************
    Level: Note
     Code: 1003
Message: /* select#1 */ select `atguigu`.`s1`.`key1` AS `key1`,`atguigu`.`s2`.`key1`
AS `key1` from `atguigu`.`s1` join `atguigu`.`s2` where ((`atguigu`.`s1`.`key1` =
`atguigu`.`s2`.`key1`) and (`atguigu`.`s2`.`common_field` is not null))
1 row in set (0.00 sec)
```

大家可以看到`SHOW WARNINGS`展示出来的信息有三个字段，分别是`Level、Code、Message`。我们最常见的就是Code为1003的信息，当Code值为1003时，`Message`字段展示的信息类似于查询优化器将我们的查询语句重写后的语句。比如我们上边的查询本来是一个左(外)连接查询，但是有一个s2.common\_field IS NOT NULL的条件，这就会导致查询优化器把左(外)连接查询优化为内连接查询，从`SHOW WARNINGS`的`Message`字段也可以看出来，原本的LEFE JOIN已经变成了JOIN。

但是大家一定要注意，我们说`Message`字段展示的信息类似于查询优化器将我们的查询语句`重写后的语句`，并不是等价于，也就是说`Message`字段展示的信息并不是标准的查询语句，在很多情况下并不能直接拿到黑框框中运行，它只能作为帮助我们理解MySQL将如何执行查询语句的一个参考依据而已。

## MySQL监控分析视图-sys schema

![](image_fW42LsWlZO.png)

### Sys schema视图摘要

1.  **主机相关**：以host\_summary开头，主要汇总了IO延迟的信息。
2.  **Innodb相关**：以innodb开头，汇总了innodb buffer信息和事务等待innodb锁的信息。
3.  **I/o相关**：以io开头，汇总了等待I/O、I/O使用量情况。
4.  **内存使用情况**：以memory开头，从主机、线程、事件等角度展示内存的使用情况
5.  **连接与会话信息**：processlist和session相关视图，总结了会话相关信息。
6.  **表相关**：以schema\_table开头的视图，展示了表的统计信息。
7.  **索引信息**：统计了索引的使用情况，包含冗余索引和未使用的索引情况。
8.  **语句相关**：以statement开头，包含执行全表扫描、使用临时表、排序等的语句信息。
9.  **用户相关**：以user开头的视图，统计了用户使用的文件I/O、执行语句统计信息。
10. **等待事件相关信息**：以wait开头，展示等待事件的延迟情况。

### Sys schema视图使用场景

索引情况

```sql
#1. 查询冗余索引
select * from sys.schema_redundant_indexes;
#2. 查询未使用过的索引
select * from sys.schema_unused_indexes;
#3. 查询索引的使用情况
select index_name,rows_selected,rows_inserted,rows_updated,rows_deleted
from sys.schema_index_statistics where table_schema='dbname';
```

表相关

```sql
# 1. 查询表的访问量
select table_schema,table_name,sum(io_read_requests+io_write_requests) as io from
sys.schema_table_statistics group by table_schema,table_name order by io desc;
# 2. 查询占用bufferpool较多的表
select object_schema,object_name,allocated,data
from sys.innodb_buffer_stats_by_table order by allocated limit 10;
# 3. 查看表的全表扫描情况
select * from sys.statements_with_full_table_scans where db='dbname';
```

语句相关

```sql
#1. 监控SQL执行的频率
select db,exec_count,query from sys.statement_analysis
order by exec_count desc;
#2. 监控使用了排序的SQL
select db,exec_count,first_seen,last_seen,query
from sys.statements_with_sorting limit 1;
#3. 监控使用了临时表或者磁盘临时表的SQL
select db,exec_count,tmp_tables,tmp_disk_tables,query
from sys.statement_analysis where tmp_tables>0 or tmp_disk_tables >0
order by (tmp_tables+tmp_disk_tables) desc;
```

IO相关

```sql
#1. 查看消耗磁盘IO的文件
select file,avg_read,avg_write,avg_read+avg_write as avg_io
from sys.io_global_by_file_by_bytes order by avg_read limit 10;
```

Innodb 相关

```sql
#1. 行锁阻塞情况
select * from sys.innodb_lock_waits;
```

![](image_9H1E8MtVZW.png)

# 索引优化与查询优化

都有哪些维度可以进行数据库调优？简言之：

-   索引失效、没有充分利用到索引——建立索引
-   关联查询太多JOIN（设计缺陷或不得已的需求）——SQL优化
-   服务器调优及各个参数设置（缓冲、线程数等）——调整my.cnf
-   数据过多——分库分表

关于数据库调优的知识非常分散。不同的DBMS，不同的公司，不同的职位，不同的项目遇到的问题都不尽相同。这里我们分为三个章节进行细致讲解。

虽然SQL查询优化的技术有很多，但是大方向上完全可以分成`物理查询优化`和`逻辑查询优化`两大块。

-   物理查询优化是通过`索引`和`表连接方式`等技术来进行优化，这里重点需要掌握索引的使用。
-   逻辑查询优化就是通过SQL`等价变换`提升查询效率，直白一点就是说，换一种查询写法效率可能更高。

## 索引失效案例

Mysql中`提高性能`的一个最有效的方式是对表数据表`设计合理的索引`。索引提供了高效的访问数据方法，并且加快查询的速度，因此索引对查询的速度有着至关重要的影响。

-   使用索引可以`快速的定位`表中的某条记录，从而提高数据库查询的速度，提高数据库的性能。
-   如果查询时没有使用索引，查询语句就会扫描表中的所有记录。在数据量大的情况下，这样的查询速度会很慢。

大多数情况下默认采用B+树来构建索引。其实用不用索引，最终都是优化器说了算。优化器是基于什么的优化器？基于`cost开销`，它不是`基于规则`，也不是`基于语义`。怎么开销小就怎么来。另外，SQL语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。

### 全值匹配我最爱

```sql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age=30;
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age=30 AND classId=4;
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age=30 AND classId=4 AND name = 'abcd';
```

### 最佳左前缀法则

在MySQL建立联合索引时会遵守最佳左前缀原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。

```sql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age=30 AND student.name = 'abcd';
```

结论：MySQL可以为多个字段创建索引，一个索引可以包含16个字段。对于多列索引，**过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用**。如果查询条件中没有用这些字段中第一个字段时，多列（或联合）索引不会被使用。

### 主键插入顺序

我们自定义的主键列 `id` 拥有 `AUTO_INCREMENT` 属性，在插入记录时存储引擎会自动为我们填入自增的主键值。这样的主键占用空间小，顺序写入，减少页分裂。

### 计算、函数、类型转换(自动或手动)导致索引失效

```sql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE LEFT(student.name,3) = 'abc';
```

### 类型转换导致索引失效

```sql
# 未使用到索引
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name=123;
```

name=123发生类型转换，索引失效。

### 范围条件右边的列索引失效

```sql
create index idx_age_name_classId on student(age,name,classId);使用到该索引
create index idx_age_name_classId on student(age,classId，name);没有使用该索引
EXPLAIN SELECT SQL_NO_CACHE * FROM student
WHERE student.age=30 AND student.classId>20 AND student.name = 'abc' ;
```

应用开发中范围查询，例如：金额查询，日期查询往往都是范围查询。应将查询条件放置where语句最后。（创建的联合索引中，务必把范围涉及到的字段写在最后）

### 不等于(!= 或者<>)索引失效

### is null可以使用索引，is not null无法使用索引

### like以通配符%开头索引失效

在使用LIKE关键字进行查询的查询语句中，如果匹配字符串的第一个字符为'%'，索引就不会起作用。只有'%'不在第一个位置，索引才会起作用。

### OR 前后存在非索引的列，索引失效

在WHERE子句中，如果在OR前的条件列进行了索引，而在OR后的条件列没有进行索引，那么索引会失效。也就是说，**OR前后的两个条件中的列都是索引时，查询中才使用索引。**

因为OR的含义就是两个只要满足一个即可，因此`只有一个条件列进行了索引是没有意义的`，只要有条件列没有进行索引，就会进行`全表扫描`，因此所以的条件列也会失效。

```sql
# 未使用到索引
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 10 OR classid = 100;
```

因为classId字段上没有索引，所以上述查询语句没有使用索引。

```sql
#使用到索引
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 10 OR name = 'Abel';
```

因为age字段和name字段上都有索引，所以查询中使用了索引。你能看到这里使用到了`index_merge`，简单来说index\_merge就是对age和name分别进行了扫描，然后将这两个结果集进行了合并。这样做的好处就是`避免了全表扫描`。

### 数据库和表的字符集统一使用utf8mb4

统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不 同的 `字符集` 进行比较前需要进行 `转换` 会造成索引失效。

**一般性建议**

-   对于单列索引，尽量选择针对当前query过滤性更好的索引
-   在选择组合索引的时候，当前query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。
-   在选择组合索引的时候，尽量选择能够当前query中where子句中更多的索引。
-   在选择组合索引的时候，如果某个字段可能出现范围查询时，尽量把这个字段放在索引次序的最后面。

**总之，书写SQL语句时，尽量避免造成索引失效的情况**

## 关联查询优化

### 数据准备

```sql
# 分类
CREATE TABLE IF NOT EXISTS `type` (
`id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
`card` INT(10) UNSIGNED NOT NULL,
PRIMARY KEY (`id`)
);
#图书
CREATE TABLE IF NOT EXISTS `book` (
`bookid` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
`card` INT(10) UNSIGNED NOT NULL,
PRIMARY KEY (`bookid`)
);

#向分类表中添加20条记录
INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));

#向图书表中添加20条记录
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
```

### 采用左外连接

```sql
EXPLAIN SELECT SQL_NO_CACHE * FROM `type` LEFT JOIN book ON type.card = book.card;
```

![](image_S6gNJkw4oM.png)

结论：type 有All

添加索引优化

```sql
ALTER TABLE book ADD INDEX Y ( card); #【被驱动表】，可以避免全表扫描
EXPLAIN SELECT SQL_NO_CACHE * FROM `type` LEFT JOIN book ON type.card = book.card;
```

![](image_m8-_FadZqn.png)

可以看到第二行的 type 变为了 ref，rows 也变成了优化比较明显。这是由左连接特性决定的。LEFT JOIN 条件用于确定如何从右表搜索行，左边一定都有，`所以 右边是我们的关键点,一定需要建立索引 。`

### 采用内连接

```sql
drop index X on type;
drop index Y on book;（如果已经删除了可以不用再执行该操作）
```

换成 inner join（MySQL自动选择驱动表）

```sql
EXPLAIN SELECT SQL_NO_CACHE * FROM type INNER JOIN book ON type.card=book.card;
```

![](image_BEmBssd6Wy.png)

添加索引优化

```sql
ALTER TABLE book ADD INDEX Y (card);
EXPLAIN SELECT SQL_NO_CACHE * FROM type INNER JOIN book ON type.card=book.card;
```

![](image_ZodVgj3dT-.png)

```sql
ALTER TABLE type ADD INDEX X (card);
EXPLAIN SELECT SQL_NO_CACHE * FROM type INNER JOIN book ON type.card=book.card;
```

![](image_-pdsS3qeW-.png)

对于内连接来说，查询优化器可以决定谁作为驱动表，谁作为被驱动表出现的，当连接条件中`哪个表添加了索引，哪个表就可能做为被驱动表`，两个表连接条件都没有使用索引时，数据量大的表一般也做为被驱动表。

### join语句原理

join方式连接多个表，本质就是各个表之间数据的循环匹配。MySQL5.5版本之前，MySQL只支持一种表间关联方式，就是嵌套循环(Nested Loop Join)。如果关联表的数据量很大，则join关联的执行时间会很长。在MySQL5.5以后的版本中，MySQL通过引入BNLJ算法来优化嵌套执行。

#### 驱动表和被驱动表

驱动表就是主表，被驱动表就是从表、非驱动表。

-   对于内连接来说：

```sql
SELECT * FROM A JOIN B ON ...
```

A一定是驱动表吗？不一定，优化器会根据你查询语句做优化，决定先查哪张表。先查询的那张表就是驱动表，反之就是被驱动表。通过explain关键字可以查看。

-   对于外连接来说：

```sql
SELECT * FROM A LEFT JOIN B ON ...
# 或
SELECT * FROM B RIGHT JOIN A ON ... 
```

通常，会认为A就是驱动表，B就是被驱动表。但也未必。

#### Simple Nested-Loop Join (简单嵌套循环连接)

算法相当简单，从表A中取出一条数据1，遍历表B，将匹配到的数据放到result.. 以此类推，驱动表A中的每一条记录与被驱动表B的记录进行判断：

![](image_U5-usZeE4n.png)

可以看到这种方式效率是非常低的，以上述表A数据100条，表B数据1000条计算，则A\*B=10万次。开销统计如下:

![](image_djgFDLKy7J.png)

当然mysql肯定不会这么粗暴的去进行表的连接，所以就出现了后面的两种对Nested-Loop Join优化算法。

#### Index Nested-Loop Join （索引嵌套循环连接）

ndex Nested-Loop Join其优化的思路主要是为了`减少内存表数据的匹配次数`，所以要求被驱动表上必须`有索引`才行。通过外层表匹配条件直接与内层表索引进行匹配，避免和内存表的每条记录去进行比较，这样极大的减少了对内存表的匹配次数。

![](image_a_i1odK6cy.png)

驱动表中的每条记录通过被驱动表的索引进行访问，因为索引查询的成本是比较固定的，故mysql优化器都倾向于使用记录数少的表作为驱动表（外表）。

![](image_CUt4tg4E56.png)

#### Block Nested-Loop Join（块嵌套循环连接）

![](image_2kLDaUyDIE.png)

注意：

这里缓存的不只是关联表的列，select后面的列也会缓存起来。

在一个有N个join关联的sql中会分配N-1个join buffer。所以查询的时候尽量减少不必要的字段，可以让join buffer中可以存放更多的列。

![](image_nFLmNwvbVi.png)

![](image_C8aYvEKsfx.png)

参数设置：

-   block\_nested\_loop

通过`show variables like '%optimizer_switch%` 查看 `block_nested_loop`状态。默认是开启的。

-   join\_buffer\_size

驱动表能不能一次加载完，要看join buffer能不能存储所有的数据，默认情况下`join_buffer_size=256k`。

```sql
mysql> show variables like '%join_buffer%';
```

join\_buffer\_size的最大值在32位操作系统可以申请4G，而在64位操作系统下可以申请大于4G的Join Buffer空间（64位Windows除外，其大值会被截断为4GB并发出警告）。

#### Join小结

1、**整体效率比较：INLJ > BNLJ > SNLJ**

2、永远用小结果集驱动大结果集（其本质就是减少外层循环的数据数量）（小的度量单位指的是表行数 \* 每行大小）

```sql
select t1.b,t2.* from t1 straight_join t2 on (t1.b=t2.b) where t2.id<=100; # 推荐
select t1.b,t2.* from t2 straight_join t1 on (t1.b=t2.b) where t2.id<=100; # 不推荐
```

3、为被驱动表匹配的条件增加索引(减少内存表的循环匹配次数)

4、增大join buffer size的大小（一次索引的数据越多，那么内层包的扫描次数就越少）

5、减少驱动表不必要的字段查询（字段越少，join buffer所缓存的数据就越多）

#### 6. Hash Join

**从MySQL的8.0.20版本开始将废弃BNLJ，因为从MySQL8.0.18版本开始就加入了hash join默认都会使用hash join**

-   Nested Loop:

    对于被连接的数据子集较小的情况，Nested Loop是个较好的选择。
-   Hash Join是做`大数据集连接`时的常用方式，优化器使用两个表中较小（相对较小）的表利用Join Key在内存中建立`散列表`，然后扫描较大的表并探测散列表，找出与Hash表匹配的行。
    -   这种方式适合于较小的表完全可以放于内存中的情况，这样总成本就是访问两个表的成本之和。
    -   在表很大的情况下并不能完全放入内存，这时优化器会将它分割成`若干不同的分区`，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高I/O的性能。
    -   它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。大多数人都说它是Join的重型升降机。Hash Join只能应用于等值连接（如WHERE A.COL1 = B.COL2），这是由Hash的特点决定的。

![](image_HdALnAGpvz.png)

### 小结

-   保证被驱动表的JOIN字段已经创建了索引
-   需要JOIN 的字段，数据类型保持绝对一致。
-   LEFT JOIN 时，选择小表作为驱动表， 大表作为被驱动表 。减少外层循环的次数。
-   INNER JOIN 时，MySQL会自动将 小结果集的表选为驱动表 。选择相信MySQL优化策略。
-   能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数)
-   不建议使用子查询，建议将子查询SQL拆开结合程序多次查询，或使用 JOIN 来代替子查询。
-   衍生表建不了索引

## 子查询优化

MySQL从4.1版本开始支持子查询，使用子查询可以进行SELECT语句的嵌套查询，即一个SELECT查询的结 果作为另一个SELECT语句的条件。 `子查询可以一次性完成很多逻辑上需要多个步骤才能完成的SQL操作` 。

**子查询是 MySQL 的一项重要的功能，可以帮助我们通过一个 SQL 语句实现比较复杂的查询。但是，子 查询的执行效率不高。** 原因：

① 执行子查询时，MySQL需要为内层查询语句的查询结果 建立一个临时表 ，然后外层查询语句从临时表 中查询记录。查询完毕后，再 撤销这些临时表 。这样会消耗过多的CPU和IO资源，产生大量的慢查询。

② 子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都 不会存在索引 ，所以查询性能会 受到一定的影响。

③ 对于返回结果集比较大的子查询，其对查询性能的影响也就越大。

**在MySQL中，可以使用连接（JOIN）查询来替代子查询。** 连接查询`不需要建立临时表` ，其 `速度比子查询` 要快 ，如果查询中使用索引的话，性能就会更好。

> 结论：尽量不要使用NOT IN或者NOT EXISTS，用LEFT JOIN xxx ON xx WHERE xx IS NULL替代

## 排序优化

在MySQL中，支持两种排序方式，分别是 `FileSort` 和 `Index` 排序。

-   Index 排序中，索引可以保证数据的有序性，不需要再进行排序，`效率更高`。
-   FileSort 排序则一般在 `内存中` 进行排序，占用`CPU较多`。如果待排结果较大，会产生临时文件 I/O 到磁盘进行排序的情况，效率较低。

**优化建议：**

1.  SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中 `避免全表扫描` ，在 ORDER BY 子句 `避免使用 FileSort 排序` 。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。
2.  尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列； 如果不同就使用联合索引。
3.  无法使用 Index 时，需要对 FileSort 方式进行调优。

## GROUP BY优化

-   group by 使用索引的原则几乎跟order by一致 ，group by 即使没有过滤条件用到索引，也可以直接使用索引。
-   group by 先排序再分组，遵照索引建的最佳左前缀法则
-   当无法使用索引列，增大 max\_length\_for\_sort\_data 和 sort\_buffer\_size 参数的设置
-   where效率高于having，能写在where限定的条件就不要写在having中了
-   减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。
-   包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行 以内，否则SQL会很慢。

## 优化分页查询

![](image_4pRaxElSUg.png)

**优化思路一**

在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。

```sql
EXPLAIN SELECT * FROM student t,(SELECT id FROM student ORDER BY id LIMIT 2000000,10) a WHERE t.id = a.id;
```

![](image_abjXLomiyh.png)

**优化思路二**

该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询 。

```sql
EXPLAIN SELECT * FROM student WHERE id > 2000000 LIMIT 10;
```

![](image_6G8YOpxsZV.png)

# 事务

## 基本概念

事务：一组逻辑操作单元，使数据从一种状态变换到另一种状态。

**事务处理的原则：** 保证所有事务都作为`一个工作单元` 来执行，即使出现了故障，都不能改变这种执行方 式。当在一个事务中执行多个操作时，要么所有的事务都被提交( `commit` )，那么这些修改就 `永久` 地保 `存下来`；要么数据库管理系统将 `放弃` 所作的所有 `修改` ，整个事务回滚( rollback )到最初状态。

## 事物的ACID特性

-   **原子性（atomicity）：**

    原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。即要么转账成功，要么转账失败，是不存在中间的状态。如果无法保证原子性会怎么样？就会出现数据不一致的情形，A账户减去100元，而B账户增加100元操作失败，系统将无故丢失100元。
-   **一致性（consistency）：**

    （国内很多网站上对一致性的阐述有误，具体你可以参考 Wikipedia 对Consistency的阐述）

    根据定义，一致性是指事务执行前后，数据从一个 `合法性状态` 变换到另外一个 `合法性状态` 。这种状态是 `语义上` 的而不是语法上的，跟具体的业务有关。

    那什么是合法的数据状态呢？满足 `预定的约束` 的状态就叫做合法的状态。通俗一点，这状态是由你自己来定义的（比如满足现实世界中的约束）。满足这个状态，数据就是一致的，不满足这个状态，数据就 是不一致的！如果事务中的某个操作失败了，系统就会自动撤销当前正在执行的事务，返回到事务操作 之前的状态。

    **举例1：** A账户有200元，转账300元出去，此时A账户余额为-100元。你自然就发现此时数据是不一致的，为什么呢？因为你定义了一个状态，余额这列必须>=0。

    **举例2：** A账户有200元，转账50元给B账户，A账户的钱扣了，但是B账户因为各种意外，余额并没有增加。你也知道此时的数据是不一致的，为什么呢？因为你定义了一个状态，要求A+B的总余额必须不变。

    **举例3：** 在数据表中我们将`姓名`字段设置为`唯一性约束`，这时当事务进行提交或者事务发生回滚的时候，如果数据表的姓名不唯一，就破坏了事物的一致性要求。
-   **隔离型（isolation）：**

    事务的隔离性是指一个事务的执行`不能被其他事务干扰`，即一个事务内部的操作及使用的数据对`并发`的其他事务是隔离的，并发执行的各个事务之间不能相互干扰。
    ```sql
    UPDATE accounts SET money = money - 50 WHERE NAME = 'AA';
    UPDATE accounts SET money = money + 50 WHERE NAME = 'BB';
    ```
    ![](image_3BZEGqx5iL.png)
-   **持久性（durability）：**

    持久性是指一个事务一旦被提交，它对数据库中数据的改变就是 永久性的 ，接下来的其他操作和数据库 故障不应该对其有任何影响。

    持久性是通过 `事务日志` 来保证的。日志包括了 `重做日志` 和 `回滚日志` 。当我们通过事务对数据进行修改 的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做 的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执 行，从而使事务具有持久性。

#### 总结

ACID是事务的四大特征，在这四个特性中，原子性是基础，隔离性是手段，一致性是约束条件， 而持久性是我们的目的。

数据库事务，其实就是数据库设计者为了方便起见，把需要保证`原子性`、`隔离性`、`一致性`和`持久性`的一个或多个数据库操作称为一个事务。

## 事务的状态

我们现在知道 `事务` 是一个抽象的概念，它其实对应着一个或多个数据库操作，MySQL根据这些操作所执 行的不同阶段把 `事务` 大致划分成几个状态：

-   **活动的（active）**

    事务对应的数据库操作正在执行过程中时，我们就说该事务处在 `活动的` 状态。
-   **部分提交的（partially committed）**

    当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并 `没有刷新到磁盘` 时，我们就说该事务处在 `部分提交的` 状态。
-   **失败的（failed）**

    当事务处在 `活动的` 或者 部分提交的 状态时，可能遇到了某些错误（数据库自身的错误、操作系统 错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在 失 败的 状态。
-   **中止的（aborted）**

    如果事务执行了一部分而变为 `失败的` 状态，那么就需要把已经修改的事务中的操作还原到事务执 行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为 `回滚` 。当 `回滚` 操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事 务处在了 `中止的` 状态。
-   **提交的（committed）**

    当一个处在 `部分提交的` 状态的事务将修改过的数据都 `同步到磁盘` 上之后，我们就可以说该事务处在了 `提交的` 状态。

    一个基本的状态转换图如下所示：

    ![](image_1eUx5EjCHa.png)

## 如何使用事务

使用事务有两种方式，分别为 `显式事务` 和 `隐式事务` 。

### 显式事务

**步骤1：** START TRANSACTION 或者 BEGIN ，作用是显式开启一个事务。

```sql
mysql> BEGIN;
#或者
mysql> START TRANSACTION;
```

`START TRANSACTION` 语句相较于 `BEGIN` 特别之处在于，后边能跟随几个 `修饰符` ：

① `READ ONLY` ：标识当前事务是一个 `只读事务` ，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。

> 补充：只读事务中只是不允许修改那些其他事务也能访问到的表中的数据，对于临时表来说（我们使用 CREATE TMEPORARY TABLE 创建的表），由于它们只能再当前会话中可见，所有只读事务其实也是可以对临时表进行增、删、改操作的。

② `READ WRITE` ：标识当前事务是一个 `读写事务` ，也就是属于该事务的数据库操作既可以读取数据， 也可以修改数据。

③ `WITH CONSISTENT SNAPSHOT` ：启动一致性读。

注意：

-   `READ ONLY`和`READ WRITE`是用来设置所谓的事物`访问模式`的，就是以只读还是读写的方式来访问数据库中的数据，一个事务的访问模式不能同时即设置为`只读`的也设置为`读写`的，所以不能同时把`READ ONLY`和`READ WRITE`放到`START TRANSACTION`语句后边。
-   如果我们不显式指定事务的访问模式，那么该事务的访问模式就是`读写`模式

**步骤2：** 一系列事务中的操作（主要是DML，不含DDL）

**步骤3：** 提交事务 或 中止事务（即回滚事务）

### 隐式事务

MySQL中有一个系统变量 `autocommit` ：

当然，如果我们想关闭这种 `自动提交` 的功能，可以使用下边两种方法之一：

-   显式的的使用 `START TRANSACTION` 或者 `BEGIN` 语句开启一个事务。这样在本次事务提交或者回滚前会暂时关闭掉自动提交的功能。
-   把系统变量 `autocommit` 的值设置为 `OFF` ，就像这样：
    ```sql
    SET autocommit = OFF;
    #或
    SET autocommit = 0;
    ```

### 隐式提交数据的情况

**数据定义语言（Data definition language，缩写为：DDL）**

数据库对象，指的就是`数据库、表、视图、存储过程`等结构。当我们`CREATE、ALTER、DROP`等语句去修改数据库对象时，就会隐式的提交前边语句所属于的事物。即：

**隐式使用或修改mysql数据库中的表**

当我们使用`ALTER USER`、`CREATE USER`、`DROP USER`、`GRANT`、`RENAME USER`、`REVOKE`、`SET PASSWORD`等语句时也会隐式的提交前边语句所属于的事务。

**事务控制或关于锁定的语句**

&#x20;   ① 当我们在一个事务还没提交或者回滚时就又使用 START TRANSACTION 或者 BEGIN 语句开启了另一个事务时，会隐式的提交上一个事务。

② 当前的 autocommit 系统变量的值为 OFF ，我们手动把它调为 ON 时，也会 隐式的提交前边语句所属的事务。

③ 使用 LOCK TABLES 、 UNLOCK TABLES 等关于锁定的语句也会 隐式的提交 前边语句所属的事务。

-   加载数据的语句

    使用`LOAD DATA`语句来批量往数据库中导入数据时，也会`隐式的提交`前边语句所属的事务。
-   关于MySQL复制的一些语句

    使用`START SLAVE、STOP SLAVE、RESET SLAVE、CHANGE MASTER TO`等语句会隐式的提交前边语句所属的事务
-   其他的一些语句

    使用`ANALYZE TABLE、CACHE INDEX、CAECK TABLE、FLUSH、LOAD INDEX INTO CACHE、OPTIMIZE TABLE、REPAIR TABLE、RESET`等语句也会隐式的提交前边语句所属的事务。

## 事务隔离级别

MySQL是一个 `客户端／服务器` 架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每 个客户端与服务器连接上之后，就可以称为一个会话（ `Session` ）。每个客户端都可以在自己的会话中 向服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是对于服务器来说可能同时处理多个事务。事务有 `隔离性` 的特性，理论上在某个事务 `对某个数据进行访问` 时，其他事务应该进行`排队` ，当该事务提交之后，其他事务才可以继续访问这个数据。但是这样对 `性能影响太大` ，我们既想保持事务的隔离性，又想让服务器在处理访问同一数据的多个事务时 `性能尽量高些` ，那就看二者如何权衡取 舍了。

### 数据并发问题

**脏写（ Dirty Write ）**

对于两个事务 Session A、Session B，如果事务Session A `修改了` 另一个 `未提交` 事务Session B `修改过` 的数据，那就意味着发生了 `脏写`，示意图如下：

![](image_vNNDsKU6W3.png)

Session A 和 Session B 各开启了一个事务，Sesssion B 中的事务先将studentno列为1的记录的name列更新为'李四'，然后Session A中的事务接着又把这条studentno列为1的记录的name列更新为'张三'。如果之后Session B中的事务进行了回滚，那么Session A中的更新也将不复存在，这种现象称之为脏写。这时Session A中的事务就没有效果了，明明把数据更新了，最后也提交事务了，最后看到的数据什么变化也没有。这里大家对事务的隔离性比较了解的话，会发现默认隔离级别下，上面Session A中的更新语句会处于等待状态，这里只是跟大家说明一下会出现这样的现象。

**脏读（ Dirty Read ）**

对于两个事务 Session A、Session B，Session A `读取` 了已经被 Session B `更新` 但还 `没有被提交` 的字段。 之后若 Session B `回滚` ，Session A `读取` 的内容就是 `临时且无效` 的。

![](image_-nOWbodmur.png)

Session A和Session B各开启了一个事务，Session B中的事务先将studentno列为1的记录的name列更新 为'张三'，然后Session A中的事务再去查询这条studentno为1的记录，如果读到列name的值为'张三'，而 Session B中的事务稍后进行了回滚，那么Session A中的事务相当于读到了一个不存在的数据，这种现象就称之为 `脏读` 。

**不可重复读（ Non-Repeatable Read ）**

对于两个事务Session A、Session B，Session A `读取`了一个字段，然后 Session B `更新`了该字段。 之后 Session A `再次读取` 同一个字段， `值就不同` 了。那就意味着发生了不可重复读。

![](image_6wWmuZd78_.png)

我们在Session B中提交了几个 `隐式事务` （注意是隐式事务，意味着语句结束事务就提交了），这些事务 都修改了studentno列为1的记录的列name的值，每次事务提交之后，如果Session A中的事务都可以查看到最新的值，这种现象也被称之为 `不可重复读` 。

**幻读（ Phantom ）**

对于两个事务Session A、Session B, Session A 从一个表中 `读取` 了一个字段, 然后 Session B 在该表中 插 入 了一些新的行。 之后, 如果 Session A `再次读取` 同一个表, 就会多出几行。那就意味着发生了`幻读`。

![](image_cKfdiC86DQ.png)

Session A中的事务先根据条件 studentno > 0这个条件查询表student，得到了name列值为'张三'的记录； 之后Session B中提交了一个 `隐式事务` ，该事务向表student中插入了一条新记录；之后Session A中的事务 再根据相同的条件 studentno > 0查询表student，得到的结果集中包含Session B中的事务新插入的那条记 录，这种现象也被称之为 幻读 。我们把新插入的那些记录称之为 `幻影记录` 。

## SQL中的四种隔离级别

上面介绍了几种并发事务执行过程中可能遇到的一些问题，这些问题有轻重缓急之分，我们给这些问题 按照严重性来排一下序：

```sql
脏写 > 脏读 > 不可重复读 > 幻读
```

我们愿意舍弃一部分隔离性来换取一部分性能在这里就体现在：设立一些隔离级别，隔离级别越低，并发问题发生的就越多。 `SQL标准` 中设立了4个 `隔离级别` ：

-   `READ UNCOMMITTED` ：读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结 果。不能避免脏读、不可重复读、幻读。
-   `READ COMMITTED` ：读已提交，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做 的改变。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可 重复读、幻读问题仍然存在。
-   `REPEATABLE READ` ：可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提 交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍 然存在。这是MySQL的默认隔离级别。
-   `SERIALIZABLE` ：可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止 其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避 免脏读、不可重复读和幻读。

`SQL标准` 中规定，针对不同的隔离级别，并发事务可以发生不同严重程度的问题，具体情况如下：

![](image_4vulWIshRa.png)

`脏写` 怎么没涉及到？因为脏写这个问题太严重了，不论是哪种隔离级别，都不允许脏写的情况发生。

不同的隔离级别有不同的现象，并有不同的锁和并发机制，隔离级别越高，数据库的并发性能就越差，4 种事务隔离级别与并发性能的关系如下：

![](image_FePRub8B6j.png)

### MySQL支持的四种隔离级别

![](image_axuLLY1fMT.png)

MySQL的默认隔离级别为REPEATABLE READ，我们可以手动修改一下事务的隔离级别。

```sql
# 查看隔离级别，MySQL 5.7.20的版本之前：
mysql> SHOW VARIABLES LIKE 'tx_isolation';
+---------------+-----------------+
| Variable_name | Value           |
+---------------+-----------------+
| tx_isolation  | REPEATABLE-READ |
+---------------+-----------------+
1 row in set (0.00 sec)
# MySQL 5.7.20版本之后，引入transaction_isolation来替换tx_isolation

# 查看隔离级别，MySQL 5.7.20的版本及之后：
mysql> SHOW VARIABLES LIKE 'transaction_isolation';
+-----------------------+-----------------+
| Variable_name         | Value           |
+-----------------------+-----------------+
| transaction_isolation | REPEATABLE-READ |
+-----------------------+-----------------+
1 row in set (0.02 sec)

#或者不同MySQL版本中都可以使用的：
SELECT @@transaction_isolation;
```

### 如何设置事务的隔离级别

通过下面的语句修改事务的隔离级别：

```sql
SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL 隔离级别;
#其中，隔离级别格式：
> READ UNCOMMITTED
> READ COMMITTED
> REPEATABLE READ
> SERIALIZABLE
```

或者：

```sql
SET [GLOBAL|SESSION] TRANSACTION_ISOLATION = '隔离级别'
#其中，隔离级别格式：
> READ-UNCOMMITTED
> READ-COMMITTED
> REPEATABLE-READ
> SERIALIZABLE
```

**关于设置时使用GLOBAL或SESSION的影响：**

-   **使用 GLOBAL 关键字（在全局范围影响）：**
    ```sql
    SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;
    #或
    SET GLOBAL TRANSACTION_ISOLATION = 'SERIALIZABLE';
    ```
    则：

    当前已经存在的会话无效
    只对执行完该语句之后产生的会话起作用
-   **使用 SESSION 关键字（在会话范围影响）：**
    ```sql
    SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;
    #或
    SET SESSION TRANSACTION_ISOLATION = 'SERIALIZABLE';
    ```
    则：

    对当前会话的所有后续的事务有效
    如果在事务之间执行，则对后续的事务有效
    该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务

如果在服务器启动时想改变事务的默认隔离级别，可以修改启动参数`transaction_isolation`的值。比如，在启动服务器时指定了`transaction_isolation=SERIALIZABLE`，那么事务的默认隔离界别就从原来的`REPEATABLE-READ`变成了`SERIALIZABLE`。
